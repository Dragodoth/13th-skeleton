import {
  TokContext,
  TokenType,
  acorn_exports,
  keywords,
  types$1
} from "./chunk-L424AFVK.js";

// node_modules/acorn-typescript/lib/index.mjs
function a(t, e) {
  for (var s = 0; s < e.length; s++) {
    var i = e[s];
    i.enumerable = i.enumerable || false, i.configurable = true, "value" in i && (i.writable = true), Object.defineProperty(t, "symbol" == typeof (r = function(t2, e2) {
      if ("object" != typeof t2 || null === t2) return t2;
      var s2 = t2[Symbol.toPrimitive];
      if (void 0 !== s2) {
        var i2 = s2.call(t2, "string");
        if ("object" != typeof i2) return i2;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return String(t2);
    }(i.key)) ? r : String(r), i);
  }
  var r;
}
function n() {
  return n = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var s = arguments[e];
      for (var i in s) Object.prototype.hasOwnProperty.call(s, i) && (t[i] = s[i]);
    }
    return t;
  }, n.apply(this, arguments);
}
function o(t, e) {
  t.prototype = Object.create(e.prototype), t.prototype.constructor = t, h(t, e);
}
function h(t, e) {
  return h = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
    return t2.__proto__ = e2, t2;
  }, h(t, e);
}
function p(t, e) {
  (null == e || e > t.length) && (e = t.length);
  for (var s = 0, i = new Array(e); s < e; s++) i[s] = t[s];
  return i;
}
function c(t, e) {
  var s = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
  if (s) return (s = s.call(t)).next.bind(s);
  if (Array.isArray(t) || (s = function(t2, e2) {
    if (t2) {
      if ("string" == typeof t2) return p(t2, e2);
      var s2 = Object.prototype.toString.call(t2).slice(8, -1);
      return "Object" === s2 && t2.constructor && (s2 = t2.constructor.name), "Map" === s2 || "Set" === s2 ? Array.from(t2) : "Arguments" === s2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(s2) ? p(t2, e2) : void 0;
    }
  }(t)) || e && t && "number" == typeof t.length) {
    s && (t = s);
    var i = 0;
    return function() {
      return i >= t.length ? { done: true } : { done: false, value: t[i++] };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
var l = true;
function u(t, e) {
  return void 0 === e && (e = {}), new TokenType("name", e);
}
var d = /* @__PURE__ */ new WeakMap();
function m(t) {
  var a2 = d.get(t.Parser.acorn || t);
  if (!a2) {
    var o2 = { assert: u(0, { startsExpr: l }), asserts: u(0, { startsExpr: l }), global: u(0, { startsExpr: l }), keyof: u(0, { startsExpr: l }), readonly: u(0, { startsExpr: l }), unique: u(0, { startsExpr: l }), abstract: u(0, { startsExpr: l }), declare: u(0, { startsExpr: l }), enum: u(0, { startsExpr: l }), module: u(0, { startsExpr: l }), namespace: u(0, { startsExpr: l }), interface: u(0, { startsExpr: l }), type: u(0, { startsExpr: l }) }, h2 = { at: new TokenType("@"), jsxName: new TokenType("jsxName"), jsxText: new TokenType("jsxText", { beforeExpr: true }), jsxTagStart: new TokenType("jsxTagStart", { startsExpr: true }), jsxTagEnd: new TokenType("jsxTagEnd") }, p2 = { tc_oTag: new TokContext("<tag", false, false), tc_cTag: new TokContext("</tag", false, false), tc_expr: new TokContext("<tag>...</tag>", true, true) }, c2 = new RegExp("^(?:" + Object.keys(o2).join("|") + ")$");
    h2.jsxTagStart.updateContext = function() {
      this.context.push(p2.tc_expr), this.context.push(p2.tc_oTag), this.exprAllowed = false;
    }, h2.jsxTagEnd.updateContext = function(t2) {
      var s = this.context.pop();
      s === p2.tc_oTag && t2 === types$1.slash || s === p2.tc_cTag ? (this.context.pop(), this.exprAllowed = this.curContext() === p2.tc_expr) : this.exprAllowed = true;
    }, a2 = { tokTypes: n({}, o2, h2), tokContexts: n({}, p2), keywordsRegExp: c2, tokenIsLiteralPropertyName: function(t2) {
      return [types$1.name, types$1.string, types$1.num].concat(Object.values(keywords), Object.values(o2)).includes(t2);
    }, tokenIsKeywordOrIdentifier: function(t2) {
      return [types$1.name].concat(Object.values(keywords), Object.values(o2)).includes(t2);
    }, tokenIsIdentifier: function(t2) {
      return [].concat(Object.values(o2), [types$1.name]).includes(t2);
    }, tokenIsTSDeclarationStart: function(t2) {
      return [o2.abstract, o2.declare, o2.enum, o2.module, o2.namespace, o2.interface, o2.type].includes(t2);
    }, tokenIsTSTypeOperator: function(t2) {
      return [o2.keyof, o2.readonly, o2.unique].includes(t2);
    }, tokenIsTemplate: function(t2) {
      return t2 === types$1.invalidTemplate;
    } };
  }
  return a2;
}
var f = 1024;
var y = new RegExp("(?:[^\\S\\n\\r\\u2028\\u2029]|\\/\\/.*|\\/\\*.*?\\*\\/)*", "y");
var x = new RegExp("(?=(" + y.source + "))\\1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, "y");
var T = function() {
  this.shorthandAssign = void 0, this.trailingComma = void 0, this.parenthesizedAssign = void 0, this.parenthesizedBind = void 0, this.doubleProto = void 0, this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
};
function v(t, e) {
  var s = e.key.name, i = t[s], r = "true";
  return "MethodDefinition" !== e.type || "get" !== e.kind && "set" !== e.kind || (r = (e.static ? "s" : "i") + e.kind), "iget" === i && "iset" === r || "iset" === i && "iget" === r || "sget" === i && "sset" === r || "sset" === i && "sget" === r ? (t[s] = "true", false) : !!i || (t[s] = r, false);
}
function P(t, e) {
  var s = t.key;
  return !t.computed && ("Identifier" === s.type && s.name === e || "Literal" === s.type && s.value === e);
}
var b = { AbstractMethodHasImplementation: function(t) {
  return "Method '" + t.methodName + "' cannot have an implementation because it is marked abstract.";
}, AbstractPropertyHasInitializer: function(t) {
  return "Property '" + t.propertyName + "' cannot have an initializer because it is marked abstract.";
}, AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.", AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.", CannotFindName: function(t) {
  return "Cannot find name '" + t.name + "'.";
}, ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.", ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.", ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.", ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.", DeclareAccessor: function(t) {
  return "'declare' is not allowed in " + t.kind + "ters.";
}, DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.", DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.", DuplicateAccessibilityModifier: function() {
  return "Accessibility modifier already seen.";
}, DuplicateModifier: function(t) {
  return "Duplicate modifier: '" + t.modifier + "'.";
}, EmptyHeritageClauseType: function(t) {
  return "'" + t.token + "' list cannot be empty.";
}, EmptyTypeArguments: "Type argument list cannot be empty.", EmptyTypeParameters: "Type parameter list cannot be empty.", ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.", ImportAliasHasImportType: "An import alias can not use 'import type'.", IncompatibleModifiers: function(t) {
  var e = t.modifiers;
  return "'" + e[0] + "' modifier cannot be used with '" + e[1] + "' modifier.";
}, IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.", IndexSignatureHasAccessibility: function(t) {
  return "Index signatures cannot have an accessibility modifier ('" + t.modifier + "').";
}, IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.", IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.", IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.", InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.", InvalidModifierOnTypeMember: function(t) {
  return "'" + t.modifier + "' modifier cannot appear on a type member.";
}, InvalidModifierOnTypeParameter: function(t) {
  return "'" + t.modifier + "' modifier cannot appear on a type parameter.";
}, InvalidModifierOnTypeParameterPositions: function(t) {
  return "'" + t.modifier + "' modifier can only appear on a type parameter of a class, interface or type alias.";
}, InvalidModifiersOrder: function(t) {
  var e = t.orderedModifiers;
  return "'" + e[0] + "' modifier must precede '" + e[1] + "' modifier.";
}, InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.", InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.", MissingInterfaceName: "'interface' declarations must be followed by an identifier.", MixedLabeledAndUnlabeledElements: "Tuple members must all have names or all not have names.", NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.", NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.", OptionalTypeBeforeRequired: "A required element cannot follow an optional element.", OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.", PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.", PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.", PrivateElementHasAccessibility: function(t) {
  return "Private elements cannot have an accessibility modifier ('" + t.modifier + "').";
}, PrivateMethodsHasAccessibility: function(t) {
  return "Private methods cannot have an accessibility modifier ('" + t.modifier + "').";
}, ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.", ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.", ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.", SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.", SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.", SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.", SingleTypeParameterWithoutTrailingComma: function(t) {
  var e = t.typeParameterName;
  return "Single type parameter " + e + " should have a trailing comma. Example usage: <" + e + ",>.";
}, StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.", TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.", TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.", TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.", TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.", UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.", UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.", GenericsEndWithComma: "Trailing comma is not allowed at the end of generics.", UnexpectedTypeAnnotation: "Did not expect a type annotation here.", UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.", UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.", UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.", UnsupportedSignatureParameterKind: function(t) {
  return "Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got " + t.type + ".";
}, LetInLexicalBinding: "'let' is not allowed to be used as a name in 'let' or 'const' declarations." };
var g = { quot: '"', amp: "&", apos: "'", lt: "<", gt: ">", nbsp: " ", iexcl: "¡", cent: "¢", pound: "£", curren: "¤", yen: "¥", brvbar: "¦", sect: "§", uml: "¨", copy: "©", ordf: "ª", laquo: "«", not: "¬", shy: "­", reg: "®", macr: "¯", deg: "°", plusmn: "±", sup2: "²", sup3: "³", acute: "´", micro: "µ", para: "¶", middot: "·", cedil: "¸", sup1: "¹", ordm: "º", raquo: "»", frac14: "¼", frac12: "½", frac34: "¾", iquest: "¿", Agrave: "À", Aacute: "Á", Acirc: "Â", Atilde: "Ã", Auml: "Ä", Aring: "Å", AElig: "Æ", Ccedil: "Ç", Egrave: "È", Eacute: "É", Ecirc: "Ê", Euml: "Ë", Igrave: "Ì", Iacute: "Í", Icirc: "Î", Iuml: "Ï", ETH: "Ð", Ntilde: "Ñ", Ograve: "Ò", Oacute: "Ó", Ocirc: "Ô", Otilde: "Õ", Ouml: "Ö", times: "×", Oslash: "Ø", Ugrave: "Ù", Uacute: "Ú", Ucirc: "Û", Uuml: "Ü", Yacute: "Ý", THORN: "Þ", szlig: "ß", agrave: "à", aacute: "á", acirc: "â", atilde: "ã", auml: "ä", aring: "å", aelig: "æ", ccedil: "ç", egrave: "è", eacute: "é", ecirc: "ê", euml: "ë", igrave: "ì", iacute: "í", icirc: "î", iuml: "ï", eth: "ð", ntilde: "ñ", ograve: "ò", oacute: "ó", ocirc: "ô", otilde: "õ", ouml: "ö", divide: "÷", oslash: "ø", ugrave: "ù", uacute: "ú", ucirc: "û", uuml: "ü", yacute: "ý", thorn: "þ", yuml: "ÿ", OElig: "Œ", oelig: "œ", Scaron: "Š", scaron: "š", Yuml: "Ÿ", fnof: "ƒ", circ: "ˆ", tilde: "˜", Alpha: "Α", Beta: "Β", Gamma: "Γ", Delta: "Δ", Epsilon: "Ε", Zeta: "Ζ", Eta: "Η", Theta: "Θ", Iota: "Ι", Kappa: "Κ", Lambda: "Λ", Mu: "Μ", Nu: "Ν", Xi: "Ξ", Omicron: "Ο", Pi: "Π", Rho: "Ρ", Sigma: "Σ", Tau: "Τ", Upsilon: "Υ", Phi: "Φ", Chi: "Χ", Psi: "Ψ", Omega: "Ω", alpha: "α", beta: "β", gamma: "γ", delta: "δ", epsilon: "ε", zeta: "ζ", eta: "η", theta: "θ", iota: "ι", kappa: "κ", lambda: "λ", mu: "μ", nu: "ν", xi: "ξ", omicron: "ο", pi: "π", rho: "ρ", sigmaf: "ς", sigma: "σ", tau: "τ", upsilon: "υ", phi: "φ", chi: "χ", psi: "ψ", omega: "ω", thetasym: "ϑ", upsih: "ϒ", piv: "ϖ", ensp: " ", emsp: " ", thinsp: " ", zwnj: "‌", zwj: "‍", lrm: "‎", rlm: "‏", ndash: "–", mdash: "—", lsquo: "‘", rsquo: "’", sbquo: "‚", ldquo: "“", rdquo: "”", bdquo: "„", dagger: "†", Dagger: "‡", bull: "•", hellip: "…", permil: "‰", prime: "′", Prime: "″", lsaquo: "‹", rsaquo: "›", oline: "‾", frasl: "⁄", euro: "€", image: "ℑ", weierp: "℘", real: "ℜ", trade: "™", alefsym: "ℵ", larr: "←", uarr: "↑", rarr: "→", darr: "↓", harr: "↔", crarr: "↵", lArr: "⇐", uArr: "⇑", rArr: "⇒", dArr: "⇓", hArr: "⇔", forall: "∀", part: "∂", exist: "∃", empty: "∅", nabla: "∇", isin: "∈", notin: "∉", ni: "∋", prod: "∏", sum: "∑", minus: "−", lowast: "∗", radic: "√", prop: "∝", infin: "∞", ang: "∠", and: "∧", or: "∨", cap: "∩", cup: "∪", int: "∫", there4: "∴", sim: "∼", cong: "≅", asymp: "≈", ne: "≠", equiv: "≡", le: "≤", ge: "≥", sub: "⊂", sup: "⊃", nsub: "⊄", sube: "⊆", supe: "⊇", oplus: "⊕", otimes: "⊗", perp: "⊥", sdot: "⋅", lceil: "⌈", rceil: "⌉", lfloor: "⌊", rfloor: "⌋", lang: "〈", rang: "〉", loz: "◊", spades: "♠", clubs: "♣", hearts: "♥", diams: "♦" };
var A = /^[\da-fA-F]+$/;
var S = /^\d+$/;
function C(t) {
  return t ? "JSXIdentifier" === t.type ? t.name : "JSXNamespacedName" === t.type ? t.namespace.name + ":" + t.name.name : "JSXMemberExpression" === t.type ? C(t.object) + "." + C(t.property) : void 0 : t;
}
var E = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
function k(t) {
  if (!t) throw new Error("Assert fail");
}
function I(t) {
  return "accessor" === t;
}
function N(t) {
  return "in" === t || "out" === t;
}
function w(t, e) {
  return 2 | (t ? 4 : 0) | (e ? 8 : 0);
}
function L(t) {
  if ("MemberExpression" !== t.type) return false;
  var e = t.property;
  return (!t.computed || !("TemplateLiteral" !== e.type || e.expressions.length > 0)) && M(t.object);
}
function M(t) {
  return "Identifier" === t.type || "MemberExpression" === t.type && !t.computed && M(t.object);
}
function O(t) {
  return "private" === t || "public" === t || "protected" === t;
}
function D(e) {
  var s = e || {}, i = s.dts, r = void 0 !== i && i, n2 = s.allowSatisfies, h2 = void 0 !== n2 && n2;
  return function(s2) {
    var i2 = s2.acorn || acorn_exports, n3 = m(i2), p2 = i2.tokTypes, l2 = i2.keywordTypes, u2 = i2.isIdentifierStart, d2 = i2.lineBreak, y2 = i2.isNewLine, M2 = i2.tokContexts, D2 = i2.isIdentifierChar, _ = n3.tokTypes, R = n3.tokContexts, j = n3.keywordsRegExp, F = n3.tokenIsLiteralPropertyName, B = n3.tokenIsTemplate, H = n3.tokenIsTSDeclarationStart, q = n3.tokenIsIdentifier, U = n3.tokenIsKeywordOrIdentifier, V = n3.tokenIsTSTypeOperator;
    function K(t, e2, s3) {
      void 0 === s3 && (s3 = t.length);
      for (var i3 = e2; i3 < s3; i3++) {
        var r2 = t.charCodeAt(i3);
        if (y2(r2)) return i3 < s3 - 1 && 13 === r2 && 10 === t.charCodeAt(i3 + 1) ? i3 + 2 : i3 + 1;
      }
      return -1;
    }
    s2 = function(t, e2, s3) {
      var i3 = s3.tokTypes, r2 = e2.tokTypes;
      return function(t2) {
        function e3() {
          return t2.apply(this, arguments) || this;
        }
        o(e3, t2);
        var s4 = e3.prototype;
        return s4.takeDecorators = function(t3) {
          var e4 = this.decoratorStack[this.decoratorStack.length - 1];
          e4.length && (t3.decorators = e4, this.resetStartLocationFromNode(t3, e4[0]), this.decoratorStack[this.decoratorStack.length - 1] = []);
        }, s4.parseDecorators = function(t3) {
          for (var e4 = this.decoratorStack[this.decoratorStack.length - 1]; this.match(r2.at); ) {
            var s5 = this.parseDecorator();
            e4.push(s5);
          }
          this.match(i3._export) ? t3 || this.unexpected() : this.canHaveLeadingDecorator() || this.raise(this.start, "Leading decorators must be attached to a class declaration.");
        }, s4.parseDecorator = function() {
          var t3 = this.startNode();
          this.next(), this.decoratorStack.push([]);
          var e4, s5 = this.start, r3 = this.startLoc;
          if (this.match(i3.parenL)) {
            var a2 = this.start, n4 = this.startLoc;
            if (this.next(), e4 = this.parseExpression(), this.expect(i3.parenR), this.options.preserveParens) {
              var o2 = this.startNodeAt(a2, n4);
              o2.expression = e4, e4 = this.finishNode(o2, "ParenthesizedExpression");
            }
          } else for (e4 = this.parseIdent(false); this.eat(i3.dot); ) {
            var h3 = this.startNodeAt(s5, r3);
            h3.object = e4, h3.property = this.parseIdent(true), h3.computed = false, e4 = this.finishNode(h3, "MemberExpression");
          }
          return t3.expression = this.parseMaybeDecoratorArguments(e4), this.decoratorStack.pop(), this.finishNode(t3, "Decorator");
        }, s4.parseMaybeDecoratorArguments = function(t3) {
          if (this.eat(i3.parenL)) {
            var e4 = this.startNodeAtNode(t3);
            return e4.callee = t3, e4.arguments = this.parseExprList(i3.parenR, false), this.finishNode(e4, "CallExpression");
          }
          return t3;
        }, e3;
      }(t);
    }(s2, n3, i2), s2 = function(t, e2, s3, i3) {
      var r2 = t.tokTypes, a2 = e2.tokTypes, n4 = t.isNewLine, h3 = t.isIdentifierChar, p3 = Object.assign({ allowNamespaces: true, allowNamespacedObjects: true }, i3 || {});
      return function(t2) {
        function e3() {
          return t2.apply(this, arguments) || this;
        }
        o(e3, t2);
        var s4 = e3.prototype;
        return s4.jsx_readToken = function() {
          for (var t3 = "", e4 = this.pos; ; ) {
            this.pos >= this.input.length && this.raise(this.start, "Unterminated JSX contents");
            var s5 = this.input.charCodeAt(this.pos);
            switch (s5) {
              case 60:
              case 123:
                return this.pos === this.start ? 60 === s5 && this.exprAllowed ? (++this.pos, this.finishToken(a2.jsxTagStart)) : this.getTokenFromCode(s5) : (t3 += this.input.slice(e4, this.pos), this.finishToken(a2.jsxText, t3));
              case 38:
                t3 += this.input.slice(e4, this.pos), t3 += this.jsx_readEntity(), e4 = this.pos;
                break;
              case 62:
              case 125:
                this.raise(this.pos, "Unexpected token `" + this.input[this.pos] + "`. Did you mean `" + (62 === s5 ? "&gt;" : "&rbrace;") + '` or `{"' + this.input[this.pos] + '"}`?');
              default:
                n4(s5) ? (t3 += this.input.slice(e4, this.pos), t3 += this.jsx_readNewLine(true), e4 = this.pos) : ++this.pos;
            }
          }
        }, s4.jsx_readNewLine = function(t3) {
          var e4, s5 = this.input.charCodeAt(this.pos);
          return ++this.pos, 13 === s5 && 10 === this.input.charCodeAt(this.pos) ? (++this.pos, e4 = t3 ? "\n" : "\r\n") : e4 = String.fromCharCode(s5), this.options.locations && (++this.curLine, this.lineStart = this.pos), e4;
        }, s4.jsx_readString = function(t3) {
          for (var e4 = "", s5 = ++this.pos; ; ) {
            this.pos >= this.input.length && this.raise(this.start, "Unterminated string constant");
            var i4 = this.input.charCodeAt(this.pos);
            if (i4 === t3) break;
            38 === i4 ? (e4 += this.input.slice(s5, this.pos), e4 += this.jsx_readEntity(), s5 = this.pos) : n4(i4) ? (e4 += this.input.slice(s5, this.pos), e4 += this.jsx_readNewLine(false), s5 = this.pos) : ++this.pos;
          }
          return e4 += this.input.slice(s5, this.pos++), this.finishToken(r2.string, e4);
        }, s4.jsx_readEntity = function() {
          var t3, e4 = "", s5 = 0, i4 = this.input[this.pos];
          "&" !== i4 && this.raise(this.pos, "Entity must start with an ampersand");
          for (var r3 = ++this.pos; this.pos < this.input.length && s5++ < 10; ) {
            if (";" === (i4 = this.input[this.pos++])) {
              "#" === e4[0] ? "x" === e4[1] ? (e4 = e4.substr(2), A.test(e4) && (t3 = String.fromCharCode(parseInt(e4, 16)))) : (e4 = e4.substr(1), S.test(e4) && (t3 = String.fromCharCode(parseInt(e4, 10)))) : t3 = g[e4];
              break;
            }
            e4 += i4;
          }
          return t3 || (this.pos = r3, "&");
        }, s4.jsx_readWord = function() {
          var t3, e4 = this.pos;
          do {
            t3 = this.input.charCodeAt(++this.pos);
          } while (h3(t3) || 45 === t3);
          return this.finishToken(a2.jsxName, this.input.slice(e4, this.pos));
        }, s4.jsx_parseIdentifier = function() {
          var t3 = this.startNode();
          return this.type === a2.jsxName ? t3.name = this.value : this.type.keyword ? t3.name = this.type.keyword : this.unexpected(), this.next(), this.finishNode(t3, "JSXIdentifier");
        }, s4.jsx_parseNamespacedName = function() {
          var t3 = this.start, e4 = this.startLoc, s5 = this.jsx_parseIdentifier();
          if (!p3.allowNamespaces || !this.eat(r2.colon)) return s5;
          var i4 = this.startNodeAt(t3, e4);
          return i4.namespace = s5, i4.name = this.jsx_parseIdentifier(), this.finishNode(i4, "JSXNamespacedName");
        }, s4.jsx_parseElementName = function() {
          if (this.type === a2.jsxTagEnd) return "";
          var t3 = this.start, e4 = this.startLoc, s5 = this.jsx_parseNamespacedName();
          for (this.type !== r2.dot || "JSXNamespacedName" !== s5.type || p3.allowNamespacedObjects || this.unexpected(); this.eat(r2.dot); ) {
            var i4 = this.startNodeAt(t3, e4);
            i4.object = s5, i4.property = this.jsx_parseIdentifier(), s5 = this.finishNode(i4, "JSXMemberExpression");
          }
          return s5;
        }, s4.jsx_parseAttributeValue = function() {
          switch (this.type) {
            case r2.braceL:
              var t3 = this.jsx_parseExpressionContainer();
              return "JSXEmptyExpression" === t3.expression.type && this.raise(t3.start, "JSX attributes must only be assigned a non-empty expression"), t3;
            case a2.jsxTagStart:
            case r2.string:
              return this.parseExprAtom();
            default:
              this.raise(this.start, "JSX value should be either an expression or a quoted JSX text");
          }
        }, s4.jsx_parseEmptyExpression = function() {
          var t3 = this.startNodeAt(this.lastTokEnd, this.lastTokEndLoc);
          return this.finishNodeAt(t3, "JSXEmptyExpression", this.start, this.startLoc);
        }, s4.jsx_parseExpressionContainer = function() {
          var t3 = this.startNode();
          return this.next(), t3.expression = this.type === r2.braceR ? this.jsx_parseEmptyExpression() : this.parseExpression(), this.expect(r2.braceR), this.finishNode(t3, "JSXExpressionContainer");
        }, s4.jsx_parseAttribute = function() {
          var t3 = this.startNode();
          return this.eat(r2.braceL) ? (this.expect(r2.ellipsis), t3.argument = this.parseMaybeAssign(), this.expect(r2.braceR), this.finishNode(t3, "JSXSpreadAttribute")) : (t3.name = this.jsx_parseNamespacedName(), t3.value = this.eat(r2.eq) ? this.jsx_parseAttributeValue() : null, this.finishNode(t3, "JSXAttribute"));
        }, s4.jsx_parseOpeningElementAt = function(t3, e4) {
          var s5 = this.startNodeAt(t3, e4);
          s5.attributes = [];
          var i4 = this.jsx_parseElementName();
          for (i4 && (s5.name = i4); this.type !== r2.slash && this.type !== a2.jsxTagEnd; ) s5.attributes.push(this.jsx_parseAttribute());
          return s5.selfClosing = this.eat(r2.slash), this.expect(a2.jsxTagEnd), this.finishNode(s5, i4 ? "JSXOpeningElement" : "JSXOpeningFragment");
        }, s4.jsx_parseClosingElementAt = function(t3, e4) {
          var s5 = this.startNodeAt(t3, e4), i4 = this.jsx_parseElementName();
          return i4 && (s5.name = i4), this.expect(a2.jsxTagEnd), this.finishNode(s5, i4 ? "JSXClosingElement" : "JSXClosingFragment");
        }, s4.jsx_parseElementAt = function(t3, e4) {
          var s5 = this.startNodeAt(t3, e4), i4 = [], n5 = this.jsx_parseOpeningElementAt(t3, e4), o2 = null;
          if (!n5.selfClosing) {
            t: for (; ; ) switch (this.type) {
              case a2.jsxTagStart:
                if (t3 = this.start, e4 = this.startLoc, this.next(), this.eat(r2.slash)) {
                  o2 = this.jsx_parseClosingElementAt(t3, e4);
                  break t;
                }
                i4.push(this.jsx_parseElementAt(t3, e4));
                break;
              case a2.jsxText:
                i4.push(this.parseExprAtom());
                break;
              case r2.braceL:
                i4.push(this.jsx_parseExpressionContainer());
                break;
              default:
                this.unexpected();
            }
            C(o2.name) !== C(n5.name) && this.raise(o2.start, "Expected corresponding JSX closing tag for <" + C(n5.name) + ">");
          }
          var h4 = n5.name ? "Element" : "Fragment";
          return s5["opening" + h4] = n5, s5["closing" + h4] = o2, s5.children = i4, this.type === r2.relational && "<" === this.value && this.raise(this.start, "Adjacent JSX elements must be wrapped in an enclosing tag"), this.finishNode(s5, "JSX" + h4);
        }, s4.jsx_parseText = function() {
          var t3 = this.parseLiteral(this.value);
          return t3.type = "JSXText", t3;
        }, s4.jsx_parseElement = function() {
          var t3 = this.start, e4 = this.startLoc;
          return this.next(), this.jsx_parseElementAt(t3, e4);
        }, e3;
      }(s3);
    }(i2, n3, s2, null == e ? void 0 : e.jsx), s2 = function(t, e2, s3) {
      var i3 = e2.tokTypes, r2 = s3.tokTypes;
      return function(t2) {
        function e3() {
          return t2.apply(this, arguments) || this;
        }
        o(e3, t2);
        var s4 = e3.prototype;
        return s4.parseMaybeImportAttributes = function(t3) {
          if (this.type === r2._with || this.type === i3.assert) {
            this.next();
            var e4 = this.parseImportAttributes();
            e4 && (t3.attributes = e4);
          }
        }, s4.parseImportAttributes = function() {
          this.expect(r2.braceL);
          var t3 = this.parseWithEntries();
          return this.expect(r2.braceR), t3;
        }, s4.parseWithEntries = function() {
          var t3 = [], e4 = /* @__PURE__ */ new Set();
          do {
            if (this.type === r2.braceR) break;
            var s5, i4 = this.startNode();
            s5 = this.type === r2.string ? this.parseLiteral(this.value) : this.parseIdent(true), this.next(), i4.key = s5, e4.has(i4.key.name) && this.raise(this.pos, "Duplicated key in attributes"), e4.add(i4.key.name), this.type !== r2.string && this.raise(this.pos, "Only string is supported as an attribute value"), i4.value = this.parseLiteral(this.value), t3.push(this.finishNode(i4, "ImportAttribute"));
          } while (this.eat(r2.comma));
          return t3;
        }, e3;
      }(t);
    }(s2, n3, i2);
    var z = function(t) {
      function e2(e3, s4, i3) {
        var r2;
        return (r2 = t.call(this, e3, s4, i3) || this).preValue = null, r2.preToken = null, r2.isLookahead = false, r2.isAmbientContext = false, r2.inAbstractClass = false, r2.inType = false, r2.inDisallowConditionalTypesContext = false, r2.maybeInArrowParameters = false, r2.shouldParseArrowReturnType = void 0, r2.shouldParseAsyncArrowReturnType = void 0, r2.decoratorStack = [[]], r2.importsStack = [[]], r2.importOrExportOuterKind = void 0, r2.tsParseConstModifier = r2.tsParseModifiers.bind(function(t2) {
          if (void 0 === t2) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t2;
        }(r2), { allowedModifiers: ["const"], disallowedModifiers: ["in", "out"], errorTemplate: b.InvalidModifierOnTypeParameterPositions }), r2;
      }
      o(e2, t);
      var s3, m2, g2, A2 = e2.prototype;
      return A2.getTokenFromCodeInType = function(e3) {
        return 62 === e3 || 60 === e3 ? this.finishOp(p2.relational, 1) : t.prototype.getTokenFromCode.call(this, e3);
      }, A2.readToken = function(e3) {
        if (!this.inType) {
          var s4 = this.curContext();
          if (s4 === R.tc_expr) return this.jsx_readToken();
          if (s4 === R.tc_oTag || s4 === R.tc_cTag) {
            if (u2(e3)) return this.jsx_readWord();
            if (62 == e3) return ++this.pos, this.finishToken(_.jsxTagEnd);
            if ((34 === e3 || 39 === e3) && s4 == R.tc_oTag) return this.jsx_readString(e3);
          }
          if (60 === e3 && this.exprAllowed && 33 !== this.input.charCodeAt(this.pos + 1)) return ++this.pos, this.finishToken(_.jsxTagStart);
        }
        return t.prototype.readToken.call(this, e3);
      }, A2.getTokenFromCode = function(e3) {
        return this.inType ? this.getTokenFromCodeInType(e3) : 64 === e3 ? (++this.pos, this.finishToken(_.at)) : t.prototype.getTokenFromCode.call(this, e3);
      }, A2.isAbstractClass = function() {
        return this.ts_isContextual(_.abstract) && this.lookahead().type === p2._class;
      }, A2.finishNode = function(e3, s4) {
        return "" !== e3.type && 0 !== e3.end ? e3 : t.prototype.finishNode.call(this, e3, s4);
      }, A2.tryParse = function(t2, e3) {
        void 0 === e3 && (e3 = this.cloneCurLookaheadState());
        var s4 = { node: null };
        try {
          return { node: t2(function(t3) {
            throw void 0 === t3 && (t3 = null), s4.node = t3, s4;
          }), error: null, thrown: false, aborted: false, failState: null };
        } catch (t3) {
          var i3 = this.getCurLookaheadState();
          if (this.setLookaheadState(e3), t3 instanceof SyntaxError) return { node: null, error: t3, thrown: true, aborted: false, failState: i3 };
          if (t3 === s4) return { node: s4.node, error: null, thrown: false, aborted: true, failState: i3 };
          throw t3;
        }
      }, A2.setOptionalParametersError = function(t2, e3) {
        var s4;
        t2.optionalParametersLoc = null != (s4 = null == e3 ? void 0 : e3.loc) ? s4 : this.startLoc;
      }, A2.reScan_lt_gt = function() {
        this.type === p2.relational && (this.pos -= 1, this.readToken_lt_gt(this.fullCharCodeAtPos()));
      }, A2.reScan_lt = function() {
        var t2 = this.type;
        return t2 === p2.bitShift ? (this.pos -= 2, this.finishOp(p2.relational, 1), p2.relational) : t2;
      }, A2.resetEndLocation = function(t2, e3) {
        void 0 === e3 && (e3 = this.lastTokEndLoc), t2.end = e3.column, t2.loc.end = e3, this.options.ranges && (t2.range[1] = e3.column);
      }, A2.startNodeAtNode = function(e3) {
        return t.prototype.startNodeAt.call(this, e3.start, e3.loc.start);
      }, A2.nextTokenStart = function() {
        return this.nextTokenStartSince(this.pos);
      }, A2.tsHasSomeModifiers = function(t2, e3) {
        return e3.some(function(e4) {
          return O(e4) ? t2.accessibility === e4 : !!t2[e4];
        });
      }, A2.tsIsStartOfStaticBlocks = function() {
        return this.isContextual("static") && 123 === this.lookaheadCharCode();
      }, A2.tsCheckForInvalidTypeCasts = function(t2) {
        var e3 = this;
        t2.forEach(function(t3) {
          "TSTypeCastExpression" === (null == t3 ? void 0 : t3.type) && e3.raise(t3.typeAnnotation.start, b.UnexpectedTypeAnnotation);
        });
      }, A2.atPossibleAsyncArrow = function(t2) {
        return "Identifier" === t2.type && "async" === t2.name && this.lastTokEndLoc.column === t2.end && !this.canInsertSemicolon() && t2.end - t2.start == 5 && t2.start === this.potentialArrowAt;
      }, A2.tsIsIdentifier = function() {
        return q(this.type);
      }, A2.tsTryParseTypeOrTypePredicateAnnotation = function() {
        return this.match(p2.colon) ? this.tsParseTypeOrTypePredicateAnnotation(p2.colon) : void 0;
      }, A2.tsTryParseGenericAsyncArrowFunction = function(e3, s4, i3) {
        var r2 = this;
        if (this.tsMatchLeftRelational()) {
          var a2 = this.maybeInArrowParameters;
          this.maybeInArrowParameters = true;
          var n4 = this.tsTryParseAndCatch(function() {
            var i4 = r2.startNodeAt(e3, s4);
            return i4.typeParameters = r2.tsParseTypeParameters(), t.prototype.parseFunctionParams.call(r2, i4), i4.returnType = r2.tsTryParseTypeOrTypePredicateAnnotation(), r2.expect(p2.arrow), i4;
          });
          if (this.maybeInArrowParameters = a2, n4) return t.prototype.parseArrowExpression.call(this, n4, null, true, i3);
        }
      }, A2.tsParseTypeArgumentsInExpression = function() {
        if (this.reScan_lt() === p2.relational) return this.tsParseTypeArguments();
      }, A2.tsInNoContext = function(t2) {
        var e3 = this.context;
        this.context = [e3[0]];
        try {
          return t2();
        } finally {
          this.context = e3;
        }
      }, A2.tsTryParseTypeAnnotation = function() {
        return this.match(p2.colon) ? this.tsParseTypeAnnotation() : void 0;
      }, A2.isUnparsedContextual = function(t2, e3) {
        var s4 = t2 + e3.length;
        if (this.input.slice(t2, s4) === e3) {
          var i3 = this.input.charCodeAt(s4);
          return !(D2(i3) || 55296 == (64512 & i3));
        }
        return false;
      }, A2.isAbstractConstructorSignature = function() {
        return this.ts_isContextual(_.abstract) && this.lookahead().type === p2._new;
      }, A2.nextTokenStartSince = function(t2) {
        return E.lastIndex = t2, E.test(this.input) ? E.lastIndex : t2;
      }, A2.lookaheadCharCode = function() {
        return this.input.charCodeAt(this.nextTokenStart());
      }, A2.compareLookaheadState = function(t2, e3) {
        for (var s4 = 0, i3 = Object.keys(t2); s4 < i3.length; s4++) {
          var r2 = i3[s4];
          if (t2[r2] !== e3[r2]) return false;
        }
        return true;
      }, A2.createLookaheadState = function() {
        this.value = null, this.context = [this.curContext()];
      }, A2.getCurLookaheadState = function() {
        return { endLoc: this.endLoc, lastTokEnd: this.lastTokEnd, lastTokStart: this.lastTokStart, lastTokStartLoc: this.lastTokStartLoc, pos: this.pos, value: this.value, type: this.type, start: this.start, end: this.end, context: this.context, startLoc: this.startLoc, lastTokEndLoc: this.lastTokEndLoc, curLine: this.curLine, lineStart: this.lineStart, curPosition: this.curPosition, containsEsc: this.containsEsc };
      }, A2.cloneCurLookaheadState = function() {
        return { pos: this.pos, value: this.value, type: this.type, start: this.start, end: this.end, context: this.context && this.context.slice(), startLoc: this.startLoc, lastTokEndLoc: this.lastTokEndLoc, endLoc: this.endLoc, lastTokEnd: this.lastTokEnd, lastTokStart: this.lastTokStart, lastTokStartLoc: this.lastTokStartLoc, curLine: this.curLine, lineStart: this.lineStart, curPosition: this.curPosition, containsEsc: this.containsEsc };
      }, A2.setLookaheadState = function(t2) {
        this.pos = t2.pos, this.value = t2.value, this.endLoc = t2.endLoc, this.lastTokEnd = t2.lastTokEnd, this.lastTokStart = t2.lastTokStart, this.lastTokStartLoc = t2.lastTokStartLoc, this.type = t2.type, this.start = t2.start, this.end = t2.end, this.context = t2.context, this.startLoc = t2.startLoc, this.lastTokEndLoc = t2.lastTokEndLoc, this.curLine = t2.curLine, this.lineStart = t2.lineStart, this.curPosition = t2.curPosition, this.containsEsc = t2.containsEsc;
      }, A2.tsLookAhead = function(t2) {
        var e3 = this.getCurLookaheadState(), s4 = t2();
        return this.setLookaheadState(e3), s4;
      }, A2.lookahead = function(t2) {
        var e3 = this.getCurLookaheadState();
        if (this.createLookaheadState(), this.isLookahead = true, void 0 !== t2) for (var s4 = 0; s4 < t2; s4++) this.nextToken();
        else this.nextToken();
        this.isLookahead = false;
        var i3 = this.getCurLookaheadState();
        return this.setLookaheadState(e3), i3;
      }, A2.readWord = function() {
        var t2 = this.readWord1(), e3 = p2.name;
        return this.keywords.test(t2) ? e3 = l2[t2] : new RegExp(j).test(t2) && (e3 = _[t2]), this.finishToken(e3, t2);
      }, A2.skipBlockComment = function() {
        var t2;
        this.isLookahead || (t2 = this.options.onComment && this.curPosition());
        var e3 = this.pos, s4 = this.input.indexOf("*/", this.pos += 2);
        if (-1 === s4 && this.raise(this.pos - 2, "Unterminated comment"), this.pos = s4 + 2, this.options.locations) for (var i3, r2 = e3; (i3 = K(this.input, r2, this.pos)) > -1; ) ++this.curLine, r2 = this.lineStart = i3;
        this.isLookahead || this.options.onComment && this.options.onComment(true, this.input.slice(e3 + 2, s4), e3, this.pos, t2, this.curPosition());
      }, A2.skipLineComment = function(t2) {
        var e3, s4 = this.pos;
        this.isLookahead || (e3 = this.options.onComment && this.curPosition());
        for (var i3 = this.input.charCodeAt(this.pos += t2); this.pos < this.input.length && !y2(i3); ) i3 = this.input.charCodeAt(++this.pos);
        this.isLookahead || this.options.onComment && this.options.onComment(false, this.input.slice(s4 + t2, this.pos), s4, this.pos, e3, this.curPosition());
      }, A2.finishToken = function(t2, e3) {
        this.preValue = this.value, this.preToken = this.type, this.end = this.pos, this.options.locations && (this.endLoc = this.curPosition());
        var s4 = this.type;
        this.type = t2, this.value = e3, this.isLookahead || this.updateContext(s4);
      }, A2.resetStartLocation = function(t2, e3, s4) {
        t2.start = e3, t2.loc.start = s4, this.options.ranges && (t2.range[0] = e3);
      }, A2.isLineTerminator = function() {
        return this.eat(p2.semi) || t.prototype.canInsertSemicolon.call(this);
      }, A2.hasFollowingLineBreak = function() {
        return x.lastIndex = this.end, x.test(this.input);
      }, A2.addExtra = function(t2, e3, s4, i3) {
        if (void 0 === i3 && (i3 = true), t2) {
          var r2 = t2.extra = t2.extra || {};
          i3 ? r2[e3] = s4 : Object.defineProperty(r2, e3, { enumerable: i3, value: s4 });
        }
      }, A2.isLiteralPropertyName = function() {
        return F(this.type);
      }, A2.hasPrecedingLineBreak = function() {
        return d2.test(this.input.slice(this.lastTokEndLoc.index, this.start));
      }, A2.createIdentifier = function(t2, e3) {
        return t2.name = e3, this.finishNode(t2, "Identifier");
      }, A2.resetStartLocationFromNode = function(t2, e3) {
        this.resetStartLocation(t2, e3.start, e3.loc.start);
      }, A2.isThisParam = function(t2) {
        return "Identifier" === t2.type && "this" === t2.name;
      }, A2.isLookaheadContextual = function(t2) {
        var e3 = this.nextTokenStart();
        return this.isUnparsedContextual(e3, t2);
      }, A2.ts_type_isContextual = function(t2, e3) {
        return t2 === e3 && !this.containsEsc;
      }, A2.ts_isContextual = function(t2) {
        return this.type === t2 && !this.containsEsc;
      }, A2.ts_isContextualWithState = function(t2, e3) {
        return t2.type === e3 && !t2.containsEsc;
      }, A2.isContextualWithState = function(t2, e3) {
        return e3.type === p2.name && e3.value === t2 && !e3.containsEsc;
      }, A2.tsIsStartOfMappedType = function() {
        return this.next(), this.eat(p2.plusMin) ? this.ts_isContextual(_.readonly) : (this.ts_isContextual(_.readonly) && this.next(), !!this.match(p2.bracketL) && (this.next(), !!this.tsIsIdentifier() && (this.next(), this.match(p2._in))));
      }, A2.tsInDisallowConditionalTypesContext = function(t2) {
        var e3 = this.inDisallowConditionalTypesContext;
        this.inDisallowConditionalTypesContext = true;
        try {
          return t2();
        } finally {
          this.inDisallowConditionalTypesContext = e3;
        }
      }, A2.tsTryParseType = function() {
        return this.tsEatThenParseType(p2.colon);
      }, A2.match = function(t2) {
        return this.type === t2;
      }, A2.matchJsx = function(t2) {
        return this.type === n3.tokTypes[t2];
      }, A2.ts_eatWithState = function(t2, e3, s4) {
        if (t2 === s4.type) {
          for (var i3 = 0; i3 < e3; i3++) this.next();
          return true;
        }
        return false;
      }, A2.ts_eatContextualWithState = function(t2, e3, s4) {
        if (j.test(t2)) {
          if (this.ts_isContextualWithState(s4, _[t2])) {
            for (var i3 = 0; i3 < e3; i3++) this.next();
            return true;
          }
          return false;
        }
        if (!this.isContextualWithState(t2, s4)) return false;
        for (var r2 = 0; r2 < e3; r2++) this.next();
        return true;
      }, A2.canHaveLeadingDecorator = function() {
        return this.match(p2._class);
      }, A2.eatContextual = function(e3) {
        return j.test(e3) ? !!this.ts_isContextual(_[e3]) && (this.next(), true) : t.prototype.eatContextual.call(this, e3);
      }, A2.tsIsExternalModuleReference = function() {
        return this.isContextual("require") && 40 === this.lookaheadCharCode();
      }, A2.tsParseExternalModuleReference = function() {
        var t2 = this.startNode();
        return this.expectContextual("require"), this.expect(p2.parenL), this.match(p2.string) || this.unexpected(), t2.expression = this.parseExprAtom(), this.expect(p2.parenR), this.finishNode(t2, "TSExternalModuleReference");
      }, A2.tsParseEntityName = function(t2) {
        void 0 === t2 && (t2 = true);
        for (var e3 = this.parseIdent(t2); this.eat(p2.dot); ) {
          var s4 = this.startNodeAtNode(e3);
          s4.left = e3, s4.right = this.parseIdent(t2), e3 = this.finishNode(s4, "TSQualifiedName");
        }
        return e3;
      }, A2.tsParseEnumMember = function() {
        var t2 = this.startNode();
        return t2.id = this.match(p2.string) ? this.parseLiteral(this.value) : this.parseIdent(true), this.eat(p2.eq) && (t2.initializer = this.parseMaybeAssign()), this.finishNode(t2, "TSEnumMember");
      }, A2.tsParseEnumDeclaration = function(t2, e3) {
        return void 0 === e3 && (e3 = {}), e3.const && (t2.const = true), e3.declare && (t2.declare = true), this.expectContextual("enum"), t2.id = this.parseIdent(), this.checkLValSimple(t2.id), this.expect(p2.braceL), t2.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)), this.expect(p2.braceR), this.finishNode(t2, "TSEnumDeclaration");
      }, A2.tsParseModuleBlock = function() {
        var e3 = this.startNode();
        for (t.prototype.enterScope.call(this, 512), this.expect(p2.braceL), e3.body = []; this.type !== p2.braceR; ) {
          var s4 = this.parseStatement(null, true);
          e3.body.push(s4);
        }
        return this.next(), t.prototype.exitScope.call(this), this.finishNode(e3, "TSModuleBlock");
      }, A2.tsParseAmbientExternalModuleDeclaration = function(e3) {
        return this.ts_isContextual(_.global) ? (e3.global = true, e3.id = this.parseIdent()) : this.match(p2.string) ? e3.id = this.parseLiteral(this.value) : this.unexpected(), this.match(p2.braceL) ? (t.prototype.enterScope.call(this, f), e3.body = this.tsParseModuleBlock(), t.prototype.exitScope.call(this)) : t.prototype.semicolon.call(this), this.finishNode(e3, "TSModuleDeclaration");
      }, A2.tsTryParseDeclare = function(t2) {
        var e3 = this;
        if (!this.isLineTerminator()) {
          var s4, i3 = this.type;
          return this.isContextual("let") && (i3 = p2._var, s4 = "let"), this.tsInAmbientContext(function() {
            if (i3 === p2._function) return t2.declare = true, e3.parseFunctionStatement(t2, false, true);
            if (i3 === p2._class) return t2.declare = true, e3.parseClass(t2, true);
            if (i3 === _.enum) return e3.tsParseEnumDeclaration(t2, { declare: true });
            if (i3 === _.global) return e3.tsParseAmbientExternalModuleDeclaration(t2);
            if (i3 === p2._const || i3 === p2._var) return e3.match(p2._const) && e3.isLookaheadContextual("enum") ? (e3.expect(p2._const), e3.tsParseEnumDeclaration(t2, { const: true, declare: true })) : (t2.declare = true, e3.parseVarStatement(t2, s4 || e3.value, true));
            if (i3 === _.interface) {
              var r2 = e3.tsParseInterfaceDeclaration(t2, { declare: true });
              if (r2) return r2;
            }
            return q(i3) ? e3.tsParseDeclaration(t2, e3.value, true) : void 0;
          });
        }
      }, A2.tsIsListTerminator = function(t2) {
        switch (t2) {
          case "EnumMembers":
          case "TypeMembers":
            return this.match(p2.braceR);
          case "HeritageClauseElement":
            return this.match(p2.braceL);
          case "TupleElementTypes":
            return this.match(p2.bracketR);
          case "TypeParametersOrArguments":
            return this.tsMatchRightRelational();
        }
      }, A2.tsParseDelimitedListWorker = function(t2, e3, s4, i3) {
        for (var r2 = [], a2 = -1; !this.tsIsListTerminator(t2); ) {
          a2 = -1;
          var n4 = e3();
          if (null == n4) return;
          if (r2.push(n4), !this.eat(p2.comma)) {
            if (this.tsIsListTerminator(t2)) break;
            return void (s4 && this.expect(p2.comma));
          }
          a2 = this.lastTokStart;
        }
        return i3 && (i3.value = a2), r2;
      }, A2.tsParseDelimitedList = function(t2, e3, s4) {
        return function(t3) {
          if (null == t3) throw new Error("Unexpected " + t3 + " value.");
          return t3;
        }(this.tsParseDelimitedListWorker(t2, e3, true, s4));
      }, A2.tsParseBracketedList = function(t2, e3, s4, i3, r2) {
        i3 || this.expect(s4 ? p2.bracketL : p2.relational);
        var a2 = this.tsParseDelimitedList(t2, e3, r2);
        return this.expect(s4 ? p2.bracketR : p2.relational), a2;
      }, A2.tsParseTypeParameterName = function() {
        return this.parseIdent().name;
      }, A2.tsEatThenParseType = function(t2) {
        return this.match(t2) ? this.tsNextThenParseType() : void 0;
      }, A2.tsExpectThenParseType = function(t2) {
        var e3 = this;
        return this.tsDoThenParseType(function() {
          return e3.expect(t2);
        });
      }, A2.tsNextThenParseType = function() {
        var t2 = this;
        return this.tsDoThenParseType(function() {
          return t2.next();
        });
      }, A2.tsDoThenParseType = function(t2) {
        var e3 = this;
        return this.tsInType(function() {
          return t2(), e3.tsParseType();
        });
      }, A2.tsSkipParameterStart = function() {
        if (q(this.type) || this.match(p2._this)) return this.next(), true;
        if (this.match(p2.braceL)) try {
          return this.parseObj(true), true;
        } catch (t2) {
          return false;
        }
        if (this.match(p2.bracketL)) {
          this.next();
          try {
            return this.parseBindingList(p2.bracketR, true, true), true;
          } catch (t2) {
            return false;
          }
        }
        return false;
      }, A2.tsIsUnambiguouslyStartOfFunctionType = function() {
        if (this.next(), this.match(p2.parenR) || this.match(p2.ellipsis)) return true;
        if (this.tsSkipParameterStart()) {
          if (this.match(p2.colon) || this.match(p2.comma) || this.match(p2.question) || this.match(p2.eq)) return true;
          if (this.match(p2.parenR) && (this.next(), this.match(p2.arrow))) return true;
        }
        return false;
      }, A2.tsIsStartOfFunctionType = function() {
        return !!this.tsMatchLeftRelational() || this.match(p2.parenL) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
      }, A2.tsInAllowConditionalTypesContext = function(t2) {
        var e3 = this.inDisallowConditionalTypesContext;
        this.inDisallowConditionalTypesContext = false;
        try {
          return t2();
        } finally {
          this.inDisallowConditionalTypesContext = e3;
        }
      }, A2.tsParseBindingListForSignature = function() {
        var e3 = this;
        return t.prototype.parseBindingList.call(this, p2.parenR, true, true).map(function(t2) {
          return "Identifier" !== t2.type && "RestElement" !== t2.type && "ObjectPattern" !== t2.type && "ArrayPattern" !== t2.type && e3.raise(t2.start, b.UnsupportedSignatureParameterKind(t2.type)), t2;
        });
      }, A2.tsParseTypePredicateAsserts = function() {
        if (this.type !== _.asserts) return false;
        var t2 = this.containsEsc;
        return this.next(), !(!q(this.type) && !this.match(p2._this) || (t2 && this.raise(this.lastTokStart, "Escape sequence in keyword asserts"), 0));
      }, A2.tsParseThisTypeNode = function() {
        var t2 = this.startNode();
        return this.next(), this.finishNode(t2, "TSThisType");
      }, A2.tsParseTypeAnnotation = function(t2, e3) {
        var s4 = this;
        return void 0 === t2 && (t2 = true), void 0 === e3 && (e3 = this.startNode()), this.tsInType(function() {
          t2 && s4.expect(p2.colon), e3.typeAnnotation = s4.tsParseType();
        }), this.finishNode(e3, "TSTypeAnnotation");
      }, A2.tsParseThisTypePredicate = function(t2) {
        this.next();
        var e3 = this.startNodeAtNode(t2);
        return e3.parameterName = t2, e3.typeAnnotation = this.tsParseTypeAnnotation(false), e3.asserts = false, this.finishNode(e3, "TSTypePredicate");
      }, A2.tsParseThisTypeOrThisTypePredicate = function() {
        var t2 = this.tsParseThisTypeNode();
        return this.isContextual("is") && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(t2) : t2;
      }, A2.tsParseTypePredicatePrefix = function() {
        var t2 = this.parseIdent();
        if (this.isContextual("is") && !this.hasPrecedingLineBreak()) return this.next(), t2;
      }, A2.tsParseTypeOrTypePredicateAnnotation = function(t2) {
        var e3 = this;
        return this.tsInType(function() {
          var s4 = e3.startNode();
          e3.expect(t2);
          var i3 = e3.startNode(), r2 = !!e3.tsTryParse(e3.tsParseTypePredicateAsserts.bind(e3));
          if (r2 && e3.match(p2._this)) {
            var a2 = e3.tsParseThisTypeOrThisTypePredicate();
            return "TSThisType" === a2.type ? (i3.parameterName = a2, i3.asserts = true, i3.typeAnnotation = null, a2 = e3.finishNode(i3, "TSTypePredicate")) : (e3.resetStartLocationFromNode(a2, i3), a2.asserts = true), s4.typeAnnotation = a2, e3.finishNode(s4, "TSTypeAnnotation");
          }
          var n4 = e3.tsIsIdentifier() && e3.tsTryParse(e3.tsParseTypePredicatePrefix.bind(e3));
          if (!n4) return r2 ? (i3.parameterName = e3.parseIdent(), i3.asserts = r2, i3.typeAnnotation = null, s4.typeAnnotation = e3.finishNode(i3, "TSTypePredicate"), e3.finishNode(s4, "TSTypeAnnotation")) : e3.tsParseTypeAnnotation(false, s4);
          var o2 = e3.tsParseTypeAnnotation(false);
          return i3.parameterName = n4, i3.typeAnnotation = o2, i3.asserts = r2, s4.typeAnnotation = e3.finishNode(i3, "TSTypePredicate"), e3.finishNode(s4, "TSTypeAnnotation");
        });
      }, A2.tsFillSignature = function(t2, e3) {
        var s4 = t2 === p2.arrow;
        e3.typeParameters = this.tsTryParseTypeParameters(), this.expect(p2.parenL), e3.parameters = this.tsParseBindingListForSignature(), (s4 || this.match(t2)) && (e3.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(t2));
      }, A2.tsTryNextParseConstantContext = function() {
        if (this.lookahead().type !== p2._const) return null;
        this.next();
        var t2 = this.tsParseTypeReference();
        return t2.typeParameters && this.raise(t2.typeName.start, b.CannotFindName({ name: "const" })), t2;
      }, A2.tsParseFunctionOrConstructorType = function(t2, e3) {
        var s4 = this, i3 = this.startNode();
        return "TSConstructorType" === t2 && (i3.abstract = !!e3, e3 && this.next(), this.next()), this.tsInAllowConditionalTypesContext(function() {
          return s4.tsFillSignature(p2.arrow, i3);
        }), this.finishNode(i3, t2);
      }, A2.tsParseUnionOrIntersectionType = function(t2, e3, s4) {
        var i3 = this.startNode(), r2 = this.eat(s4), a2 = [];
        do {
          a2.push(e3());
        } while (this.eat(s4));
        return 1 !== a2.length || r2 ? (i3.types = a2, this.finishNode(i3, t2)) : a2[0];
      }, A2.tsCheckTypeAnnotationForReadOnly = function(t2) {
        switch (t2.typeAnnotation.type) {
          case "TSTupleType":
          case "TSArrayType":
            return;
          default:
            this.raise(t2.start, b.UnexpectedReadonly);
        }
      }, A2.tsParseTypeOperator = function() {
        var t2 = this.startNode(), e3 = this.value;
        return this.next(), t2.operator = e3, t2.typeAnnotation = this.tsParseTypeOperatorOrHigher(), "readonly" === e3 && this.tsCheckTypeAnnotationForReadOnly(t2), this.finishNode(t2, "TSTypeOperator");
      }, A2.tsParseConstraintForInferType = function() {
        var t2 = this;
        if (this.eat(p2._extends)) {
          var e3 = this.tsInDisallowConditionalTypesContext(function() {
            return t2.tsParseType();
          });
          if (this.inDisallowConditionalTypesContext || !this.match(p2.question)) return e3;
        }
      }, A2.tsParseInferType = function() {
        var t2 = this, e3 = this.startNode();
        this.expectContextual("infer");
        var s4 = this.startNode();
        return s4.name = this.tsParseTypeParameterName(), s4.constraint = this.tsTryParse(function() {
          return t2.tsParseConstraintForInferType();
        }), e3.typeParameter = this.finishNode(s4, "TSTypeParameter"), this.finishNode(e3, "TSInferType");
      }, A2.tsParseLiteralTypeNode = function() {
        var t2 = this, e3 = this.startNode();
        return e3.literal = function() {
          switch (t2.type) {
            case p2.num:
            case p2.string:
            case p2._true:
            case p2._false:
              return t2.parseExprAtom();
            default:
              t2.unexpected();
          }
        }(), this.finishNode(e3, "TSLiteralType");
      }, A2.tsParseImportType = function() {
        var t2 = this.startNode();
        return this.expect(p2._import), this.expect(p2.parenL), this.match(p2.string) || this.raise(this.start, b.UnsupportedImportTypeArgument), t2.argument = this.parseExprAtom(), this.expect(p2.parenR), this.eat(p2.dot) && (t2.qualifier = this.tsParseEntityName()), this.tsMatchLeftRelational() && (t2.typeParameters = this.tsParseTypeArguments()), this.finishNode(t2, "TSImportType");
      }, A2.tsParseTypeQuery = function() {
        var t2 = this.startNode();
        return this.expect(p2._typeof), t2.exprName = this.match(p2._import) ? this.tsParseImportType() : this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.tsMatchLeftRelational() && (t2.typeParameters = this.tsParseTypeArguments()), this.finishNode(t2, "TSTypeQuery");
      }, A2.tsParseMappedTypeParameter = function() {
        var t2 = this.startNode();
        return t2.name = this.tsParseTypeParameterName(), t2.constraint = this.tsExpectThenParseType(p2._in), this.finishNode(t2, "TSTypeParameter");
      }, A2.tsParseMappedType = function() {
        var t2 = this.startNode();
        return this.expect(p2.braceL), this.match(p2.plusMin) ? (t2.readonly = this.value, this.next(), this.expectContextual("readonly")) : this.eatContextual("readonly") && (t2.readonly = true), this.expect(p2.bracketL), t2.typeParameter = this.tsParseMappedTypeParameter(), t2.nameType = this.eatContextual("as") ? this.tsParseType() : null, this.expect(p2.bracketR), this.match(p2.plusMin) ? (t2.optional = this.value, this.next(), this.expect(p2.question)) : this.eat(p2.question) && (t2.optional = true), t2.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(p2.braceR), this.finishNode(t2, "TSMappedType");
      }, A2.tsParseTypeLiteral = function() {
        var t2 = this.startNode();
        return t2.members = this.tsParseObjectTypeMembers(), this.finishNode(t2, "TSTypeLiteral");
      }, A2.tsParseTupleElementType = function() {
        var t2 = this.startLoc, e3 = this.start, s4 = this.eat(p2.ellipsis), i3 = this.tsParseType(), r2 = this.eat(p2.question);
        if (this.eat(p2.colon)) {
          var a2 = this.startNodeAtNode(i3);
          a2.optional = r2, "TSTypeReference" !== i3.type || i3.typeParameters || "Identifier" !== i3.typeName.type ? (this.raise(i3.start, b.InvalidTupleMemberLabel), a2.label = i3) : a2.label = i3.typeName, a2.elementType = this.tsParseType(), i3 = this.finishNode(a2, "TSNamedTupleMember");
        } else if (r2) {
          var n4 = this.startNodeAtNode(i3);
          n4.typeAnnotation = i3, i3 = this.finishNode(n4, "TSOptionalType");
        }
        if (s4) {
          var o2 = this.startNodeAt(e3, t2);
          o2.typeAnnotation = i3, i3 = this.finishNode(o2, "TSRestType");
        }
        return i3;
      }, A2.tsParseTupleType = function() {
        var t2 = this, e3 = this.startNode();
        e3.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
        var s4 = false, i3 = null;
        return e3.elementTypes.forEach(function(e4) {
          var r2 = e4.type;
          !s4 || "TSRestType" === r2 || "TSOptionalType" === r2 || "TSNamedTupleMember" === r2 && e4.optional || t2.raise(e4.start, b.OptionalTypeBeforeRequired), s4 || (s4 = "TSNamedTupleMember" === r2 && e4.optional || "TSOptionalType" === r2);
          var a2 = r2;
          "TSRestType" === r2 && (a2 = (e4 = e4.typeAnnotation).type);
          var n4 = "TSNamedTupleMember" === a2;
          null != i3 || (i3 = n4), i3 !== n4 && t2.raise(e4.start, b.MixedLabeledAndUnlabeledElements);
        }), this.finishNode(e3, "TSTupleType");
      }, A2.tsParseTemplateLiteralType = function() {
        var t2 = this.startNode();
        return t2.literal = this.parseTemplate({ isTagged: false }), this.finishNode(t2, "TSLiteralType");
      }, A2.tsParseTypeReference = function() {
        var t2 = this.startNode();
        return t2.typeName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.tsMatchLeftRelational() && (t2.typeParameters = this.tsParseTypeArguments()), this.finishNode(t2, "TSTypeReference");
      }, A2.tsMatchLeftRelational = function() {
        return this.match(p2.relational) && "<" === this.value;
      }, A2.tsMatchRightRelational = function() {
        return this.match(p2.relational) && ">" === this.value;
      }, A2.tsParseParenthesizedType = function() {
        var t2 = this.startNode();
        return this.expect(p2.parenL), t2.typeAnnotation = this.tsParseType(), this.expect(p2.parenR), this.finishNode(t2, "TSParenthesizedType");
      }, A2.tsParseNonArrayType = function() {
        switch (this.type) {
          case p2.string:
          case p2.num:
          case p2._true:
          case p2._false:
            return this.tsParseLiteralTypeNode();
          case p2.plusMin:
            if ("-" === this.value) {
              var t2 = this.startNode();
              return this.lookahead().type !== p2.num && this.unexpected(), t2.literal = this.parseMaybeUnary(), this.finishNode(t2, "TSLiteralType");
            }
            break;
          case p2._this:
            return this.tsParseThisTypeOrThisTypePredicate();
          case p2._typeof:
            return this.tsParseTypeQuery();
          case p2._import:
            return this.tsParseImportType();
          case p2.braceL:
            return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
          case p2.bracketL:
            return this.tsParseTupleType();
          case p2.parenL:
            return this.tsParseParenthesizedType();
          case p2.backQuote:
          case p2.dollarBraceL:
            return this.tsParseTemplateLiteralType();
          default:
            var e3 = this.type;
            if (q(e3) || e3 === p2._void || e3 === p2._null) {
              var s4 = e3 === p2._void ? "TSVoidKeyword" : e3 === p2._null ? "TSNullKeyword" : function(t3) {
                switch (t3) {
                  case "any":
                    return "TSAnyKeyword";
                  case "boolean":
                    return "TSBooleanKeyword";
                  case "bigint":
                    return "TSBigIntKeyword";
                  case "never":
                    return "TSNeverKeyword";
                  case "number":
                    return "TSNumberKeyword";
                  case "object":
                    return "TSObjectKeyword";
                  case "string":
                    return "TSStringKeyword";
                  case "symbol":
                    return "TSSymbolKeyword";
                  case "undefined":
                    return "TSUndefinedKeyword";
                  case "unknown":
                    return "TSUnknownKeyword";
                  default:
                    return;
                }
              }(this.value);
              if (void 0 !== s4 && 46 !== this.lookaheadCharCode()) {
                var i3 = this.startNode();
                return this.next(), this.finishNode(i3, s4);
              }
              return this.tsParseTypeReference();
            }
        }
        this.unexpected();
      }, A2.tsParseArrayTypeOrHigher = function() {
        for (var t2 = this.tsParseNonArrayType(); !this.hasPrecedingLineBreak() && this.eat(p2.bracketL); ) if (this.match(p2.bracketR)) {
          var e3 = this.startNodeAtNode(t2);
          e3.elementType = t2, this.expect(p2.bracketR), t2 = this.finishNode(e3, "TSArrayType");
        } else {
          var s4 = this.startNodeAtNode(t2);
          s4.objectType = t2, s4.indexType = this.tsParseType(), this.expect(p2.bracketR), t2 = this.finishNode(s4, "TSIndexedAccessType");
        }
        return t2;
      }, A2.tsParseTypeOperatorOrHigher = function() {
        var t2 = this;
        return V(this.type) && !this.containsEsc ? this.tsParseTypeOperator() : this.isContextual("infer") ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(function() {
          return t2.tsParseArrayTypeOrHigher();
        });
      }, A2.tsParseIntersectionTypeOrHigher = function() {
        return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), p2.bitwiseAND);
      }, A2.tsParseUnionTypeOrHigher = function() {
        return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), p2.bitwiseOR);
      }, A2.tsParseNonConditionalType = function() {
        return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(p2._new) ? this.tsParseFunctionOrConstructorType("TSConstructorType") : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType("TSConstructorType", true) : this.tsParseUnionTypeOrHigher();
      }, A2.tsParseType = function() {
        var t2 = this;
        k(this.inType);
        var e3 = this.tsParseNonConditionalType();
        if (this.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(p2._extends)) return e3;
        var s4 = this.startNodeAtNode(e3);
        return s4.checkType = e3, s4.extendsType = this.tsInDisallowConditionalTypesContext(function() {
          return t2.tsParseNonConditionalType();
        }), this.expect(p2.question), s4.trueType = this.tsInAllowConditionalTypesContext(function() {
          return t2.tsParseType();
        }), this.expect(p2.colon), s4.falseType = this.tsInAllowConditionalTypesContext(function() {
          return t2.tsParseType();
        }), this.finishNode(s4, "TSConditionalType");
      }, A2.tsIsUnambiguouslyIndexSignature = function() {
        return this.next(), !!q(this.type) && (this.next(), this.match(p2.colon));
      }, A2.tsInType = function(t2) {
        var e3 = this.inType;
        this.inType = true;
        try {
          return t2();
        } finally {
          this.inType = e3;
        }
      }, A2.tsTryParseIndexSignature = function(t2) {
        if (this.match(p2.bracketL) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this))) {
          this.expect(p2.bracketL);
          var e3 = this.parseIdent();
          e3.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(e3), this.expect(p2.bracketR), t2.parameters = [e3];
          var s4 = this.tsTryParseTypeAnnotation();
          return s4 && (t2.typeAnnotation = s4), this.tsParseTypeMemberSemicolon(), this.finishNode(t2, "TSIndexSignature");
        }
      }, A2.tsParseNoneModifiers = function(t2) {
        this.tsParseModifiers({ modified: t2, allowedModifiers: [], disallowedModifiers: ["in", "out"], errorTemplate: b.InvalidModifierOnTypeParameterPositions });
      }, A2.tsParseTypeParameter = function(t2) {
        void 0 === t2 && (t2 = this.tsParseNoneModifiers.bind(this));
        var e3 = this.startNode();
        return t2(e3), e3.name = this.tsParseTypeParameterName(), e3.constraint = this.tsEatThenParseType(p2._extends), e3.default = this.tsEatThenParseType(p2.eq), this.finishNode(e3, "TSTypeParameter");
      }, A2.tsParseTypeParameters = function(t2) {
        var e3 = this.startNode();
        this.tsMatchLeftRelational() || this.matchJsx("jsxTagStart") ? this.next() : this.unexpected();
        var s4 = { value: -1 };
        return e3.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, t2), false, true, s4), 0 === e3.params.length && this.raise(this.start, b.EmptyTypeParameters), -1 !== s4.value && this.addExtra(e3, "trailingComma", s4.value), this.finishNode(e3, "TSTypeParameterDeclaration");
      }, A2.tsTryParseTypeParameters = function(t2) {
        if (this.tsMatchLeftRelational()) return this.tsParseTypeParameters(t2);
      }, A2.tsTryParse = function(t2) {
        var e3 = this.getCurLookaheadState(), s4 = t2();
        return void 0 !== s4 && false !== s4 ? s4 : void this.setLookaheadState(e3);
      }, A2.tsTokenCanFollowModifier = function() {
        return (this.match(p2.bracketL) || this.match(p2.braceL) || this.match(p2.star) || this.match(p2.ellipsis) || this.match(p2.privateId) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
      }, A2.tsNextTokenCanFollowModifier = function() {
        return this.next(true), this.tsTokenCanFollowModifier();
      }, A2.tsParseModifier = function(t2, e3) {
        if (q(this.type) || this.type === p2._in) {
          var s4 = this.value;
          if (-1 !== t2.indexOf(s4) && !this.containsEsc) {
            if (e3 && this.tsIsStartOfStaticBlocks()) return;
            if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) return s4;
          }
        }
      }, A2.tsParseModifiersByMap = function(t2) {
        for (var e3 = t2.modified, s4 = t2.map, i3 = 0, r2 = Object.keys(s4); i3 < r2.length; i3++) {
          var a2 = r2[i3];
          e3[a2] = s4[a2];
        }
      }, A2.tsParseModifiers = function(t2) {
        for (var e3 = this, s4 = t2.modified, i3 = t2.allowedModifiers, r2 = t2.disallowedModifiers, a2 = t2.stopOnStartOfClassStaticBlock, n4 = t2.errorTemplate, o2 = void 0 === n4 ? b.InvalidModifierOnTypeMember : n4, h3 = {}, p3 = function(t3, i4, r3, a3) {
          i4 === r3 && s4[a3] && e3.raise(t3.column, b.InvalidModifiersOrder({ orderedModifiers: [r3, a3] }));
        }, c2 = function(t3, i4, r3, a3) {
          (s4[r3] && i4 === a3 || s4[a3] && i4 === r3) && e3.raise(t3.column, b.IncompatibleModifiers({ modifiers: [r3, a3] }));
        }; ; ) {
          var l3 = this.startLoc, u3 = this.tsParseModifier(i3.concat(null != r2 ? r2 : []), a2);
          if (!u3) break;
          O(u3) ? s4.accessibility ? this.raise(this.start, b.DuplicateAccessibilityModifier()) : (p3(l3, u3, u3, "override"), p3(l3, u3, u3, "static"), p3(l3, u3, u3, "readonly"), p3(l3, u3, u3, "accessor"), h3.accessibility = u3, s4.accessibility = u3) : N(u3) ? s4[u3] ? this.raise(this.start, b.DuplicateModifier({ modifier: u3 })) : (p3(l3, u3, "in", "out"), h3[u3] = u3, s4[u3] = true) : I(u3) ? s4[u3] ? this.raise(this.start, b.DuplicateModifier({ modifier: u3 })) : (c2(l3, u3, "accessor", "readonly"), c2(l3, u3, "accessor", "static"), c2(l3, u3, "accessor", "override"), h3[u3] = u3, s4[u3] = true) : Object.hasOwnProperty.call(s4, u3) ? this.raise(this.start, b.DuplicateModifier({ modifier: u3 })) : (p3(l3, u3, "static", "readonly"), p3(l3, u3, "static", "override"), p3(l3, u3, "override", "readonly"), p3(l3, u3, "abstract", "override"), c2(l3, u3, "declare", "override"), c2(l3, u3, "static", "abstract"), h3[u3] = u3, s4[u3] = true), null != r2 && r2.includes(u3) && this.raise(this.start, o2);
        }
        return h3;
      }, A2.tsParseInOutModifiers = function(t2) {
        this.tsParseModifiers({ modified: t2, allowedModifiers: ["in", "out"], disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"], errorTemplate: b.InvalidModifierOnTypeParameter });
      }, A2.tsParseTypeArguments = function() {
        var t2 = this, e3 = this.startNode();
        return e3.params = this.tsInType(function() {
          return t2.tsInNoContext(function() {
            return t2.expect(p2.relational), t2.tsParseDelimitedList("TypeParametersOrArguments", t2.tsParseType.bind(t2));
          });
        }), 0 === e3.params.length && this.raise(this.start, b.EmptyTypeArguments), this.exprAllowed = false, this.expect(p2.relational), this.finishNode(e3, "TSTypeParameterInstantiation");
      }, A2.tsParseHeritageClause = function(t2) {
        var e3 = this, s4 = this.start, i3 = this.tsParseDelimitedList("HeritageClauseElement", function() {
          var t3 = e3.startNode();
          return t3.expression = e3.tsParseEntityName(), e3.tsMatchLeftRelational() && (t3.typeParameters = e3.tsParseTypeArguments()), e3.finishNode(t3, "TSExpressionWithTypeArguments");
        });
        return i3.length || this.raise(s4, b.EmptyHeritageClauseType({ token: t2 })), i3;
      }, A2.tsParseTypeMemberSemicolon = function() {
        this.eat(p2.comma) || this.isLineTerminator() || this.expect(p2.semi);
      }, A2.tsTryParseAndCatch = function(t2) {
        var e3 = this.tryParse(function(e4) {
          return t2() || e4();
        });
        if (!e3.aborted && e3.node) return e3.error && this.setLookaheadState(e3.failState), e3.node;
      }, A2.tsParseSignatureMember = function(t2, e3) {
        return this.tsFillSignature(p2.colon, e3), this.tsParseTypeMemberSemicolon(), this.finishNode(e3, t2);
      }, A2.tsParsePropertyOrMethodSignature = function(t2, e3) {
        this.eat(p2.question) && (t2.optional = true);
        var s4 = t2;
        if (this.match(p2.parenL) || this.tsMatchLeftRelational()) {
          e3 && this.raise(t2.start, b.ReadonlyForMethodSignature);
          var i3 = s4;
          i3.kind && this.tsMatchLeftRelational() && this.raise(this.start, b.AccesorCannotHaveTypeParameters), this.tsFillSignature(p2.colon, i3), this.tsParseTypeMemberSemicolon();
          var r2 = "parameters", a2 = "typeAnnotation";
          if ("get" === i3.kind) i3[r2].length > 0 && (this.raise(this.start, "A 'get' accesor must not have any formal parameters."), this.isThisParam(i3[r2][0]) && this.raise(this.start, b.AccesorCannotDeclareThisParameter));
          else if ("set" === i3.kind) {
            if (1 !== i3[r2].length) this.raise(this.start, "A 'get' accesor must not have any formal parameters.");
            else {
              var n4 = i3[r2][0];
              this.isThisParam(n4) && this.raise(this.start, b.AccesorCannotDeclareThisParameter), "Identifier" === n4.type && n4.optional && this.raise(this.start, b.SetAccesorCannotHaveOptionalParameter), "RestElement" === n4.type && this.raise(this.start, b.SetAccesorCannotHaveRestParameter);
            }
            i3[a2] && this.raise(i3[a2].start, b.SetAccesorCannotHaveReturnType);
          } else i3.kind = "method";
          return this.finishNode(i3, "TSMethodSignature");
        }
        var o2 = s4;
        e3 && (o2.readonly = true);
        var h3 = this.tsTryParseTypeAnnotation();
        return h3 && (o2.typeAnnotation = h3), this.tsParseTypeMemberSemicolon(), this.finishNode(o2, "TSPropertySignature");
      }, A2.tsParseTypeMember = function() {
        var t2 = this.startNode();
        if (this.match(p2.parenL) || this.tsMatchLeftRelational()) return this.tsParseSignatureMember("TSCallSignatureDeclaration", t2);
        if (this.match(p2._new)) {
          var e3 = this.startNode();
          return this.next(), this.match(p2.parenL) || this.tsMatchLeftRelational() ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", t2) : (t2.key = this.createIdentifier(e3, "new"), this.tsParsePropertyOrMethodSignature(t2, false));
        }
        return this.tsParseModifiers({ modified: t2, allowedModifiers: ["readonly"], disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"] }), this.tsTryParseIndexSignature(t2) || (this.parsePropertyName(t2), t2.computed || "Identifier" !== t2.key.type || "get" !== t2.key.name && "set" !== t2.key.name || !this.tsTokenCanFollowModifier() || (t2.kind = t2.key.name, this.parsePropertyName(t2)), this.tsParsePropertyOrMethodSignature(t2, !!t2.readonly));
      }, A2.tsParseList = function(t2, e3) {
        for (var s4 = []; !this.tsIsListTerminator(t2); ) s4.push(e3());
        return s4;
      }, A2.tsParseObjectTypeMembers = function() {
        this.expect(p2.braceL);
        var t2 = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
        return this.expect(p2.braceR), t2;
      }, A2.tsParseInterfaceDeclaration = function(t2, e3) {
        if (void 0 === e3 && (e3 = {}), this.hasFollowingLineBreak()) return null;
        this.expectContextual("interface"), e3.declare && (t2.declare = true), q(this.type) ? (t2.id = this.parseIdent(), this.checkLValSimple(t2.id, 7)) : (t2.id = null, this.raise(this.start, b.MissingInterfaceName)), t2.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this)), this.eat(p2._extends) && (t2.extends = this.tsParseHeritageClause("extends"));
        var s4 = this.startNode();
        return s4.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), t2.body = this.finishNode(s4, "TSInterfaceBody"), this.finishNode(t2, "TSInterfaceDeclaration");
      }, A2.tsParseAbstractDeclaration = function(t2) {
        if (this.match(p2._class)) return t2.abstract = true, this.parseClass(t2, true);
        if (this.ts_isContextual(_.interface)) {
          if (!this.hasFollowingLineBreak()) return t2.abstract = true, this.tsParseInterfaceDeclaration(t2);
        } else this.unexpected(t2.start);
      }, A2.tsIsDeclarationStart = function() {
        return H(this.type);
      }, A2.tsParseExpressionStatement = function(e3, s4) {
        switch (s4.name) {
          case "declare":
            var i3 = this.tsTryParseDeclare(e3);
            if (i3) return i3.declare = true, i3;
            break;
          case "global":
            if (this.match(p2.braceL)) {
              t.prototype.enterScope.call(this, f);
              var r2 = e3;
              return r2.global = true, r2.id = s4, r2.body = this.tsParseModuleBlock(), t.prototype.exitScope.call(this), this.finishNode(r2, "TSModuleDeclaration");
            }
            break;
          default:
            return this.tsParseDeclaration(e3, s4.name, false);
        }
      }, A2.tsParseModuleReference = function() {
        return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);
      }, A2.tsIsExportDefaultSpecifier = function() {
        var t2 = this.type, e3 = this.isAsyncFunction(), s4 = this.isLet();
        if (q(t2)) {
          if (e3 && !this.containsEsc || s4) return false;
          if ((t2 === _.type || t2 === _.interface) && !this.containsEsc) {
            var i3 = this.lookahead();
            if (q(i3.type) && !this.isContextualWithState("from", i3) || i3.type === p2.braceL) return false;
          }
        } else if (!this.match(p2._default)) return false;
        var r2 = this.nextTokenStart(), a2 = this.isUnparsedContextual(r2, "from");
        if (44 === this.input.charCodeAt(r2) || q(this.type) && a2) return true;
        if (this.match(p2._default) && a2) {
          var n4 = this.input.charCodeAt(this.nextTokenStartSince(r2 + 4));
          return 34 === n4 || 39 === n4;
        }
        return false;
      }, A2.tsInAmbientContext = function(t2) {
        var e3 = this.isAmbientContext;
        this.isAmbientContext = true;
        try {
          return t2();
        } finally {
          this.isAmbientContext = e3;
        }
      }, A2.tsCheckLineTerminator = function(t2) {
        return t2 ? !this.hasFollowingLineBreak() && (this.next(), true) : !this.isLineTerminator();
      }, A2.tsParseModuleOrNamespaceDeclaration = function(e3, s4) {
        if (void 0 === s4 && (s4 = false), e3.id = this.parseIdent(), s4 || this.checkLValSimple(e3.id, 8), this.eat(p2.dot)) {
          var i3 = this.startNode();
          this.tsParseModuleOrNamespaceDeclaration(i3, true), e3.body = i3;
        } else t.prototype.enterScope.call(this, f), e3.body = this.tsParseModuleBlock(), t.prototype.exitScope.call(this);
        return this.finishNode(e3, "TSModuleDeclaration");
      }, A2.checkLValSimple = function(e3, s4, i3) {
        return void 0 === s4 && (s4 = 0), t.prototype.checkLValSimple.call(this, e3, s4, i3);
      }, A2.tsParseTypeAliasDeclaration = function(t2) {
        var e3 = this;
        return t2.id = this.parseIdent(), this.checkLValSimple(t2.id, 6), t2.typeAnnotation = this.tsInType(function() {
          if (t2.typeParameters = e3.tsTryParseTypeParameters(e3.tsParseInOutModifiers.bind(e3)), e3.expect(p2.eq), e3.ts_isContextual(_.interface) && e3.lookahead().type !== p2.dot) {
            var s4 = e3.startNode();
            return e3.next(), e3.finishNode(s4, "TSIntrinsicKeyword");
          }
          return e3.tsParseType();
        }), this.semicolon(), this.finishNode(t2, "TSTypeAliasDeclaration");
      }, A2.tsParseDeclaration = function(t2, e3, s4) {
        switch (e3) {
          case "abstract":
            if (this.tsCheckLineTerminator(s4) && (this.match(p2._class) || q(this.type))) return this.tsParseAbstractDeclaration(t2);
            break;
          case "module":
            if (this.tsCheckLineTerminator(s4)) {
              if (this.match(p2.string)) return this.tsParseAmbientExternalModuleDeclaration(t2);
              if (q(this.type)) return this.tsParseModuleOrNamespaceDeclaration(t2);
            }
            break;
          case "namespace":
            if (this.tsCheckLineTerminator(s4) && q(this.type)) return this.tsParseModuleOrNamespaceDeclaration(t2);
            break;
          case "type":
            if (this.tsCheckLineTerminator(s4) && q(this.type)) return this.tsParseTypeAliasDeclaration(t2);
        }
      }, A2.tsTryParseExportDeclaration = function() {
        return this.tsParseDeclaration(this.startNode(), this.value, true);
      }, A2.tsParseImportEqualsDeclaration = function(e3, s4) {
        e3.isExport = s4 || false, e3.id = this.parseIdent(), this.checkLValSimple(e3.id, 2), t.prototype.expect.call(this, p2.eq);
        var i3 = this.tsParseModuleReference();
        return "type" === e3.importKind && "TSExternalModuleReference" !== i3.type && this.raise(i3.start, b.ImportAliasHasImportType), e3.moduleReference = i3, t.prototype.semicolon.call(this), this.finishNode(e3, "TSImportEqualsDeclaration");
      }, A2.isExportDefaultSpecifier = function() {
        if (this.tsIsDeclarationStart()) return false;
        var t2 = this.type;
        if (q(t2)) {
          if (this.isContextual("async") || this.isContextual("let")) return false;
          if ((t2 === _.type || t2 === _.interface) && !this.containsEsc) {
            var e3 = this.lookahead();
            if (q(e3.type) && !this.isContextualWithState("from", e3) || e3.type === p2.braceL) return false;
          }
        } else if (!this.match(p2._default)) return false;
        var s4 = this.nextTokenStart(), i3 = this.isUnparsedContextual(s4, "from");
        if (44 === this.input.charCodeAt(s4) || q(this.type) && i3) return true;
        if (this.match(p2._default) && i3) {
          var r2 = this.input.charCodeAt(this.nextTokenStartSince(s4 + 4));
          return 34 === r2 || 39 === r2;
        }
        return false;
      }, A2.parseTemplate = function(t2) {
        var e3 = (void 0 === t2 ? {} : t2).isTagged, s4 = void 0 !== e3 && e3, i3 = this.startNode();
        this.next(), i3.expressions = [];
        var r2 = this.parseTemplateElement({ isTagged: s4 });
        for (i3.quasis = [r2]; !r2.tail; ) this.type === p2.eof && this.raise(this.pos, "Unterminated template literal"), this.expect(p2.dollarBraceL), i3.expressions.push(this.inType ? this.tsParseType() : this.parseExpression()), this.expect(p2.braceR), i3.quasis.push(r2 = this.parseTemplateElement({ isTagged: s4 }));
        return this.next(), this.finishNode(i3, "TemplateLiteral");
      }, A2.parseFunction = function(t2, e3, s4, i3, r2) {
        this.initFunction(t2), (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !i3) && (this.type === p2.star && 2 & e3 && this.unexpected(), t2.generator = this.eat(p2.star)), this.options.ecmaVersion >= 8 && (t2.async = !!i3), 1 & e3 && (t2.id = 4 & e3 && this.type !== p2.name ? null : this.parseIdent());
        var a2 = this.yieldPos, n4 = this.awaitPos, o2 = this.awaitIdentPos, h3 = this.maybeInArrowParameters;
        this.maybeInArrowParameters = false, this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(w(t2.async, t2.generator)), 1 & e3 || (t2.id = this.type === p2.name ? this.parseIdent() : null), this.parseFunctionParams(t2);
        var c2 = 1 & e3;
        return this.parseFunctionBody(t2, s4, false, r2, { isFunctionDeclaration: c2 }), this.yieldPos = a2, this.awaitPos = n4, this.awaitIdentPos = o2, 1 & e3 && t2.id && !(2 & e3) && this.checkLValSimple(t2.id, t2.body ? this.strict || t2.generator || t2.async ? this.treatFunctionsAsVar ? 1 : 2 : 3 : 0), this.maybeInArrowParameters = h3, this.finishNode(t2, c2 ? "FunctionDeclaration" : "FunctionExpression");
      }, A2.parseFunctionBody = function(e3, s4, i3, r2, a2) {
        void 0 === s4 && (s4 = false), void 0 === i3 && (i3 = false), void 0 === r2 && (r2 = false), this.match(p2.colon) && (e3.returnType = this.tsParseTypeOrTypePredicateAnnotation(p2.colon));
        var n4 = null != a2 && a2.isFunctionDeclaration ? "TSDeclareFunction" : null != a2 && a2.isClassMethod ? "TSDeclareMethod" : void 0;
        return n4 && !this.match(p2.braceL) && this.isLineTerminator() ? this.finishNode(e3, n4) : "TSDeclareFunction" === n4 && this.isAmbientContext && (this.raise(e3.start, b.DeclareFunctionHasImplementation), e3.declare) ? (t.prototype.parseFunctionBody.call(this, e3, s4, i3, false), this.finishNode(e3, n4)) : (t.prototype.parseFunctionBody.call(this, e3, s4, i3, r2), e3);
      }, A2.parseNew = function() {
        var t2;
        this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword new");
        var e3 = this.startNode(), s4 = this.parseIdent(true);
        if (this.options.ecmaVersion >= 6 && this.eat(p2.dot)) {
          e3.meta = s4;
          var i3 = this.containsEsc;
          return e3.property = this.parseIdent(true), "target" !== e3.property.name && this.raiseRecoverable(e3.property.start, "The only valid meta property for new is 'new.target'"), i3 && this.raiseRecoverable(e3.start, "'new.target' must not contain escaped characters"), this.allowNewDotTarget || this.raiseRecoverable(e3.start, "'new.target' can only be used in functions and class static block"), this.finishNode(e3, "MetaProperty");
        }
        var r2 = this.start, a2 = this.startLoc, n4 = this.type === p2._import;
        e3.callee = this.parseSubscripts(this.parseExprAtom(), r2, a2, true, false), n4 && "ImportExpression" === e3.callee.type && this.raise(r2, "Cannot use new with import()");
        var o2 = e3.callee;
        return "TSInstantiationExpression" !== o2.type || null != (t2 = o2.extra) && t2.parenthesized || (e3.typeParameters = o2.typeParameters, e3.callee = o2.expression), e3.arguments = this.eat(p2.parenL) ? this.parseExprList(p2.parenR, this.options.ecmaVersion >= 8, false) : [], this.finishNode(e3, "NewExpression");
      }, A2.parseExprOp = function(e3, s4, i3, r2, a2) {
        var n4;
        if (p2._in.binop > r2 && !this.hasPrecedingLineBreak() && (this.isContextual("as") && (n4 = "TSAsExpression"), h2 && this.isContextual("satisfies") && (n4 = "TSSatisfiesExpression"), n4)) {
          var o2 = this.startNodeAt(s4, i3);
          o2.expression = e3;
          var c2 = this.tsTryNextParseConstantContext();
          return o2.typeAnnotation = c2 || this.tsNextThenParseType(), this.finishNode(o2, n4), this.reScan_lt_gt(), this.parseExprOp(o2, s4, i3, r2, a2);
        }
        return t.prototype.parseExprOp.call(this, e3, s4, i3, r2, a2);
      }, A2.parseImportSpecifiers = function() {
        var t2 = [], e3 = true;
        if (n3.tokenIsIdentifier(this.type) && (t2.push(this.parseImportDefaultSpecifier()), !this.eat(p2.comma))) return t2;
        if (this.type === p2.star) return t2.push(this.parseImportNamespaceSpecifier()), t2;
        for (this.expect(p2.braceL); !this.eat(p2.braceR); ) {
          if (e3) e3 = false;
          else if (this.expect(p2.comma), this.afterTrailingComma(p2.braceR)) break;
          t2.push(this.parseImportSpecifier());
        }
        return t2;
      }, A2.parseImport = function(t2) {
        var e3 = this.lookahead();
        if (t2.importKind = "value", this.importOrExportOuterKind = "value", q(e3.type) || this.match(p2.star) || this.match(p2.braceL)) {
          var s4 = this.lookahead(2);
          if (s4.type !== p2.comma && !this.isContextualWithState("from", s4) && s4.type !== p2.eq && this.ts_eatContextualWithState("type", 1, e3) && (this.importOrExportOuterKind = "type", t2.importKind = "type", e3 = this.lookahead(), s4 = this.lookahead(2)), q(e3.type) && s4.type === p2.eq) {
            this.next();
            var i3 = this.tsParseImportEqualsDeclaration(t2);
            return this.importOrExportOuterKind = "value", i3;
          }
        }
        return this.next(), this.type === p2.string ? (t2.specifiers = [], t2.source = this.parseExprAtom()) : (t2.specifiers = this.parseImportSpecifiers(), this.expectContextual("from"), t2.source = this.type === p2.string ? this.parseExprAtom() : this.unexpected()), this.parseMaybeImportAttributes(t2), this.semicolon(), this.finishNode(t2, "ImportDeclaration"), this.importOrExportOuterKind = "value", "type" === t2.importKind && t2.specifiers.length > 1 && "ImportDefaultSpecifier" === t2.specifiers[0].type && this.raise(t2.start, b.TypeImportCannotSpecifyDefaultAndNamed), t2;
      }, A2.parseExportDefaultDeclaration = function() {
        if (this.isAbstractClass()) {
          var e3 = this.startNode();
          return this.next(), e3.abstract = true, this.parseClass(e3, true);
        }
        if (this.match(_.interface)) {
          var s4 = this.tsParseInterfaceDeclaration(this.startNode());
          if (s4) return s4;
        }
        return t.prototype.parseExportDefaultDeclaration.call(this);
      }, A2.parseExportAllDeclaration = function(t2, e3) {
        return this.options.ecmaVersion >= 11 && (this.eatContextual("as") ? (t2.exported = this.parseModuleExportName(), this.checkExport(e3, t2.exported, this.lastTokStart)) : t2.exported = null), this.expectContextual("from"), this.type !== p2.string && this.unexpected(), t2.source = this.parseExprAtom(), this.parseMaybeImportAttributes(t2), this.semicolon(), this.finishNode(t2, "ExportAllDeclaration");
      }, A2.parseDynamicImport = function(t2) {
        if (this.next(), t2.source = this.parseMaybeAssign(), this.eat(p2.comma)) {
          var e3 = this.parseExpression();
          t2.arguments = [e3];
        }
        if (!this.eat(p2.parenR)) {
          var s4 = this.start;
          this.eat(p2.comma) && this.eat(p2.parenR) ? this.raiseRecoverable(s4, "Trailing comma is not allowed in import()") : this.unexpected(s4);
        }
        return this.finishNode(t2, "ImportExpression");
      }, A2.parseExport = function(t2, e3) {
        var s4 = this.lookahead();
        if (this.ts_eatWithState(p2._import, 2, s4)) {
          this.ts_isContextual(_.type) && 61 !== this.lookaheadCharCode() ? (t2.importKind = "type", this.importOrExportOuterKind = "type", this.next()) : (t2.importKind = "value", this.importOrExportOuterKind = "value");
          var i3 = this.tsParseImportEqualsDeclaration(t2, true);
          return this.importOrExportOuterKind = void 0, i3;
        }
        if (this.ts_eatWithState(p2.eq, 2, s4)) {
          var r2 = t2;
          return r2.expression = this.parseExpression(), this.semicolon(), this.importOrExportOuterKind = void 0, this.finishNode(r2, "TSExportAssignment");
        }
        if (this.ts_eatContextualWithState("as", 2, s4)) {
          var a2 = t2;
          return this.expectContextual("namespace"), a2.id = this.parseIdent(), this.semicolon(), this.importOrExportOuterKind = void 0, this.finishNode(a2, "TSNamespaceExportDeclaration");
        }
        if (this.ts_isContextualWithState(s4, _.type) && this.lookahead(2).type === p2.braceL ? (this.next(), this.importOrExportOuterKind = "type", t2.exportKind = "type") : (this.importOrExportOuterKind = "value", t2.exportKind = "value"), this.next(), this.eat(p2.star)) return this.parseExportAllDeclaration(t2, e3);
        if (this.eat(p2._default)) return this.checkExport(e3, "default", this.lastTokStart), t2.declaration = this.parseExportDefaultDeclaration(), this.finishNode(t2, "ExportDefaultDeclaration");
        if (this.shouldParseExportStatement()) t2.declaration = this.parseExportDeclaration(t2), "VariableDeclaration" === t2.declaration.type ? this.checkVariableExport(e3, t2.declaration.declarations) : this.checkExport(e3, t2.declaration.id, t2.declaration.id.start), t2.specifiers = [], t2.source = null;
        else {
          if (t2.declaration = null, t2.specifiers = this.parseExportSpecifiers(e3), this.eatContextual("from")) this.type !== p2.string && this.unexpected(), t2.source = this.parseExprAtom(), this.parseMaybeImportAttributes(t2);
          else {
            for (var n4, o2 = c(t2.specifiers); !(n4 = o2()).done; ) {
              var h3 = n4.value;
              this.checkUnreserved(h3.local), this.checkLocalExport(h3.local), "Literal" === h3.local.type && this.raise(h3.local.start, "A string literal cannot be used as an exported binding without `from`.");
            }
            t2.source = null;
          }
          this.semicolon();
        }
        return this.finishNode(t2, "ExportNamedDeclaration");
      }, A2.checkExport = function(t2, e3, s4) {
        t2 && ("string" != typeof e3 && (e3 = "Identifier" === e3.type ? e3.name : e3.value), t2[e3] = true);
      }, A2.parseMaybeDefault = function(e3, s4, i3) {
        var r2 = t.prototype.parseMaybeDefault.call(this, e3, s4, i3);
        return "AssignmentPattern" === r2.type && r2.typeAnnotation && r2.right.start < r2.typeAnnotation.start && this.raise(r2.typeAnnotation.start, b.TypeAnnotationAfterAssign), r2;
      }, A2.typeCastToParameter = function(t2) {
        return t2.expression.typeAnnotation = t2.typeAnnotation, this.resetEndLocation(t2.expression, t2.typeAnnotation.end), t2.expression;
      }, A2.toAssignableList = function(e3, s4) {
        for (var i3 = 0; i3 < e3.length; i3++) {
          var r2 = e3[i3];
          "TSTypeCastExpression" === (null == r2 ? void 0 : r2.type) && (e3[i3] = this.typeCastToParameter(r2));
        }
        return t.prototype.toAssignableList.call(this, e3, s4);
      }, A2.reportReservedArrowTypeParam = function(t2) {
      }, A2.parseExprAtom = function(e3, s4, i3) {
        if (this.type === _.jsxText) return this.jsx_parseText();
        if (this.type === _.jsxTagStart) return this.jsx_parseElement();
        if (this.type === _.at) return this.parseDecorators(), this.parseExprAtom();
        if (q(this.type)) {
          var r2 = this.potentialArrowAt === this.start, a2 = this.start, n4 = this.startLoc, o2 = this.containsEsc, h3 = this.parseIdent(false);
          if (this.options.ecmaVersion >= 8 && !o2 && "async" === h3.name && !this.canInsertSemicolon() && this.eat(p2._function)) return this.overrideContext(M2.f_expr), this.parseFunction(this.startNodeAt(a2, n4), 0, false, true, s4);
          if (r2 && !this.canInsertSemicolon()) {
            if (this.eat(p2.arrow)) return this.parseArrowExpression(this.startNodeAt(a2, n4), [h3], false, s4);
            if (this.options.ecmaVersion >= 8 && "async" === h3.name && this.type === p2.name && !o2 && (!this.potentialArrowInForAwait || "of" !== this.value || this.containsEsc)) return h3 = this.parseIdent(false), !this.canInsertSemicolon() && this.eat(p2.arrow) || this.unexpected(), this.parseArrowExpression(this.startNodeAt(a2, n4), [h3], true, s4);
          }
          return h3;
        }
        return t.prototype.parseExprAtom.call(this, e3, s4, i3);
      }, A2.parseExprAtomDefault = function() {
        if (q(this.type)) {
          var t2 = this.potentialArrowAt === this.start, e3 = this.containsEsc, s4 = this.parseIdent();
          if (!e3 && "async" === s4.name && !this.canInsertSemicolon()) {
            var i3 = this.type;
            if (i3 === p2._function) return this.next(), this.parseFunction(this.startNodeAtNode(s4), void 0, true, true);
            if (q(i3)) {
              if (61 === this.lookaheadCharCode()) {
                var r2 = this.parseIdent(false);
                return !this.canInsertSemicolon() && this.eat(p2.arrow) || this.unexpected(), this.parseArrowExpression(this.startNodeAtNode(s4), [r2], true);
              }
              return s4;
            }
          }
          return t2 && this.match(p2.arrow) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(s4), [s4], false)) : s4;
        }
        this.unexpected();
      }, A2.parseIdentNode = function() {
        var e3 = this.startNode();
        return U(this.type) ? (e3.name = this.value, e3) : t.prototype.parseIdentNode.call(this);
      }, A2.parseVarStatement = function(e3, s4, i3) {
        void 0 === i3 && (i3 = false);
        var r2 = this.isAmbientContext;
        this.next(), t.prototype.parseVar.call(this, e3, false, s4, i3 || r2), this.semicolon();
        var a2 = this.finishNode(e3, "VariableDeclaration");
        if (!r2) return a2;
        for (var n4, o2 = c(a2.declarations); !(n4 = o2()).done; ) {
          var h3 = n4.value, p3 = h3.init;
          p3 && ("const" !== s4 || h3.id.typeAnnotation ? this.raise(p3.start, b.InitializerNotAllowedInAmbientContext) : "StringLiteral" !== p3.type && "BooleanLiteral" !== p3.type && "NumericLiteral" !== p3.type && "BigIntLiteral" !== p3.type && ("TemplateLiteral" !== p3.type || p3.expressions.length > 0) && !L(p3) && this.raise(p3.start, b.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference));
        }
        return a2;
      }, A2.parseStatement = function(e3, s4, i3) {
        if (this.match(_.at) && this.parseDecorators(true), this.match(p2._const) && this.isLookaheadContextual("enum")) {
          var r2 = this.startNode();
          return this.expect(p2._const), this.tsParseEnumDeclaration(r2, { const: true });
        }
        if (this.ts_isContextual(_.enum)) return this.tsParseEnumDeclaration(this.startNode());
        if (this.ts_isContextual(_.interface)) {
          var a2 = this.tsParseInterfaceDeclaration(this.startNode());
          if (a2) return a2;
        }
        return t.prototype.parseStatement.call(this, e3, s4, i3);
      }, A2.parseAccessModifier = function() {
        return this.tsParseModifier(["public", "protected", "private"]);
      }, A2.parsePostMemberNameModifiers = function(t2) {
        this.eat(p2.question) && (t2.optional = true), t2.readonly && this.match(p2.parenL) && this.raise(t2.start, b.ClassMethodHasReadonly), t2.declare && this.match(p2.parenL) && this.raise(t2.start, b.ClassMethodHasDeclare);
      }, A2.parseExpressionStatement = function(e3, s4) {
        return ("Identifier" === s4.type ? this.tsParseExpressionStatement(e3, s4) : void 0) || t.prototype.parseExpressionStatement.call(this, e3, s4);
      }, A2.shouldParseExportStatement = function() {
        return !!this.tsIsDeclarationStart() || !!this.match(_.at) || t.prototype.shouldParseExportStatement.call(this);
      }, A2.parseConditional = function(t2, e3, s4, i3, r2) {
        if (this.eat(p2.question)) {
          var a2 = this.startNodeAt(e3, s4);
          return a2.test = t2, a2.consequent = this.parseMaybeAssign(), this.expect(p2.colon), a2.alternate = this.parseMaybeAssign(i3), this.finishNode(a2, "ConditionalExpression");
        }
        return t2;
      }, A2.parseMaybeConditional = function(t2, e3) {
        var s4 = this, i3 = this.start, r2 = this.startLoc, a2 = this.parseExprOps(t2, e3);
        if (this.checkExpressionErrors(e3)) return a2;
        if (!this.maybeInArrowParameters || !this.match(p2.question)) return this.parseConditional(a2, i3, r2, t2, e3);
        var n4 = this.tryParse(function() {
          return s4.parseConditional(a2, i3, r2, t2, e3);
        });
        return n4.node ? (n4.error && this.setLookaheadState(n4.failState), n4.node) : (n4.error && this.setOptionalParametersError(e3, n4.error), a2);
      }, A2.parseParenItem = function(e3) {
        var s4 = this.start, i3 = this.startLoc;
        if (e3 = t.prototype.parseParenItem.call(this, e3), this.eat(p2.question) && (e3.optional = true, this.resetEndLocation(e3)), this.match(p2.colon)) {
          var r2 = this.startNodeAt(s4, i3);
          return r2.expression = e3, r2.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(r2, "TSTypeCastExpression");
        }
        return e3;
      }, A2.parseExportDeclaration = function(t2) {
        var e3 = this;
        if (!this.isAmbientContext && this.ts_isContextual(_.declare)) return this.tsInAmbientContext(function() {
          return e3.parseExportDeclaration(t2);
        });
        var s4 = this.start, i3 = this.startLoc, r2 = this.eatContextual("declare");
        !r2 || !this.ts_isContextual(_.declare) && this.shouldParseExportStatement() || this.raise(this.start, b.ExpectedAmbientAfterExportDeclare);
        var a2 = q(this.type) && this.tsTryParseExportDeclaration() || this.parseStatement(null);
        return a2 ? (("TSInterfaceDeclaration" === a2.type || "TSTypeAliasDeclaration" === a2.type || r2) && (t2.exportKind = "type"), r2 && (this.resetStartLocation(a2, s4, i3), a2.declare = true), a2) : null;
      }, A2.parseClassId = function(e3, s4) {
        if (s4 || !this.isContextual("implements")) {
          t.prototype.parseClassId.call(this, e3, s4);
          var i3 = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this));
          i3 && (e3.typeParameters = i3);
        }
      }, A2.parseClassPropertyAnnotation = function(t2) {
        t2.optional || ("!" === this.value && this.eat(p2.prefix) ? t2.definite = true : this.eat(p2.question) && (t2.optional = true));
        var e3 = this.tsTryParseTypeAnnotation();
        e3 && (t2.typeAnnotation = e3);
      }, A2.parseClassField = function(e3) {
        if ("PrivateIdentifier" === e3.key.type) e3.abstract && this.raise(e3.start, b.PrivateElementHasAbstract), e3.accessibility && this.raise(e3.start, b.PrivateElementHasAccessibility({ modifier: e3.accessibility })), this.parseClassPropertyAnnotation(e3);
        else if (this.parseClassPropertyAnnotation(e3), this.isAmbientContext && (!e3.readonly || e3.typeAnnotation) && this.match(p2.eq) && this.raise(this.start, b.DeclareClassFieldHasInitializer), e3.abstract && this.match(p2.eq)) {
          var s4 = e3.key;
          this.raise(this.start, b.AbstractPropertyHasInitializer({ propertyName: "Identifier" !== s4.type || e3.computed ? "[" + this.input.slice(s4.start, s4.end) + "]" : s4.name }));
        }
        return t.prototype.parseClassField.call(this, e3);
      }, A2.parseClassMethod = function(t2, e3, s4, i3) {
        var r2 = "constructor" === t2.kind, a2 = "PrivateIdentifier" === t2.key.type, n4 = this.tsTryParseTypeParameters();
        a2 ? (n4 && (t2.typeParameters = n4), t2.accessibility && this.raise(t2.start, b.PrivateMethodsHasAccessibility({ modifier: t2.accessibility }))) : n4 && r2 && this.raise(n4.start, b.ConstructorHasTypeParameters);
        var o2 = t2.declare, h3 = t2.kind;
        !(void 0 !== o2 && o2) || "get" !== h3 && "set" !== h3 || this.raise(t2.start, b.DeclareAccessor({ kind: h3 })), n4 && (t2.typeParameters = n4);
        var p3 = t2.key;
        "constructor" === t2.kind ? (e3 && this.raise(p3.start, "Constructor can't be a generator"), s4 && this.raise(p3.start, "Constructor can't be an async method")) : t2.static && P(t2, "prototype") && this.raise(p3.start, "Classes may not have a static property named prototype");
        var c2 = t2.value = this.parseMethod(e3, s4, i3, true, t2);
        return "get" === t2.kind && 0 !== c2.params.length && this.raiseRecoverable(c2.start, "getter should have no params"), "set" === t2.kind && 1 !== c2.params.length && this.raiseRecoverable(c2.start, "setter should have exactly one param"), "set" === t2.kind && "RestElement" === c2.params[0].type && this.raiseRecoverable(c2.params[0].start, "Setter cannot use rest params"), this.finishNode(t2, "MethodDefinition");
      }, A2.isClassMethod = function() {
        return this.match(p2.relational);
      }, A2.parseClassElement = function(e3) {
        var s4 = this;
        if (this.eat(p2.semi)) return null;
        var i3, r2 = this.options.ecmaVersion, a2 = this.startNode(), n4 = "", o2 = false, h3 = false, c2 = "method", l3 = ["declare", "private", "public", "protected", "accessor", "override", "abstract", "readonly", "static"], u3 = this.tsParseModifiers({ modified: a2, allowedModifiers: l3, disallowedModifiers: ["in", "out"], stopOnStartOfClassStaticBlock: true, errorTemplate: b.InvalidModifierOnTypeParameterPositions });
        i3 = Boolean(u3.static);
        var d3 = function() {
          if (!s4.tsIsStartOfStaticBlocks()) {
            var u4 = s4.tsTryParseIndexSignature(a2);
            if (u4) return a2.abstract && s4.raise(a2.start, b.IndexSignatureHasAbstract), a2.accessibility && s4.raise(a2.start, b.IndexSignatureHasAccessibility({ modifier: a2.accessibility })), a2.declare && s4.raise(a2.start, b.IndexSignatureHasDeclare), a2.override && s4.raise(a2.start, b.IndexSignatureHasOverride), u4;
            if (!s4.inAbstractClass && a2.abstract && s4.raise(a2.start, b.NonAbstractClassHasAbstractMethod), a2.override && e3 && s4.raise(a2.start, b.OverrideNotInSubClass), a2.static = i3, i3 && (s4.isClassElementNameStart() || s4.type === p2.star || (n4 = "static")), !n4 && r2 >= 8 && s4.eatContextual("async") && (!s4.isClassElementNameStart() && s4.type !== p2.star || s4.canInsertSemicolon() ? n4 = "async" : h3 = true), !n4 && (r2 >= 9 || !h3) && s4.eat(p2.star) && (o2 = true), !n4 && !h3 && !o2) {
              var d4 = s4.value;
              (s4.eatContextual("get") || s4.eatContextual("set")) && (s4.isClassElementNameStart() ? c2 = d4 : n4 = d4);
            }
            if (n4 ? (a2.computed = false, a2.key = s4.startNodeAt(s4.lastTokStart, s4.lastTokStartLoc), a2.key.name = n4, s4.finishNode(a2.key, "Identifier")) : s4.parseClassElementName(a2), s4.parsePostMemberNameModifiers(a2), s4.isClassMethod() || r2 < 13 || s4.type === p2.parenL || "method" !== c2 || o2 || h3) {
              var m3 = !a2.static && P(a2, "constructor"), f2 = m3 && e3;
              m3 && "method" !== c2 && s4.raise(a2.key.start, "Constructor can't have get/set modifier"), a2.kind = m3 ? "constructor" : c2, s4.parseClassMethod(a2, o2, h3, f2);
            } else s4.parseClassField(a2);
            return a2;
          }
          if (s4.next(), s4.next(), s4.tsHasSomeModifiers(a2, l3) && s4.raise(s4.start, b.StaticBlockCannotHaveModifier), r2 >= 13) return t.prototype.parseClassStaticBlock.call(s4, a2), a2;
        };
        return a2.declare ? this.tsInAmbientContext(d3) : d3(), a2;
      }, A2.isClassElementNameStart = function() {
        return !!this.tsIsIdentifier() || t.prototype.isClassElementNameStart.call(this);
      }, A2.parseClassSuper = function(e3) {
        t.prototype.parseClassSuper.call(this, e3), e3.superClass && (this.tsMatchLeftRelational() || this.match(p2.bitShift)) && (e3.superTypeParameters = this.tsParseTypeArgumentsInExpression()), this.eatContextual("implements") && (e3.implements = this.tsParseHeritageClause("implements"));
      }, A2.parseFunctionParams = function(e3) {
        var s4 = this.tsTryParseTypeParameters();
        s4 && (e3.typeParameters = s4), t.prototype.parseFunctionParams.call(this, e3);
      }, A2.parseVarId = function(e3, s4) {
        t.prototype.parseVarId.call(this, e3, s4), "Identifier" === e3.id.type && !this.hasPrecedingLineBreak() && "!" === this.value && this.eat(p2.prefix) && (e3.definite = true);
        var i3 = this.tsTryParseTypeAnnotation();
        i3 && (e3.id.typeAnnotation = i3, this.resetEndLocation(e3.id));
      }, A2.parseArrowExpression = function(t2, e3, s4, i3) {
        this.match(p2.colon) && (t2.returnType = this.tsParseTypeAnnotation());
        var r2 = this.yieldPos, a2 = this.awaitPos, n4 = this.awaitIdentPos;
        this.enterScope(16 | w(s4, false)), this.initFunction(t2);
        var o2 = this.maybeInArrowParameters;
        return this.options.ecmaVersion >= 8 && (t2.async = !!s4), this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.maybeInArrowParameters = true, t2.params = this.toAssignableList(e3, true), this.maybeInArrowParameters = false, this.parseFunctionBody(t2, true, false, i3), this.yieldPos = r2, this.awaitPos = a2, this.awaitIdentPos = n4, this.maybeInArrowParameters = o2, this.finishNode(t2, "ArrowFunctionExpression");
      }, A2.parseMaybeAssignOrigin = function(t2, e3, s4) {
        if (this.isContextual("yield")) {
          if (this.inGenerator) return this.parseYield(t2);
          this.exprAllowed = false;
        }
        var i3 = false, r2 = -1, a2 = -1, n4 = -1;
        e3 ? (r2 = e3.parenthesizedAssign, a2 = e3.trailingComma, n4 = e3.doubleProto, e3.parenthesizedAssign = e3.trailingComma = -1) : (e3 = new T(), i3 = true);
        var o2 = this.start, h3 = this.startLoc;
        (this.type === p2.parenL || q(this.type)) && (this.potentialArrowAt = this.start, this.potentialArrowInForAwait = "await" === t2);
        var c2 = this.parseMaybeConditional(t2, e3);
        if (s4 && (c2 = s4.call(this, c2, o2, h3)), this.type.isAssign) {
          var l3 = this.startNodeAt(o2, h3);
          return l3.operator = this.value, this.type === p2.eq && (c2 = this.toAssignable(c2, true, e3)), i3 || (e3.parenthesizedAssign = e3.trailingComma = e3.doubleProto = -1), e3.shorthandAssign >= c2.start && (e3.shorthandAssign = -1), this.type === p2.eq ? this.checkLValPattern(c2) : this.checkLValSimple(c2), l3.left = c2, this.next(), l3.right = this.parseMaybeAssign(t2), n4 > -1 && (e3.doubleProto = n4), this.finishNode(l3, "AssignmentExpression");
        }
        return i3 && this.checkExpressionErrors(e3, true), r2 > -1 && (e3.parenthesizedAssign = r2), a2 > -1 && (e3.trailingComma = a2), c2;
      }, A2.parseMaybeAssign = function(t2, e3, s4) {
        var i3, r2, a2, o2, h3, p3, c2, l3, u3, d3, m3, f2 = this;
        if (this.matchJsx("jsxTagStart") || this.tsMatchLeftRelational()) {
          if (l3 = this.cloneCurLookaheadState(), !(u3 = this.tryParse(function() {
            return f2.parseMaybeAssignOrigin(t2, e3, s4);
          }, l3)).error) return u3.node;
          var y3 = this.context, x2 = y3[y3.length - 1];
          x2 === n3.tokContexts.tc_oTag && y3[y3.length - 2] === n3.tokContexts.tc_expr ? (y3.pop(), y3.pop()) : x2 !== n3.tokContexts.tc_oTag && x2 !== n3.tokContexts.tc_expr || y3.pop();
        }
        if (!(null != (i3 = u3) && i3.error || this.tsMatchLeftRelational())) return this.parseMaybeAssignOrigin(t2, e3, s4);
        l3 && !this.compareLookaheadState(l3, this.getCurLookaheadState()) || (l3 = this.cloneCurLookaheadState());
        var T2 = this.tryParse(function(i4) {
          var r3, a3;
          m3 = f2.tsParseTypeParameters();
          var n4 = f2.parseMaybeAssignOrigin(t2, e3, s4);
          return ("ArrowFunctionExpression" !== n4.type || null != (r3 = n4.extra) && r3.parenthesized) && i4(), 0 !== (null == (a3 = m3) ? void 0 : a3.params.length) && f2.resetStartLocationFromNode(n4, m3), n4.typeParameters = m3, n4;
        }, l3);
        if (!T2.error && !T2.aborted) return m3 && this.reportReservedArrowTypeParam(m3), T2.node;
        if (!u3 && (k(true), !(d3 = this.tryParse(function() {
          return f2.parseMaybeAssignOrigin(t2, e3, s4);
        }, l3)).error)) return d3.node;
        if (null != (r2 = u3) && r2.node) return this.setLookaheadState(u3.failState), u3.node;
        if (T2.node) return this.setLookaheadState(T2.failState), m3 && this.reportReservedArrowTypeParam(m3), T2.node;
        if (null != (a2 = d3) && a2.node) return this.setLookaheadState(d3.failState), d3.node;
        if (null != (o2 = u3) && o2.thrown) throw u3.error;
        if (T2.thrown) throw T2.error;
        if (null != (h3 = d3) && h3.thrown) throw d3.error;
        throw (null == (p3 = u3) ? void 0 : p3.error) || T2.error || (null == (c2 = d3) ? void 0 : c2.error);
      }, A2.parseAssignableListItem = function(t2) {
        for (var e3 = []; this.match(_.at); ) e3.push(this.parseDecorator());
        var s4, i3 = this.start, r2 = this.startLoc, a2 = false, n4 = false;
        if (void 0 !== t2) {
          var o2 = {};
          this.tsParseModifiers({ modified: o2, allowedModifiers: ["public", "private", "protected", "override", "readonly"] }), s4 = o2.accessibility, n4 = o2.override, a2 = o2.readonly, false === t2 && (s4 || a2 || n4) && this.raise(r2.start, b.UnexpectedParameterModifier);
        }
        var h3 = this.parseMaybeDefault(i3, r2);
        this.parseBindingListItem(h3);
        var p3 = this.parseMaybeDefault(h3.start, h3.loc, h3);
        if (e3.length && (p3.decorators = e3), s4 || a2 || n4) {
          var c2 = this.startNodeAt(i3, r2);
          return s4 && (c2.accessibility = s4), a2 && (c2.readonly = a2), n4 && (c2.override = n4), "Identifier" !== p3.type && "AssignmentPattern" !== p3.type && this.raise(c2.start, b.UnsupportedParameterPropertyKind), c2.parameter = p3, this.finishNode(c2, "TSParameterProperty");
        }
        return p3;
      }, A2.checkLValInnerPattern = function(e3, s4, i3) {
        void 0 === s4 && (s4 = 0), "TSParameterProperty" === e3.type ? this.checkLValInnerPattern(e3.parameter, s4, i3) : t.prototype.checkLValInnerPattern.call(this, e3, s4, i3);
      }, A2.parseBindingListItem = function(t2) {
        this.eat(p2.question) && ("Identifier" === t2.type || this.isAmbientContext || this.inType || this.raise(t2.start, b.PatternIsOptional), t2.optional = true);
        var e3 = this.tsTryParseTypeAnnotation();
        return e3 && (t2.typeAnnotation = e3), this.resetEndLocation(t2), t2;
      }, A2.isAssignable = function(t2, e3) {
        var s4 = this;
        switch (t2.type) {
          case "TSTypeCastExpression":
            return this.isAssignable(t2.expression, e3);
          case "TSParameterProperty":
          case "Identifier":
          case "ObjectPattern":
          case "ArrayPattern":
          case "AssignmentPattern":
          case "RestElement":
            return true;
          case "ObjectExpression":
            var i3 = t2.properties.length - 1;
            return t2.properties.every(function(t3, e4) {
              return "ObjectMethod" !== t3.type && (e4 === i3 || "SpreadElement" !== t3.type) && s4.isAssignable(t3);
            });
          case "Property":
          case "ObjectProperty":
            return this.isAssignable(t2.value);
          case "SpreadElement":
            return this.isAssignable(t2.argument);
          case "ArrayExpression":
            return t2.elements.every(function(t3) {
              return null === t3 || s4.isAssignable(t3);
            });
          case "AssignmentExpression":
            return "=" === t2.operator;
          case "ParenthesizedExpression":
            return this.isAssignable(t2.expression);
          case "MemberExpression":
          case "OptionalMemberExpression":
            return !e3;
          default:
            return false;
        }
      }, A2.toAssignable = function(e3, s4, i3) {
        switch (void 0 === s4 && (s4 = false), void 0 === i3 && (i3 = new T()), e3.type) {
          case "ParenthesizedExpression":
            return this.toAssignableParenthesizedExpression(e3, s4, i3);
          case "TSAsExpression":
          case "TSSatisfiesExpression":
          case "TSNonNullExpression":
          case "TSTypeAssertion":
            return s4 || this.raise(e3.start, b.UnexpectedTypeCastInParameter), this.toAssignable(e3.expression, s4, i3);
          case "MemberExpression":
            break;
          case "AssignmentExpression":
            return s4 || "TSTypeCastExpression" !== e3.left.type || (e3.left = this.typeCastToParameter(e3.left)), t.prototype.toAssignable.call(this, e3, s4, i3);
          case "TSTypeCastExpression":
            return this.typeCastToParameter(e3);
          default:
            return t.prototype.toAssignable.call(this, e3, s4, i3);
        }
        return e3;
      }, A2.toAssignableParenthesizedExpression = function(e3, s4, i3) {
        switch (e3.expression.type) {
          case "TSAsExpression":
          case "TSSatisfiesExpression":
          case "TSNonNullExpression":
          case "TSTypeAssertion":
          case "ParenthesizedExpression":
            return this.toAssignable(e3.expression, s4, i3);
          default:
            return t.prototype.toAssignable.call(this, e3, s4, i3);
        }
      }, A2.curPosition = function() {
        if (this.options.locations) {
          var e3 = t.prototype.curPosition.call(this);
          return Object.defineProperty(e3, "offset", { get: function() {
            return function(t2) {
              var e4 = new i2.Position(this.line, this.column + t2);
              return e4.index = this.index + t2, e4;
            };
          } }), e3.index = this.pos, e3;
        }
      }, A2.parseBindingAtom = function() {
        return this.type === p2._this ? this.parseIdent(true) : t.prototype.parseBindingAtom.call(this);
      }, A2.shouldParseArrow = function(t2) {
        var e3, s4 = this;
        if (e3 = this.match(p2.colon) ? t2.every(function(t3) {
          return s4.isAssignable(t3, true);
        }) : !this.canInsertSemicolon()) {
          if (this.match(p2.colon)) {
            var i3 = this.tryParse(function(t3) {
              var e4 = s4.tsParseTypeOrTypePredicateAnnotation(p2.colon);
              return !s4.canInsertSemicolon() && s4.match(p2.arrow) || t3(), e4;
            });
            if (i3.aborted) return this.shouldParseArrowReturnType = void 0, false;
            i3.thrown || (i3.error && this.setLookaheadState(i3.failState), this.shouldParseArrowReturnType = i3.node);
          }
          return !!this.match(p2.arrow) || (this.shouldParseArrowReturnType = void 0, false);
        }
        return this.shouldParseArrowReturnType = void 0, e3;
      }, A2.parseParenArrowList = function(t2, e3, s4, i3) {
        var r2 = this.startNodeAt(t2, e3);
        return r2.returnType = this.shouldParseArrowReturnType, this.shouldParseArrowReturnType = void 0, this.parseArrowExpression(r2, s4, false, i3);
      }, A2.parseParenAndDistinguishExpression = function(t2, e3) {
        var s4, i3 = this.start, r2 = this.startLoc, a2 = this.options.ecmaVersion >= 8;
        if (this.options.ecmaVersion >= 6) {
          var n4 = this.maybeInArrowParameters;
          this.maybeInArrowParameters = true, this.next();
          var o2, h3 = this.start, c2 = this.startLoc, l3 = [], u3 = true, d3 = false, m3 = new T(), f2 = this.yieldPos, y3 = this.awaitPos;
          for (this.yieldPos = 0, this.awaitPos = 0; this.type !== p2.parenR; ) {
            if (u3 ? u3 = false : this.expect(p2.comma), a2 && this.afterTrailingComma(p2.parenR, true)) {
              d3 = true;
              break;
            }
            if (this.type === p2.ellipsis) {
              o2 = this.start, l3.push(this.parseParenItem(this.parseRestBinding())), this.type === p2.comma && this.raise(this.start, "Comma is not permitted after the rest element");
              break;
            }
            l3.push(this.parseMaybeAssign(e3, m3, this.parseParenItem));
          }
          var x2 = this.lastTokEnd, v2 = this.lastTokEndLoc;
          if (this.expect(p2.parenR), this.maybeInArrowParameters = n4, t2 && this.shouldParseArrow(l3) && this.eat(p2.arrow)) return this.checkPatternErrors(m3, false), this.checkYieldAwaitInDefaultParams(), this.yieldPos = f2, this.awaitPos = y3, this.parseParenArrowList(i3, r2, l3, e3);
          l3.length && !d3 || this.unexpected(this.lastTokStart), o2 && this.unexpected(o2), this.checkExpressionErrors(m3, true), this.yieldPos = f2 || this.yieldPos, this.awaitPos = y3 || this.awaitPos, l3.length > 1 ? ((s4 = this.startNodeAt(h3, c2)).expressions = l3, this.finishNodeAt(s4, "SequenceExpression", x2, v2)) : s4 = l3[0];
        } else s4 = this.parseParenExpression();
        if (this.options.preserveParens) {
          var P2 = this.startNodeAt(i3, r2);
          return P2.expression = s4, this.finishNode(P2, "ParenthesizedExpression");
        }
        return s4;
      }, A2.parseTaggedTemplateExpression = function(t2, e3, s4, i3) {
        var r2 = this.startNodeAt(e3, s4);
        return r2.tag = t2, r2.quasi = this.parseTemplate({ isTagged: true }), i3 && this.raise(e3, "Tagged Template Literals are not allowed in optionalChain."), this.finishNode(r2, "TaggedTemplateExpression");
      }, A2.shouldParseAsyncArrow = function() {
        var t2 = this;
        if (!this.match(p2.colon)) return !this.canInsertSemicolon() && this.eat(p2.arrow);
        var e3 = this.tryParse(function(e4) {
          var s4 = t2.tsParseTypeOrTypePredicateAnnotation(p2.colon);
          return !t2.canInsertSemicolon() && t2.match(p2.arrow) || e4(), s4;
        });
        return e3.aborted ? (this.shouldParseAsyncArrowReturnType = void 0, false) : e3.thrown ? void 0 : (e3.error && this.setLookaheadState(e3.failState), this.shouldParseAsyncArrowReturnType = e3.node, !this.canInsertSemicolon() && this.eat(p2.arrow));
      }, A2.parseSubscriptAsyncArrow = function(t2, e3, s4, i3) {
        var r2 = this.startNodeAt(t2, e3);
        return r2.returnType = this.shouldParseAsyncArrowReturnType, this.shouldParseAsyncArrowReturnType = void 0, this.parseArrowExpression(r2, s4, true, i3);
      }, A2.parseExprList = function(t2, e3, s4, i3) {
        for (var r2 = [], a2 = true; !this.eat(t2); ) {
          if (a2) a2 = false;
          else if (this.expect(p2.comma), e3 && this.afterTrailingComma(t2)) break;
          var n4 = void 0;
          s4 && this.type === p2.comma ? n4 = null : this.type === p2.ellipsis ? (n4 = this.parseSpread(i3), i3 && this.type === p2.comma && i3.trailingComma < 0 && (i3.trailingComma = this.start)) : n4 = this.parseMaybeAssign(false, i3, this.parseParenItem), r2.push(n4);
        }
        return r2;
      }, A2.parseSubscript = function(t2, e3, s4, i3, r2, a2, n4) {
        var o2 = this, h3 = a2;
        if (!this.hasPrecedingLineBreak() && "!" === this.value && this.match(p2.prefix)) {
          this.exprAllowed = false, this.next();
          var c2 = this.startNodeAt(e3, s4);
          return c2.expression = t2, t2 = this.finishNode(c2, "TSNonNullExpression");
        }
        var l3 = false;
        if (this.match(p2.questionDot) && 60 === this.lookaheadCharCode()) {
          if (i3) return t2;
          t2.optional = true, h3 = l3 = true, this.next();
        }
        if (this.tsMatchLeftRelational() || this.match(p2.bitShift)) {
          var u3, d3 = this.tsTryParseAndCatch(function() {
            if (!i3 && o2.atPossibleAsyncArrow(t2)) {
              var r3 = o2.tsTryParseGenericAsyncArrowFunction(e3, s4, n4);
              if (r3) return t2 = r3;
            }
            var a3 = o2.tsParseTypeArgumentsInExpression();
            if (!a3) return t2;
            if (l3 && !o2.match(p2.parenL)) return u3 = o2.curPosition(), t2;
            if (B(o2.type) || o2.type === p2.backQuote) {
              var c3 = o2.parseTaggedTemplateExpression(t2, e3, s4, h3);
              return c3.typeParameters = a3, c3;
            }
            if (!i3 && o2.eat(p2.parenL)) {
              var d4 = new T(), m4 = o2.startNodeAt(e3, s4);
              return m4.callee = t2, m4.arguments = o2.parseExprList(p2.parenR, o2.options.ecmaVersion >= 8, false, d4), o2.tsCheckForInvalidTypeCasts(m4.arguments), m4.typeParameters = a3, h3 && (m4.optional = l3), o2.checkExpressionErrors(d4, true), t2 = o2.finishNode(m4, "CallExpression");
            }
            var f3 = o2.type;
            if (!(o2.tsMatchRightRelational() || f3 === p2.bitShift || f3 !== p2.parenL && (y4 = f3, Boolean(y4.startsExpr)) && !o2.hasPrecedingLineBreak())) {
              var y4, x3 = o2.startNodeAt(e3, s4);
              return x3.expression = t2, x3.typeParameters = a3, o2.finishNode(x3, "TSInstantiationExpression");
            }
          });
          if (u3 && this.unexpected(u3), d3) return "TSInstantiationExpression" === d3.type && (this.match(p2.dot) || this.match(p2.questionDot) && 40 !== this.lookaheadCharCode()) && this.raise(this.start, b.InvalidPropertyAccessAfterInstantiationExpression), t2 = d3;
        }
        var m3 = this.options.ecmaVersion >= 11, f2 = m3 && this.eat(p2.questionDot);
        i3 && f2 && this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
        var y3 = this.eat(p2.bracketL);
        if (y3 || f2 && this.type !== p2.parenL && this.type !== p2.backQuote || this.eat(p2.dot)) {
          var x2 = this.startNodeAt(e3, s4);
          x2.object = t2, y3 ? (x2.property = this.parseExpression(), this.expect(p2.bracketR)) : x2.property = this.type === p2.privateId && "Super" !== t2.type ? this.parsePrivateIdent() : this.parseIdent("never" !== this.options.allowReserved), x2.computed = !!y3, m3 && (x2.optional = f2), t2 = this.finishNode(x2, "MemberExpression");
        } else if (!i3 && this.eat(p2.parenL)) {
          var v2 = this.maybeInArrowParameters;
          this.maybeInArrowParameters = true;
          var P2 = new T(), g3 = this.yieldPos, A3 = this.awaitPos, S2 = this.awaitIdentPos;
          this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0;
          var C2 = this.parseExprList(p2.parenR, this.options.ecmaVersion >= 8, false, P2);
          if (r2 && !f2 && this.shouldParseAsyncArrow()) this.checkPatternErrors(P2, false), this.checkYieldAwaitInDefaultParams(), this.awaitIdentPos > 0 && this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function"), this.yieldPos = g3, this.awaitPos = A3, this.awaitIdentPos = S2, t2 = this.parseSubscriptAsyncArrow(e3, s4, C2, n4);
          else {
            this.checkExpressionErrors(P2, true), this.yieldPos = g3 || this.yieldPos, this.awaitPos = A3 || this.awaitPos, this.awaitIdentPos = S2 || this.awaitIdentPos;
            var E2 = this.startNodeAt(e3, s4);
            E2.callee = t2, E2.arguments = C2, m3 && (E2.optional = f2), t2 = this.finishNode(E2, "CallExpression");
          }
          this.maybeInArrowParameters = v2;
        } else if (this.type === p2.backQuote) {
          (f2 || h3) && this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
          var k2 = this.startNodeAt(e3, s4);
          k2.tag = t2, k2.quasi = this.parseTemplate({ isTagged: true }), t2 = this.finishNode(k2, "TaggedTemplateExpression");
        }
        return t2;
      }, A2.parseGetterSetter = function(t2) {
        t2.kind = t2.key.name, this.parsePropertyName(t2), t2.value = this.parseMethod(false);
        var e3 = "get" === t2.kind ? 0 : 1, s4 = t2.value.params[0], i3 = s4 && this.isThisParam(s4);
        t2.value.params.length !== (e3 = i3 ? e3 + 1 : e3) ? this.raiseRecoverable(t2.value.start, "get" === t2.kind ? "getter should have no params" : "setter should have exactly one param") : "set" === t2.kind && "RestElement" === t2.value.params[0].type && this.raiseRecoverable(t2.value.params[0].start, "Setter cannot use rest params");
      }, A2.parseProperty = function(e3, s4) {
        if (!e3) {
          var i3 = [];
          if (this.match(_.at)) for (; this.match(_.at); ) i3.push(this.parseDecorator());
          var r2 = t.prototype.parseProperty.call(this, e3, s4);
          return "SpreadElement" === r2.type && i3.length && this.raise(r2.start, "Decorators can't be used with SpreadElement"), i3.length && (r2.decorators = i3, i3 = []), r2;
        }
        return t.prototype.parseProperty.call(this, e3, s4);
      }, A2.parseCatchClauseParam = function() {
        var t2 = this.parseBindingAtom(), e3 = "Identifier" === t2.type;
        this.enterScope(e3 ? 32 : 0), this.checkLValPattern(t2, e3 ? 4 : 2);
        var s4 = this.tsTryParseTypeAnnotation();
        return s4 && (t2.typeAnnotation = s4, this.resetEndLocation(t2)), this.expect(p2.parenR), t2;
      }, A2.parseClass = function(t2, e3) {
        var s4 = this.inAbstractClass;
        this.inAbstractClass = !!t2.abstract;
        try {
          this.next(), this.takeDecorators(t2);
          var i3 = this.strict;
          this.strict = true, this.parseClassId(t2, e3), this.parseClassSuper(t2);
          var r2 = this.enterClassBody(), a2 = this.startNode(), n4 = false;
          a2.body = [];
          var o2 = [];
          for (this.expect(p2.braceL); this.type !== p2.braceR; ) if (this.match(_.at)) o2.push(this.parseDecorator());
          else {
            var h3 = this.parseClassElement(null !== t2.superClass);
            o2.length && (h3.decorators = o2, this.resetStartLocationFromNode(h3, o2[0]), o2 = []), h3 && (a2.body.push(h3), "MethodDefinition" === h3.type && "constructor" === h3.kind && "FunctionExpression" === h3.value.type ? (n4 && this.raiseRecoverable(h3.start, "Duplicate constructor in the same class"), n4 = true, h3.decorators && h3.decorators.length > 0 && this.raise(h3.start, "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?")) : h3.key && "PrivateIdentifier" === h3.key.type && v(r2, h3) && this.raiseRecoverable(h3.key.start, "Identifier '#" + h3.key.name + "' has already been declared"));
          }
          return this.strict = i3, this.next(), o2.length && this.raise(this.start, "Decorators must be attached to a class element."), t2.body = this.finishNode(a2, "ClassBody"), this.exitClassBody(), this.finishNode(t2, e3 ? "ClassDeclaration" : "ClassExpression");
        } finally {
          this.inAbstractClass = s4;
        }
      }, A2.parseClassFunctionParams = function() {
        var t2 = this.tsTryParseTypeParameters(this.tsParseConstModifier), e3 = this.parseBindingList(p2.parenR, false, this.options.ecmaVersion >= 8, true);
        return t2 && (e3.typeParameters = t2), e3;
      }, A2.parseMethod = function(t2, e3, s4, i3, r2) {
        var a2 = this.startNode(), n4 = this.yieldPos, o2 = this.awaitPos, h3 = this.awaitIdentPos;
        if (this.initFunction(a2), this.options.ecmaVersion >= 6 && (a2.generator = t2), this.options.ecmaVersion >= 8 && (a2.async = !!e3), this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(64 | w(e3, a2.generator) | (s4 ? 128 : 0)), this.expect(p2.parenL), a2.params = this.parseClassFunctionParams(), this.checkYieldAwaitInDefaultParams(), this.parseFunctionBody(a2, false, true, false, { isClassMethod: i3 }), this.yieldPos = n4, this.awaitPos = o2, this.awaitIdentPos = h3, r2 && r2.abstract && a2.body) {
          var c2 = r2.key;
          this.raise(r2.start, b.AbstractMethodHasImplementation({ methodName: "Identifier" !== c2.type || r2.computed ? "[" + this.input.slice(c2.start, c2.end) + "]" : c2.name }));
        }
        return this.finishNode(a2, "FunctionExpression");
      }, e2.parse = function(t2, e3) {
        if (false === e3.locations) throw new Error("You have to enable options.locations while using acorn-typescript");
        e3.locations = true;
        var s4 = new this(e3, t2);
        return r && (s4.isAmbientContext = true), s4.parse();
      }, e2.parseExpressionAt = function(t2, e3, s4) {
        if (false === s4.locations) throw new Error("You have to enable options.locations while using acorn-typescript");
        s4.locations = true;
        var i3 = new this(s4, t2, e3);
        return r && (i3.isAmbientContext = true), i3.nextToken(), i3.parseExpression();
      }, A2.parseImportSpecifier = function() {
        if (this.ts_isContextual(_.type)) {
          var e3 = this.startNode();
          return e3.imported = this.parseModuleExportName(), this.parseTypeOnlyImportExportSpecifier(e3, true, "type" === this.importOrExportOuterKind), this.finishNode(e3, "ImportSpecifier");
        }
        var s4 = t.prototype.parseImportSpecifier.call(this);
        return s4.importKind = "value", s4;
      }, A2.parseExportSpecifier = function(e3) {
        var s4 = this.ts_isContextual(_.type);
        if (!this.match(p2.string) && s4) {
          var i3 = this.startNode();
          return i3.local = this.parseModuleExportName(), this.parseTypeOnlyImportExportSpecifier(i3, false, "type" === this.importOrExportOuterKind), this.finishNode(i3, "ExportSpecifier"), this.checkExport(e3, i3.exported, i3.exported.start), i3;
        }
        var r2 = t.prototype.parseExportSpecifier.call(this, e3);
        return r2.exportKind = "value", r2;
      }, A2.parseTypeOnlyImportExportSpecifier = function(e3, s4, i3) {
        var r2, a2 = s4 ? "imported" : "local", n4 = s4 ? "local" : "exported", o2 = e3[a2], h3 = false, p3 = true, c2 = o2.start;
        if (this.isContextual("as")) {
          var l3 = this.parseIdent();
          if (this.isContextual("as")) {
            var u3 = this.parseIdent();
            U(this.type) ? (h3 = true, o2 = l3, r2 = s4 ? this.parseIdent() : this.parseModuleExportName(), p3 = false) : (r2 = u3, p3 = false);
          } else U(this.type) ? (p3 = false, r2 = s4 ? this.parseIdent() : this.parseModuleExportName()) : (h3 = true, o2 = l3);
        } else U(this.type) && (h3 = true, s4 ? (o2 = t.prototype.parseIdent.call(this, true), this.isContextual("as") || this.checkUnreserved(o2)) : o2 = this.parseModuleExportName());
        h3 && i3 && this.raise(c2, s4 ? b.TypeModifierIsUsedInTypeImports : b.TypeModifierIsUsedInTypeExports), e3[a2] = o2, e3[n4] = r2, e3[s4 ? "importKind" : "exportKind"] = h3 ? "type" : "value", p3 && this.eatContextual("as") && (e3[n4] = s4 ? this.parseIdent() : this.parseModuleExportName()), e3[n4] || (e3[n4] = this.copyNode(e3[a2])), s4 && this.checkLValSimple(e3[n4], 2);
      }, A2.raiseCommonCheck = function(e3, s4, i3) {
        return "Comma is not permitted after the rest element" === s4 ? this.isAmbientContext && this.match(p2.comma) && 41 === this.lookaheadCharCode() ? void this.next() : t.prototype.raise.call(this, e3, s4) : i3 ? t.prototype.raiseRecoverable.call(this, e3, s4) : t.prototype.raise.call(this, e3, s4);
      }, A2.raiseRecoverable = function(t2, e3) {
        return this.raiseCommonCheck(t2, e3, true);
      }, A2.raise = function(t2, e3) {
        return this.raiseCommonCheck(t2, e3, true);
      }, A2.updateContext = function(e3) {
        var s4 = this.type;
        if (s4 == p2.braceL) {
          var i3 = this.curContext();
          i3 == R.tc_oTag ? this.context.push(M2.b_expr) : i3 == R.tc_expr ? this.context.push(M2.b_tmpl) : t.prototype.updateContext.call(this, e3), this.exprAllowed = true;
        } else {
          if (s4 !== p2.slash || e3 !== _.jsxTagStart) return t.prototype.updateContext.call(this, e3);
          this.context.length -= 2, this.context.push(R.tc_cTag), this.exprAllowed = false;
        }
      }, A2.jsx_parseOpeningElementAt = function(t2, e3) {
        var s4 = this, i3 = this.startNodeAt(t2, e3), r2 = this.jsx_parseElementName();
        if (r2 && (i3.name = r2), this.match(p2.relational) || this.match(p2.bitShift)) {
          var a2 = this.tsTryParseAndCatch(function() {
            return s4.tsParseTypeArgumentsInExpression();
          });
          a2 && (i3.typeParameters = a2);
        }
        for (i3.attributes = []; this.type !== p2.slash && this.type !== _.jsxTagEnd; ) i3.attributes.push(this.jsx_parseAttribute());
        return i3.selfClosing = this.eat(p2.slash), this.expect(_.jsxTagEnd), this.finishNode(i3, r2 ? "JSXOpeningElement" : "JSXOpeningFragment");
      }, A2.enterScope = function(e3) {
        e3 === f && this.importsStack.push([]), t.prototype.enterScope.call(this, e3);
        var s4 = t.prototype.currentScope.call(this);
        s4.types = [], s4.enums = [], s4.constEnums = [], s4.classes = [], s4.exportOnlyBindings = [];
      }, A2.exitScope = function() {
        t.prototype.currentScope.call(this).flags === f && this.importsStack.pop(), t.prototype.exitScope.call(this);
      }, A2.hasImport = function(t2, e3) {
        var s4 = this.importsStack.length;
        if (this.importsStack[s4 - 1].indexOf(t2) > -1) return true;
        if (!e3 && s4 > 1) {
          for (var i3 = 0; i3 < s4 - 1; i3++) if (this.importsStack[i3].indexOf(t2) > -1) return true;
        }
        return false;
      }, A2.maybeExportDefined = function(t2, e3) {
        this.inModule && 1 & t2.flags && this.undefinedExports.delete(e3);
      }, A2.isRedeclaredInScope = function(e3, s4, i3) {
        return !!(0 & i3) && (2 & i3 ? e3.lexical.indexOf(s4) > -1 || e3.functions.indexOf(s4) > -1 || e3.var.indexOf(s4) > -1 : 3 & i3 ? e3.lexical.indexOf(s4) > -1 || !t.prototype.treatFunctionsAsVarInScope.call(this, e3) && e3.var.indexOf(s4) > -1 : e3.lexical.indexOf(s4) > -1 && !(32 & e3.flags && e3.lexical[0] === s4) || !this.treatFunctionsAsVarInScope(e3) && e3.functions.indexOf(s4) > -1);
      }, A2.checkRedeclarationInScope = function(t2, e3, s4, i3) {
        this.isRedeclaredInScope(t2, e3, s4) && this.raise(i3, "Identifier '" + e3 + "' has already been declared.");
      }, A2.declareName = function(e3, s4, i3) {
        if (4096 & s4) return this.hasImport(e3, true) && this.raise(i3, "Identifier '" + e3 + "' has already been declared."), void this.importsStack[this.importsStack.length - 1].push(e3);
        var r2 = this.currentScope();
        if (1024 & s4) return this.maybeExportDefined(r2, e3), void r2.exportOnlyBindings.push(e3);
        t.prototype.declareName.call(this, e3, s4, i3), 0 & s4 && (0 & s4 || (this.checkRedeclarationInScope(r2, e3, s4, i3), this.maybeExportDefined(r2, e3)), r2.types.push(e3)), 256 & s4 && r2.enums.push(e3), 512 & s4 && r2.constEnums.push(e3), 128 & s4 && r2.classes.push(e3);
      }, A2.checkLocalExport = function(e3) {
        var s4 = e3.name;
        if (!this.hasImport(s4)) {
          for (var i3 = this.scopeStack.length - 1; i3 >= 0; i3--) {
            var r2 = this.scopeStack[i3];
            if (r2.types.indexOf(s4) > -1 || r2.exportOnlyBindings.indexOf(s4) > -1) return;
          }
          t.prototype.checkLocalExport.call(this, e3);
        }
      }, s3 = e2, g2 = [{ key: "acornTypeScript", get: function() {
        return n3;
      } }], (m2 = [{ key: "acornTypeScript", get: function() {
        return n3;
      } }]) && a(s3.prototype, m2), g2 && a(s3, g2), Object.defineProperty(s3, "prototype", { writable: false }), e2;
    }(s2);
    return z;
  };
}

export {
  D
};
//# sourceMappingURL=chunk-MCF5IZSX.js.map
