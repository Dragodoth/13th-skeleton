import {
  require_lib
} from "./chunk-RTQQBXLT.js";
import {
  require_lib as require_lib2
} from "./chunk-5IIC2QU3.js";
import {
  hash,
  is_boolean_attribute,
  is_capture_event,
  is_content_editable_binding,
  is_delegated,
  is_dom_property,
  is_load_error_element,
  is_mathml,
  is_passive_event,
  is_reserved,
  is_rune,
  is_svg,
  is_void,
  normalize_attribute
} from "./chunk-DPXC2WL3.js";
import {
  EACH_INDEX_REACTIVE,
  EACH_IS_ANIMATED,
  EACH_IS_CONTROLLED,
  EACH_ITEM_IMMUTABLE,
  EACH_ITEM_REACTIVE,
  ELEMENT_IS_NAMESPACED,
  ELEMENT_PRESERVE_ATTRIBUTE_CASE,
  HYDRATION_END,
  HYDRATION_START,
  HYDRATION_START_ELSE,
  IGNORABLE_RUNTIME_WARNINGS,
  NAMESPACE_MATHML,
  NAMESPACE_SVG,
  PROPS_IS_BINDABLE,
  PROPS_IS_IMMUTABLE,
  PROPS_IS_LAZY_INITIAL,
  PROPS_IS_RUNES,
  PROPS_IS_UPDATED,
  TEMPLATE_FRAGMENT,
  TEMPLATE_USE_IMPORT_NODE,
  TRANSITION_GLOBAL,
  TRANSITION_IN,
  TRANSITION_OUT
} from "./chunk-QVLHSJ7S.js";
import {
  VERSION
} from "./chunk-AJJAVYTT.js";
import {
  walk
} from "./chunk-CXPE5DNB.js";
import {
  D
} from "./chunk-MCF5IZSX.js";
import {
  Parser,
  isIdentifierChar,
  isIdentifierStart
} from "./chunk-L424AFVK.js";
import {
  is_reference
} from "./chunk-IYSNZR4A.js";
import {
  print
} from "./chunk-FKDVJUZP.js";
import {
  getLocator
} from "./chunk-3DD2DS5V.js";
import {
  MagicString
} from "./chunk-7MZNUKTV.js";
import {
  require_remapping_umd
} from "./chunk-RQO3LMD2.js";
import {
  require_sourcemap_codec_umd
} from "./chunk-H7TQ7GYX.js";
import {
  __commonJS,
  __privateAdd,
  __privateGet,
  __privateSet,
  __publicField,
  __toESM
} from "./chunk-B4Q33VKO.js";

// browser-external:node:process
var require_node_process = __commonJS({
  "browser-external:node:process"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key2) {
        if (key2 !== "__esModule" && key2 !== "__proto__" && key2 !== "constructor" && key2 !== "splice") {
          console.warn(`Module "node:process" has been externalized for browser compatibility. Cannot access "node:process.${key2}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/svelte/src/compiler/phases/patterns.js
var regex_whitespace = /\s/;
var regex_whitespaces = /\s+/;
var regex_starts_with_newline = /^\r?\n/;
var regex_starts_with_whitespace = /^\s/;
var regex_starts_with_whitespaces = /^[ \t\r\n]+/;
var regex_ends_with_whitespace = /\s$/;
var regex_ends_with_whitespaces = /[ \t\r\n]+$/;
var regex_not_whitespace = /[^ \t\r\n]/;
var regex_whitespaces_strict = /[ \t\n\r\f]+/g;
var regex_only_whitespaces = /^[ \t\n\r\f]+$/;
var regex_not_newline_characters = /[^\n]/g;
var regex_is_valid_identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;
var regex_invalid_identifier_chars = /(^[^a-zA-Z_$]|[^a-zA-Z0-9_$])/g;
var regex_starts_with_vowel = /^[aeiou]/;
var regex_heading_tags = /^h[1-6]$/;
var regex_illegal_attribute_character = /(^[0-9-.])|[\^$@%&#?!|()[\]{}^*+~;]/;

// node_modules/svelte/src/compiler/phases/1-parse/utils/fuzzymatch.js
function fuzzymatch(name, names) {
  if (names.length === 0) return null;
  const set2 = new FuzzySet(names);
  const matches = set2.get(name);
  return matches && matches[0][0] > 0.7 ? matches[0][1] : null;
}
var GRAM_SIZE_LOWER = 2;
var GRAM_SIZE_UPPER = 3;
function _distance(str1, str2) {
  if (str1 === null && str2 === null) {
    throw "Trying to compare two null values";
  }
  if (str1 === null || str2 === null) return 0;
  str1 = String(str1);
  str2 = String(str2);
  const distance = levenshtein(str1, str2);
  return 1 - distance / Math.max(str1.length, str2.length);
}
function levenshtein(str1, str2) {
  const current = [];
  let prev = 0;
  let value = 0;
  for (let i = 0; i <= str2.length; i++) {
    for (let j = 0; j <= str1.length; j++) {
      if (i && j) {
        if (str1.charAt(j - 1) === str2.charAt(i - 1)) {
          value = prev;
        } else {
          value = Math.min(current[j], current[j - 1], prev) + 1;
        }
      } else {
        value = i + j;
      }
      prev = current[j];
      current[j] = value;
    }
  }
  return (
    /** @type {number} */
    current.pop()
  );
}
var non_word_regex = /[^\w, ]+/;
function iterate_grams(value, gram_size = 2) {
  const simplified = "-" + value.toLowerCase().replace(non_word_regex, "") + "-";
  const len_diff = gram_size - simplified.length;
  const results = [];
  if (len_diff > 0) {
    for (let i = 0; i < len_diff; ++i) {
      value += "-";
    }
  }
  for (let i = 0; i < simplified.length - gram_size + 1; ++i) {
    results.push(simplified.slice(i, i + gram_size));
  }
  return results;
}
function gram_counter(value, gram_size = 2) {
  const result = {};
  const grams = iterate_grams(value, gram_size);
  let i = 0;
  for (i; i < grams.length; ++i) {
    if (grams[i] in result) {
      result[grams[i]] += 1;
    } else {
      result[grams[i]] = 1;
    }
  }
  return result;
}
function sort_descending(a, b) {
  return b[0] - a[0];
}
var FuzzySet = class {
  /** @param {string[]} arr */
  constructor(arr) {
    /** @type {Record<string, string>} */
    __publicField(this, "exact_set", {});
    /** @type {Record<string, [number, number][]>} */
    __publicField(this, "match_dict", {});
    /** @type {Record<string, number[]>} */
    __publicField(this, "items", {});
    for (let i = GRAM_SIZE_LOWER; i < GRAM_SIZE_UPPER + 1; ++i) {
      this.items[i] = [];
    }
    for (let i = 0; i < arr.length; ++i) {
      this.add(arr[i]);
    }
  }
  /** @param {string} value */
  add(value) {
    const normalized_value = value.toLowerCase();
    if (normalized_value in this.exact_set) {
      return false;
    }
    let i = GRAM_SIZE_LOWER;
    for (i; i < GRAM_SIZE_UPPER + 1; ++i) {
      this._add(value, i);
    }
  }
  /**
   * @param {string} value
   * @param {number} gram_size
   */
  _add(value, gram_size) {
    const normalized_value = value.toLowerCase();
    const items = this.items[gram_size] || [];
    const index = items.length;
    items.push(0);
    const gram_counts = gram_counter(normalized_value, gram_size);
    let sum_of_square_gram_counts = 0;
    let gram;
    let gram_count;
    for (gram in gram_counts) {
      gram_count = gram_counts[gram];
      sum_of_square_gram_counts += Math.pow(gram_count, 2);
      if (gram in this.match_dict) {
        this.match_dict[gram].push([index, gram_count]);
      } else {
        this.match_dict[gram] = [[index, gram_count]];
      }
    }
    const vector_normal = Math.sqrt(sum_of_square_gram_counts);
    items[index] = [vector_normal, normalized_value];
    this.items[gram_size] = items;
    this.exact_set[normalized_value] = value;
  }
  /** @param {string} value */
  get(value) {
    const normalized_value = value.toLowerCase();
    const result = this.exact_set[normalized_value];
    if (result) {
      return (
        /** @type {MatchTuple[]} */
        [[1, result]]
      );
    }
    for (let gram_size = GRAM_SIZE_UPPER; gram_size >= GRAM_SIZE_LOWER; --gram_size) {
      const results = this.__get(value, gram_size);
      if (results.length > 0) return results;
    }
    return null;
  }
  /**
   * @param {string} value
   * @param {number} gram_size
   * @returns {MatchTuple[]}
   */
  __get(value, gram_size) {
    const normalized_value = value.toLowerCase();
    const matches = {};
    const gram_counts = gram_counter(normalized_value, gram_size);
    const items = this.items[gram_size];
    let sum_of_square_gram_counts = 0;
    let gram;
    let gram_count;
    let i;
    let index;
    let other_gram_count;
    for (gram in gram_counts) {
      gram_count = gram_counts[gram];
      sum_of_square_gram_counts += Math.pow(gram_count, 2);
      if (gram in this.match_dict) {
        for (i = 0; i < this.match_dict[gram].length; ++i) {
          index = this.match_dict[gram][i][0];
          other_gram_count = this.match_dict[gram][i][1];
          if (index in matches) {
            matches[index] += gram_count * other_gram_count;
          } else {
            matches[index] = gram_count * other_gram_count;
          }
        }
      }
    }
    const vector_normal = Math.sqrt(sum_of_square_gram_counts);
    let results = [];
    let match_score;
    for (const match_index in matches) {
      match_score = matches[match_index];
      results.push([match_score / (vector_normal * items[match_index][0]), items[match_index][1]]);
    }
    results.sort(sort_descending);
    let new_results = [];
    const end_index = Math.min(50, results.length);
    for (let i2 = 0; i2 < end_index; ++i2) {
      new_results.push([_distance(results[i2][1], normalized_value), results[i2][1]]);
    }
    results = new_results;
    results.sort(sort_descending);
    new_results = [];
    for (let i2 = 0; i2 < results.length; ++i2) {
      if (results[i2][0] === results[0][0]) {
        new_results.push([results[i2][0], this.exact_set[results[i2][1]]]);
      }
    }
    return new_results;
  }
};

// node_modules/svelte/src/compiler/state.js
var warnings = [];
var filename;
var source;
var dev;
var locator = getLocator("", { offsetLine: 1 });
var warning_filter;
var ignore_stack = [];
var ignore_map = /* @__PURE__ */ new Map();
function push_ignore(ignores) {
  const next2 = /* @__PURE__ */ new Set([...ignore_stack.at(-1) || [], ...ignores]);
  ignore_stack.push(next2);
}
function pop_ignore() {
  ignore_stack.pop();
}
function reset_warning_filter(fn = () => true) {
  warning_filter = fn;
}
function is_ignored(node, code) {
  var _a2;
  return dev && !!((_a2 = ignore_map.get(node)) == null ? void 0 : _a2.some((codes3) => codes3.has(code)));
}
function reset(_source, options) {
  var _a2;
  source = _source;
  const root_dir = (_a2 = options.rootDir) == null ? void 0 : _a2.replace(/\\/g, "/");
  filename = options.filename.replace(/\\/g, "/");
  dev = !!options.dev;
  if (typeof root_dir === "string" && filename.startsWith(root_dir)) {
    filename = filename.replace(root_dir, "").replace(/^[/\\]/, "");
  }
  locator = getLocator(source, { offsetLine: 1 });
  warnings = [];
  ignore_stack = [];
  ignore_map.clear();
}

// node_modules/svelte/src/compiler/utils/compile_diagnostic.js
var regex_tabs = /^\t+/;
function tabs_to_spaces(str) {
  return str.replace(regex_tabs, (match) => match.split("	").join("  "));
}
function get_code_frame(source2, line, column) {
  const lines = source2.split("\n");
  const frame_start = Math.max(0, line - 2);
  const frame_end = Math.min(line + 3, lines.length);
  const digits = String(frame_end + 1).length;
  return lines.slice(frame_start, frame_end).map((str, i) => {
    const is_error_line = frame_start + i === line;
    const line_num = String(i + frame_start + 1).padStart(digits, " ");
    if (is_error_line) {
      const indicator = " ".repeat(digits + 2 + tabs_to_spaces(str.slice(0, column)).length) + "^";
      return `${line_num}: ${tabs_to_spaces(str)}
${indicator}`;
    }
    return `${line_num}: ${tabs_to_spaces(str)}`;
  }).join("\n");
}
var CompileDiagnostic = class {
  /**
   * @param {string} code
   * @param {string} message
   * @param {[number, number] | undefined} position
   */
  constructor(code, message, position) {
    __publicField(this, "name", "CompileDiagnostic");
    this.code = code;
    this.message = message;
    if (filename) {
      this.filename = filename;
    }
    if (position) {
      this.position = position;
      this.start = locator(position[0]);
      this.end = locator(position[1]);
      if (this.start && this.end) {
        this.frame = get_code_frame(source, this.start.line - 1, this.end.column);
      }
    }
  }
  toString() {
    let out = `${this.code}: ${this.message}`;
    if (this.filename) {
      out += `
${this.filename}`;
      if (this.start) {
        out += `:${this.start.line}:${this.start.column}`;
      }
    }
    if (this.frame) {
      out += `
${this.frame}`;
    }
    return out;
  }
  toJSON() {
    return {
      code: this.code,
      message: this.message,
      filename: this.filename,
      start: this.start,
      end: this.end,
      position: this.position,
      frame: this.frame
    };
  }
};

// node_modules/svelte/src/compiler/warnings.js
var InternalCompileWarning = class extends CompileDiagnostic {
  /**
   * @param {string} code
   * @param {string} message
   * @param {[number, number] | undefined} position
   */
  constructor(code, message, position) {
    super(code, message, position);
    __publicField(this, "name", "CompileWarning");
  }
};
function w(node, code, message) {
  var _a2;
  let stack = ignore_stack;
  if (node) {
    stack = ignore_map.get(node) ?? ignore_stack;
  }
  if (stack && ((_a2 = stack.at(-1)) == null ? void 0 : _a2.has(code))) return;
  const warning = new InternalCompileWarning(code, message, node && node.start !== void 0 ? [node.start, node.end ?? node.start] : void 0);
  if (!warning_filter(warning)) return;
  warnings.push(warning);
}
var codes = [
  "a11y_accesskey",
  "a11y_aria_activedescendant_has_tabindex",
  "a11y_aria_attributes",
  "a11y_autocomplete_valid",
  "a11y_autofocus",
  "a11y_click_events_have_key_events",
  "a11y_consider_explicit_label",
  "a11y_distracting_elements",
  "a11y_figcaption_index",
  "a11y_figcaption_parent",
  "a11y_hidden",
  "a11y_img_redundant_alt",
  "a11y_incorrect_aria_attribute_type",
  "a11y_incorrect_aria_attribute_type_boolean",
  "a11y_incorrect_aria_attribute_type_id",
  "a11y_incorrect_aria_attribute_type_idlist",
  "a11y_incorrect_aria_attribute_type_integer",
  "a11y_incorrect_aria_attribute_type_token",
  "a11y_incorrect_aria_attribute_type_tokenlist",
  "a11y_incorrect_aria_attribute_type_tristate",
  "a11y_interactive_supports_focus",
  "a11y_invalid_attribute",
  "a11y_label_has_associated_control",
  "a11y_media_has_caption",
  "a11y_misplaced_role",
  "a11y_misplaced_scope",
  "a11y_missing_attribute",
  "a11y_missing_content",
  "a11y_mouse_events_have_key_events",
  "a11y_no_abstract_role",
  "a11y_no_interactive_element_to_noninteractive_role",
  "a11y_no_noninteractive_element_interactions",
  "a11y_no_noninteractive_element_to_interactive_role",
  "a11y_no_noninteractive_tabindex",
  "a11y_no_redundant_roles",
  "a11y_no_static_element_interactions",
  "a11y_positive_tabindex",
  "a11y_role_has_required_aria_props",
  "a11y_role_supports_aria_props",
  "a11y_role_supports_aria_props_implicit",
  "a11y_unknown_aria_attribute",
  "a11y_unknown_role",
  "legacy_code",
  "unknown_code",
  "options_deprecated_accessors",
  "options_deprecated_immutable",
  "options_missing_custom_element",
  "options_removed_enable_sourcemap",
  "options_removed_hydratable",
  "options_removed_loop_guard_timeout",
  "options_renamed_ssr_dom",
  "export_let_unused",
  "legacy_component_creation",
  "non_reactive_update",
  "perf_avoid_inline_class",
  "perf_avoid_nested_class",
  "reactive_declaration_invalid_placement",
  "reactive_declaration_module_script_dependency",
  "reactive_declaration_non_reactive_property",
  "state_referenced_locally",
  "store_rune_conflict",
  "css_unused_selector",
  "attribute_avoid_is",
  "attribute_global_event_reference",
  "attribute_illegal_colon",
  "attribute_invalid_property_name",
  "attribute_quoted",
  "bind_invalid_each_rest",
  "block_empty",
  "component_name_lowercase",
  "element_invalid_self_closing_tag",
  "event_directive_deprecated",
  "node_invalid_placement_ssr",
  "script_context_deprecated",
  "script_unknown_attribute",
  "slot_element_deprecated",
  "svelte_component_deprecated",
  "svelte_element_invalid_this",
  "svelte_self_deprecated"
];
function a11y_accesskey(node) {
  w(node, "a11y_accesskey", "Avoid using accesskey");
}
function a11y_aria_activedescendant_has_tabindex(node) {
  w(node, "a11y_aria_activedescendant_has_tabindex", "An element with an aria-activedescendant attribute should have a tabindex value");
}
function a11y_aria_attributes(node, name) {
  w(node, "a11y_aria_attributes", `\`<${name}>\` should not have aria-* attributes`);
}
function a11y_autocomplete_valid(node, value, type) {
  w(node, "a11y_autocomplete_valid", `'${value}' is an invalid value for 'autocomplete' on \`<input type="${type}">\``);
}
function a11y_autofocus(node) {
  w(node, "a11y_autofocus", "Avoid using autofocus");
}
function a11y_click_events_have_key_events(node) {
  w(node, "a11y_click_events_have_key_events", 'Visible, non-interactive elements with a click event must be accompanied by a keyboard event handler. Consider whether an interactive element such as `<button type="button">` or `<a>` might be more appropriate. See https://svelte.dev/docs/accessibility-warnings#a11y-click-events-have-key-events for more details');
}
function a11y_consider_explicit_label(node) {
  w(node, "a11y_consider_explicit_label", "Buttons and links should either contain text or have an `aria-label` or `aria-labelledby` attribute");
}
function a11y_distracting_elements(node, name) {
  w(node, "a11y_distracting_elements", `Avoid \`<${name}>\` elements`);
}
function a11y_figcaption_index(node) {
  w(node, "a11y_figcaption_index", "`<figcaption>` must be first or last child of `<figure>`");
}
function a11y_figcaption_parent(node) {
  w(node, "a11y_figcaption_parent", "`<figcaption>` must be an immediate child of `<figure>`");
}
function a11y_hidden(node, name) {
  w(node, "a11y_hidden", `\`<${name}>\` element should not be hidden`);
}
function a11y_img_redundant_alt(node) {
  w(node, "a11y_img_redundant_alt", "Screenreaders already announce `<img>` elements as an image");
}
function a11y_incorrect_aria_attribute_type(node, attribute, type) {
  w(node, "a11y_incorrect_aria_attribute_type", `The value of '${attribute}' must be a ${type}`);
}
function a11y_incorrect_aria_attribute_type_boolean(node, attribute) {
  w(node, "a11y_incorrect_aria_attribute_type_boolean", `The value of '${attribute}' must be either 'true' or 'false'. It cannot be empty`);
}
function a11y_incorrect_aria_attribute_type_idlist(node, attribute) {
  w(node, "a11y_incorrect_aria_attribute_type_idlist", `The value of '${attribute}' must be a space-separated list of strings that represent DOM element IDs`);
}
function a11y_incorrect_aria_attribute_type_integer(node, attribute) {
  w(node, "a11y_incorrect_aria_attribute_type_integer", `The value of '${attribute}' must be an integer`);
}
function a11y_incorrect_aria_attribute_type_token(node, attribute, values) {
  w(node, "a11y_incorrect_aria_attribute_type_token", `The value of '${attribute}' must be exactly one of ${values}`);
}
function a11y_incorrect_aria_attribute_type_tokenlist(node, attribute, values) {
  w(node, "a11y_incorrect_aria_attribute_type_tokenlist", `The value of '${attribute}' must be a space-separated list of one or more of ${values}`);
}
function a11y_incorrect_aria_attribute_type_tristate(node, attribute) {
  w(node, "a11y_incorrect_aria_attribute_type_tristate", `The value of '${attribute}' must be exactly one of true, false, or mixed`);
}
function a11y_interactive_supports_focus(node, role) {
  w(node, "a11y_interactive_supports_focus", `Elements with the '${role}' interactive role must have a tabindex value`);
}
function a11y_invalid_attribute(node, href_value, href_attribute) {
  w(node, "a11y_invalid_attribute", `'${href_value}' is not a valid ${href_attribute} attribute`);
}
function a11y_label_has_associated_control(node) {
  w(node, "a11y_label_has_associated_control", "A form label must be associated with a control");
}
function a11y_media_has_caption(node) {
  w(node, "a11y_media_has_caption", '`<video>` elements must have a `<track kind="captions">`');
}
function a11y_misplaced_role(node, name) {
  w(node, "a11y_misplaced_role", `\`<${name}>\` should not have role attribute`);
}
function a11y_misplaced_scope(node) {
  w(node, "a11y_misplaced_scope", "The scope attribute should only be used with `<th>` elements");
}
function a11y_missing_attribute(node, name, article, sequence2) {
  w(node, "a11y_missing_attribute", `\`<${name}>\` element should have ${article} ${sequence2} attribute`);
}
function a11y_missing_content(node, name) {
  w(node, "a11y_missing_content", `\`<${name}>\` element should contain text`);
}
function a11y_mouse_events_have_key_events(node, event, accompanied_by) {
  w(node, "a11y_mouse_events_have_key_events", `'${event}' event must be accompanied by '${accompanied_by}' event`);
}
function a11y_no_abstract_role(node, role) {
  w(node, "a11y_no_abstract_role", `Abstract role '${role}' is forbidden`);
}
function a11y_no_interactive_element_to_noninteractive_role(node, element2, role) {
  w(node, "a11y_no_interactive_element_to_noninteractive_role", `\`<${element2}>\` cannot have role '${role}'`);
}
function a11y_no_noninteractive_element_interactions(node, element2) {
  w(node, "a11y_no_noninteractive_element_interactions", `Non-interactive element \`<${element2}>\` should not be assigned mouse or keyboard event listeners`);
}
function a11y_no_noninteractive_element_to_interactive_role(node, element2, role) {
  w(node, "a11y_no_noninteractive_element_to_interactive_role", `Non-interactive element \`<${element2}>\` cannot have interactive role '${role}'`);
}
function a11y_no_noninteractive_tabindex(node) {
  w(node, "a11y_no_noninteractive_tabindex", "noninteractive element cannot have nonnegative tabIndex value");
}
function a11y_no_redundant_roles(node, role) {
  w(node, "a11y_no_redundant_roles", `Redundant role '${role}'`);
}
function a11y_no_static_element_interactions(node, element2, handler) {
  w(node, "a11y_no_static_element_interactions", `\`<${element2}>\` with a ${handler} handler must have an ARIA role`);
}
function a11y_positive_tabindex(node) {
  w(node, "a11y_positive_tabindex", "Avoid tabindex values above zero");
}
function a11y_role_has_required_aria_props(node, role, props) {
  w(node, "a11y_role_has_required_aria_props", `Elements with the ARIA role "${role}" must have the following attributes defined: ${props}`);
}
function a11y_role_supports_aria_props(node, attribute, role) {
  w(node, "a11y_role_supports_aria_props", `The attribute '${attribute}' is not supported by the role '${role}'`);
}
function a11y_role_supports_aria_props_implicit(node, attribute, role, name) {
  w(node, "a11y_role_supports_aria_props_implicit", `The attribute '${attribute}' is not supported by the role '${role}'. This role is implicit on the element \`<${name}>\``);
}
function a11y_unknown_aria_attribute(node, attribute, suggestion) {
  w(node, "a11y_unknown_aria_attribute", suggestion ? `Unknown aria attribute 'aria-${attribute}'. Did you mean '${suggestion}'?` : `Unknown aria attribute 'aria-${attribute}'`);
}
function a11y_unknown_role(node, role, suggestion) {
  w(node, "a11y_unknown_role", suggestion ? `Unknown role '${role}'. Did you mean '${suggestion}'?` : `Unknown role '${role}'`);
}
function legacy_code(node, code, suggestion) {
  w(node, "legacy_code", `\`${code}\` is no longer valid — please use \`${suggestion}\` instead`);
}
function unknown_code(node, code, suggestion) {
  w(node, "unknown_code", suggestion ? `\`${code}\` is not a recognised code (did you mean \`${suggestion}\`?)` : `\`${code}\` is not a recognised code`);
}
function options_deprecated_accessors(node) {
  w(node, "options_deprecated_accessors", "The `accessors` option has been deprecated. It will have no effect in runes mode");
}
function options_deprecated_immutable(node) {
  w(node, "options_deprecated_immutable", "The `immutable` option has been deprecated. It will have no effect in runes mode");
}
function options_missing_custom_element(node) {
  w(node, "options_missing_custom_element", "The `customElement` option is used when generating a custom element. Did you forget the `customElement: true` compile option?");
}
function options_removed_enable_sourcemap(node) {
  w(node, "options_removed_enable_sourcemap", "The `enableSourcemap` option has been removed. Source maps are always generated now, and tooling can choose to ignore them");
}
function options_removed_hydratable(node) {
  w(node, "options_removed_hydratable", "The `hydratable` option has been removed. Svelte components are always hydratable now");
}
function options_removed_loop_guard_timeout(node) {
  w(node, "options_removed_loop_guard_timeout", "The `loopGuardTimeout` option has been removed");
}
function options_renamed_ssr_dom(node) {
  w(node, "options_renamed_ssr_dom", '`generate: "dom"` and `generate: "ssr"` options have been renamed to "client" and "server" respectively');
}
function export_let_unused(node, name) {
  w(node, "export_let_unused", `Component has unused export property '${name}'. If it is for external reference only, please consider using \`export const ${name}\``);
}
function legacy_component_creation(node) {
  w(node, "legacy_component_creation", "Svelte 5 components are no longer classes. Instantiate them using `mount` or `hydrate` (imported from 'svelte') instead.");
}
function non_reactive_update(node, name) {
  w(node, "non_reactive_update", `\`${name}\` is updated, but is not declared with \`$state(...)\`. Changing its value will not correctly trigger updates`);
}
function perf_avoid_inline_class(node) {
  w(node, "perf_avoid_inline_class", "Avoid 'new class' — instead, declare the class at the top level scope");
}
function perf_avoid_nested_class(node) {
  w(node, "perf_avoid_nested_class", "Avoid declaring classes below the top level scope");
}
function reactive_declaration_invalid_placement(node) {
  w(node, "reactive_declaration_invalid_placement", "Reactive declarations only exist at the top level of the instance script");
}
function reactive_declaration_module_script_dependency(node) {
  w(node, "reactive_declaration_module_script_dependency", "Reassignments of module-level declarations will not cause reactive statements to update");
}
function reactive_declaration_non_reactive_property(node) {
  w(node, "reactive_declaration_non_reactive_property", "Properties of objects and arrays are not reactive unless in runes mode. Changes to this property will not cause the reactive statement to update");
}
function state_referenced_locally(node) {
  w(node, "state_referenced_locally", "State referenced in its own scope will never update. Did you mean to reference it inside a closure?");
}
function store_rune_conflict(node, name) {
  w(node, "store_rune_conflict", `It looks like you're using the \`$${name}\` rune, but there is a local binding called \`${name}\`. Referencing a local variable with a \`$\` prefix will create a store subscription. Please rename \`${name}\` to avoid the ambiguity`);
}
function css_unused_selector(node, name) {
  w(node, "css_unused_selector", `Unused CSS selector "${name}"`);
}
function attribute_avoid_is(node) {
  w(node, "attribute_avoid_is", 'The "is" attribute is not supported cross-browser and should be avoided');
}
function attribute_global_event_reference(node, name) {
  w(node, "attribute_global_event_reference", `You are referencing \`globalThis.${name}\`. Did you forget to declare a variable with that name?`);
}
function attribute_illegal_colon(node) {
  w(node, "attribute_illegal_colon", "Attributes should not contain ':' characters to prevent ambiguity with Svelte directives");
}
function attribute_invalid_property_name(node, wrong, right) {
  w(node, "attribute_invalid_property_name", `'${wrong}' is not a valid HTML attribute. Did you mean '${right}'?`);
}
function attribute_quoted(node) {
  w(node, "attribute_quoted", "Quoted attributes on components and custom elements will be stringified in a future version of Svelte. If this isn't what you want, remove the quotes");
}
function bind_invalid_each_rest(node, name) {
  w(node, "bind_invalid_each_rest", `The rest operator (...) will create a new object and binding '${name}' with the original object will not work`);
}
function block_empty(node) {
  w(node, "block_empty", "Empty block");
}
function component_name_lowercase(node, name) {
  w(node, "component_name_lowercase", `\`<${name}>\` will be treated as an HTML element unless it begins with a capital letter`);
}
function element_invalid_self_closing_tag(node, name) {
  w(node, "element_invalid_self_closing_tag", `Self-closing HTML tags for non-void elements are ambiguous — use \`<${name} ...></${name}>\` rather than \`<${name} ... />\``);
}
function event_directive_deprecated(node, name) {
  w(node, "event_directive_deprecated", `Using \`on:${name}\` to listen to the ${name} event is deprecated. Use the event attribute \`on${name}\` instead`);
}
function node_invalid_placement_ssr(node, thing, parent) {
  w(node, "node_invalid_placement_ssr", `${thing} is invalid inside \`<${parent}>\`. When rendering this component on the server, the resulting HTML will be modified by the browser, likely resulting in a \`hydration_mismatch\` warning`);
}
function script_context_deprecated(node) {
  w(node, "script_context_deprecated", '`context="module"` is deprecated, use the `module` attribute instead');
}
function script_unknown_attribute(node) {
  w(node, "script_unknown_attribute", "Unrecognized attribute — should be one of `generics`, `lang` or `module`. If this exists for a preprocessor, ensure that the preprocessor removes it");
}
function slot_element_deprecated(node) {
  w(node, "slot_element_deprecated", "Using `<slot>` to render parent content is deprecated. Use `{@render ...}` tags instead");
}
function svelte_component_deprecated(node) {
  w(node, "svelte_component_deprecated", "`<svelte:component>` is deprecated in runes mode — components are dynamic by default");
}
function svelte_element_invalid_this(node) {
  w(node, "svelte_element_invalid_this", "`this` should be an `{expression}`. Using a string attribute value will cause an error in future versions of Svelte");
}
function svelte_self_deprecated(node, name, basename) {
  w(node, "svelte_self_deprecated", `\`<svelte:self>\` is deprecated — use self-imports (e.g. \`import ${name} from './${basename}'\`) instead`);
}

// node_modules/svelte/src/compiler/utils/extract_svelte_ignore.js
var regex_svelte_ignore = /^\s*svelte-ignore\s/;
var replacements = {
  "non-top-level-reactive-declaration": "reactive_declaration_invalid_placement",
  "module-script-reactive-declaration": "reactive_declaration_module_script",
  "empty-block": "block_empty",
  "avoid-is": "attribute_avoid_is",
  "invalid-html-attribute": "attribute_invalid_property_name",
  "a11y-structure": "a11y_figcaption_parent",
  "illegal-attribute-character": "attribute_illegal_colon",
  "invalid-rest-eachblock-binding": "bind_invalid_each_rest",
  "unused-export-let": "export_let_unused"
};
var codes2 = codes.concat(IGNORABLE_RUNTIME_WARNINGS);
function extract_svelte_ignore(offset, text2, runes) {
  const match = regex_svelte_ignore.exec(text2);
  if (!match) return [];
  let length = match[0].length;
  offset += length;
  const ignores = [];
  if (runes) {
    for (const match2 of text2.slice(length).matchAll(/([\w$-]+)(,)?/gm)) {
      const code = match2[1];
      if (codes2.includes(code)) {
        ignores.push(code);
      } else {
        const replacement = replacements[code] ?? code.replace(/-/g, "_");
        const start = offset + /** @type {number} */
        match2.index;
        const end = start + code.length;
        if (codes2.includes(replacement)) {
          legacy_code({ start, end }, code, replacement);
        } else {
          const suggestion = fuzzymatch(code, codes2);
          unknown_code({ start, end }, code, suggestion);
        }
      }
      if (!match2[2]) {
        break;
      }
    }
  } else {
    for (const match2 of text2.slice(length).matchAll(/[\w$-]+/gm)) {
      const code = match2[0];
      ignores.push(code);
      if (!codes2.includes(code)) {
        const replacement = replacements[code] ?? code.replace(/-/g, "_");
        if (codes2.includes(replacement)) {
          ignores.push(replacement);
        }
      }
    }
  }
  return ignores;
}
function migrate_svelte_ignore(text2) {
  const match = regex_svelte_ignore.exec(text2);
  if (!match) return text2;
  const length = match[0].length;
  return text2.substring(0, length) + text2.substring(length).replace(/\w+-\w+(-\w+)*/g, (code, _, idx) => {
    let replacement = replacements[code] ?? code.replace(/-/g, "_");
    if (/\w+-\w+/.test(text2.substring(length + idx + code.length))) {
      replacement += ",";
    }
    return replacement;
  });
}

// node_modules/svelte/src/compiler/legacy.js
function remove_surrounding_whitespace_nodes(nodes) {
  const first = nodes.at(0);
  const last = nodes.at(-1);
  if ((first == null ? void 0 : first.type) === "Text") {
    if (!regex_not_whitespace.test(first.data)) {
      nodes.shift();
    } else {
      first.data = first.data.replace(regex_starts_with_whitespaces, "");
    }
  }
  if ((last == null ? void 0 : last.type) === "Text") {
    if (!regex_not_whitespace.test(last.data)) {
      nodes.pop();
    } else {
      last.data = last.data.replace(regex_ends_with_whitespaces, "");
    }
  }
}
function convert(source2, ast) {
  const root = (
    /** @type {SvelteNode | Legacy.LegacySvelteNode} */
    ast
  );
  return (
    /** @type {Legacy.LegacyRoot} */
    walk(root, null, {
      _(node, { next: next2 }) {
        delete node.parent;
        delete node.metadata;
        next2();
      },
      // @ts-ignore
      Root(node, { visit }) {
        const { instance, module, options } = node;
        if (
          /** @type {any} */
          options == null ? void 0 : options.__raw__
        ) {
          let idx = node.fragment.nodes.findIndex((node2) => options.end <= node2.start);
          if (idx === -1) {
            idx = node.fragment.nodes.length;
          }
          delete options.__raw__.parent;
          node.fragment.nodes.splice(
            idx,
            0,
            /** @type {any} */
            options.__raw__
          );
        }
        let start = null;
        let end = null;
        if (node.fragment.nodes.length > 0) {
          const first = (
            /** @type {AST.BaseNode} */
            node.fragment.nodes.at(0)
          );
          const last = (
            /** @type {AST.BaseNode} */
            node.fragment.nodes.at(-1)
          );
          start = first.start;
          end = last.end;
          while (/\s/.test(source2[start])) start += 1;
          while (/\s/.test(source2[end - 1])) end -= 1;
        }
        if (instance) {
          delete instance.parent;
          delete instance.attributes;
        }
        if (module) {
          delete module.parent;
          delete module.attributes;
        }
        return {
          html: {
            type: "Fragment",
            start,
            end,
            children: node.fragment.nodes.map((child) => visit(child))
          },
          instance,
          module,
          css: ast.css ? visit(ast.css) : void 0
        };
      },
      AnimateDirective(node) {
        return { ...node, type: "Animation" };
      },
      // @ts-ignore
      AwaitBlock(node, { visit }) {
        var _a2, _b2, _c;
        let pendingblock = {
          type: "PendingBlock",
          /** @type {number | null} */
          start: null,
          /** @type {number | null} */
          end: null,
          children: ((_a2 = node.pending) == null ? void 0 : _a2.nodes.map((child) => visit(child))) ?? [],
          skip: true
        };
        let thenblock = {
          type: "ThenBlock",
          /** @type {number | null} */
          start: null,
          /** @type {number | null} */
          end: null,
          children: ((_b2 = node.then) == null ? void 0 : _b2.nodes.map((child) => visit(child))) ?? [],
          skip: true
        };
        let catchblock = {
          type: "CatchBlock",
          /** @type {number | null} */
          start: null,
          /** @type {number | null} */
          end: null,
          children: ((_c = node.catch) == null ? void 0 : _c.nodes.map((child) => visit(child))) ?? [],
          skip: true
        };
        if (node.pending) {
          const first = node.pending.nodes.at(0);
          const last = node.pending.nodes.at(-1);
          pendingblock.start = (first == null ? void 0 : first.start) ?? source2.indexOf("}", node.expression.end) + 1;
          pendingblock.end = (last == null ? void 0 : last.end) ?? pendingblock.start;
          pendingblock.skip = false;
        }
        if (node.then) {
          const first = node.then.nodes.at(0);
          const last = node.then.nodes.at(-1);
          thenblock.start = pendingblock.end ?? (first == null ? void 0 : first.start) ?? source2.indexOf("}", node.expression.end) + 1;
          thenblock.end = (last == null ? void 0 : last.end) ?? source2.lastIndexOf("}", pendingblock.end ?? node.expression.end) + 1;
          thenblock.skip = false;
        }
        if (node.catch) {
          const first = node.catch.nodes.at(0);
          const last = node.catch.nodes.at(-1);
          catchblock.start = thenblock.end ?? pendingblock.end ?? (first == null ? void 0 : first.start) ?? source2.indexOf("}", node.expression.end) + 1;
          catchblock.end = (last == null ? void 0 : last.end) ?? source2.lastIndexOf("}", thenblock.end ?? pendingblock.end ?? node.expression.end) + 1;
          catchblock.skip = false;
        }
        return {
          type: "AwaitBlock",
          start: node.start,
          end: node.end,
          expression: node.expression,
          value: node.value,
          error: node.error,
          pending: pendingblock,
          then: thenblock,
          catch: catchblock
        };
      },
      BindDirective(node) {
        return { ...node, type: "Binding" };
      },
      ClassDirective(node) {
        return { ...node, type: "Class" };
      },
      Comment(node) {
        return {
          ...node,
          ignores: extract_svelte_ignore(node.start, node.data, false)
        };
      },
      ComplexSelector(node, { next: next2 }) {
        next2();
        const children = [];
        for (const child of node.children) {
          if (child.combinator) {
            children.push(child.combinator);
          }
          children.push(...child.selectors);
        }
        return {
          type: "Selector",
          start: node.start,
          end: node.end,
          children
        };
      },
      Component(node, { visit }) {
        return {
          type: "InlineComponent",
          start: node.start,
          end: node.end,
          name: node.name,
          attributes: node.attributes.map(
            (child) => (
              /** @type {Legacy.LegacyAttributeLike} */
              visit(child)
            )
          ),
          children: node.fragment.nodes.map(
            (child) => (
              /** @type {Legacy.LegacyElementLike} */
              visit(child)
            )
          )
        };
      },
      // @ts-ignore
      ConstTag(node) {
        if (
          /** @type {Legacy.LegacyConstTag} */
          node.expression !== void 0
        ) {
          return node;
        }
        const modern_node = (
          /** @type {AST.ConstTag} */
          node
        );
        const { id: left } = { ...modern_node.declaration.declarations[0] };
        delete left.typeAnnotation;
        return {
          type: "ConstTag",
          start: modern_node.start,
          end: node.end,
          expression: {
            type: "AssignmentExpression",
            start: (modern_node.declaration.start ?? 0) + "const ".length,
            end: modern_node.declaration.end ?? 0,
            operator: "=",
            left,
            right: modern_node.declaration.declarations[0].init
          }
        };
      },
      // @ts-ignore
      KeyBlock(node, { visit }) {
        remove_surrounding_whitespace_nodes(node.fragment.nodes);
        return {
          type: "KeyBlock",
          start: node.start,
          end: node.end,
          expression: node.expression,
          children: node.fragment.nodes.map(
            (child) => (
              /** @type {Legacy.LegacyElementLike} */
              visit(child)
            )
          )
        };
      },
      // @ts-ignore
      EachBlock(node, { visit }) {
        let elseblock = void 0;
        if (node.fallback) {
          const first = node.fallback.nodes.at(0);
          const end = source2.lastIndexOf(
            "{",
            /** @type {number} */
            node.end - 1
          );
          const start = (first == null ? void 0 : first.start) ?? end;
          remove_surrounding_whitespace_nodes(node.fallback.nodes);
          elseblock = {
            type: "ElseBlock",
            start,
            end,
            children: node.fallback.nodes.map((child) => visit(child))
          };
        }
        remove_surrounding_whitespace_nodes(node.body.nodes);
        return {
          type: "EachBlock",
          start: node.start,
          end: node.end,
          children: node.body.nodes.map((child) => visit(child)),
          context: node.context,
          expression: node.expression,
          index: node.index,
          key: node.key,
          else: elseblock
        };
      },
      ExpressionTag(node, { path }) {
        const parent = path.at(-1);
        if ((parent == null ? void 0 : parent.type) === "Attribute") {
          if (source2[parent.start] === "{") {
            return {
              type: "AttributeShorthand",
              start: node.start,
              end: node.end,
              expression: node.expression
            };
          }
        }
        return {
          type: "MustacheTag",
          start: node.start,
          end: node.end,
          expression: node.expression
        };
      },
      HtmlTag(node) {
        return { ...node, type: "RawMustacheTag" };
      },
      // @ts-ignore
      IfBlock(node, { visit }) {
        var _a2, _b2;
        let elseblock = void 0;
        if (node.alternate) {
          let nodes = node.alternate.nodes;
          if (nodes.length === 1 && nodes[0].type === "IfBlock" && nodes[0].elseif) {
            nodes = nodes[0].consequent.nodes;
          }
          const end = source2.lastIndexOf(
            "{",
            /** @type {number} */
            node.end - 1
          );
          const start2 = ((_a2 = nodes.at(0)) == null ? void 0 : _a2.start) ?? end;
          remove_surrounding_whitespace_nodes(node.alternate.nodes);
          elseblock = {
            type: "ElseBlock",
            start: start2,
            end,
            children: node.alternate.nodes.map(
              (child) => (
                /** @type {Legacy.LegacyElementLike} */
                visit(child)
              )
            )
          };
        }
        const start = node.elseif ? ((_b2 = node.consequent.nodes[0]) == null ? void 0 : _b2.start) ?? source2.lastIndexOf(
          "{",
          /** @type {number} */
          node.end - 1
        ) : node.start;
        remove_surrounding_whitespace_nodes(node.consequent.nodes);
        return {
          type: "IfBlock",
          start,
          end: node.end,
          expression: node.test,
          children: node.consequent.nodes.map(
            (child) => (
              /** @type {Legacy.LegacyElementLike} */
              visit(child)
            )
          ),
          else: elseblock,
          elseif: node.elseif ? true : void 0
        };
      },
      OnDirective(node) {
        return { ...node, type: "EventHandler" };
      },
      // @ts-expect-error
      SnippetBlock(node, { visit }) {
        remove_surrounding_whitespace_nodes(node.body.nodes);
        return {
          type: "SnippetBlock",
          start: node.start,
          end: node.end,
          expression: node.expression,
          parameters: node.parameters,
          children: node.body.nodes.map((child) => visit(child))
        };
      },
      RegularElement(node, { visit }) {
        return {
          type: "Element",
          start: node.start,
          end: node.end,
          name: node.name,
          attributes: node.attributes.map((child) => visit(child)),
          children: node.fragment.nodes.map((child) => visit(child))
        };
      },
      SlotElement(node, { visit }) {
        return {
          type: "Slot",
          start: node.start,
          end: node.end,
          name: node.name,
          attributes: node.attributes.map(
            (child) => (
              /** @type {Legacy.LegacyAttributeLike} */
              visit(child)
            )
          ),
          children: node.fragment.nodes.map(
            (child) => (
              /** @type {Legacy.LegacyElementLike} */
              visit(child)
            )
          )
        };
      },
      Attribute(node, { visit, next: next2, path }) {
        if (node.value !== true && !Array.isArray(node.value)) {
          path.push(node);
          const value = (
            /** @type {Legacy.LegacyAttribute['value']} */
            [visit(node.value)]
          );
          path.pop();
          return {
            ...node,
            value
          };
        } else {
          return next2();
        }
      },
      StyleDirective(node, { visit, next: next2, path }) {
        if (node.value !== true && !Array.isArray(node.value)) {
          path.push(node);
          const value = (
            /** @type {Legacy.LegacyStyleDirective['value']} */
            [visit(node.value)]
          );
          path.pop();
          return {
            ...node,
            value
          };
        } else {
          return next2();
        }
      },
      SpreadAttribute(node) {
        return { ...node, type: "Spread" };
      },
      StyleSheet(node, context) {
        return {
          ...node,
          ...context.next(),
          type: "Style"
        };
      },
      SvelteBody(node, { visit }) {
        return {
          type: "Body",
          name: "svelte:body",
          start: node.start,
          end: node.end,
          attributes: node.attributes.map(
            (child) => (
              /** @type {Legacy.LegacyAttributeLike} */
              visit(child)
            )
          ),
          children: node.fragment.nodes.map(
            (child) => (
              /** @type {Legacy.LegacyElementLike} */
              visit(child)
            )
          )
        };
      },
      SvelteComponent(node, { visit }) {
        return {
          type: "InlineComponent",
          name: "svelte:component",
          start: node.start,
          end: node.end,
          expression: node.expression,
          attributes: node.attributes.map(
            (child) => (
              /** @type {Legacy.LegacyAttributeLike} */
              visit(child)
            )
          ),
          children: node.fragment.nodes.map(
            (child) => (
              /** @type {Legacy.LegacyElementLike} */
              visit(child)
            )
          )
        };
      },
      SvelteDocument(node, { visit }) {
        return {
          type: "Document",
          name: "svelte:document",
          start: node.start,
          end: node.end,
          attributes: node.attributes.map(
            (child) => (
              /** @type {Legacy.LegacyAttributeLike} */
              visit(child)
            )
          ),
          children: node.fragment.nodes.map(
            (child) => (
              /** @type {Legacy.LegacyElementLike} */
              visit(child)
            )
          )
        };
      },
      SvelteElement(node, { visit }) {
        let tag2 = node.tag;
        if (tag2.type === "Literal" && typeof tag2.value === "string" && source2[
          /** @type {number} */
          node.tag.start - 1
        ] !== "{") {
          tag2 = tag2.value;
        }
        return {
          type: "Element",
          name: "svelte:element",
          start: node.start,
          end: node.end,
          tag: tag2,
          attributes: node.attributes.map((child) => visit(child)),
          children: node.fragment.nodes.map((child) => visit(child))
        };
      },
      SvelteFragment(node, { visit }) {
        return {
          type: "SlotTemplate",
          name: "svelte:fragment",
          start: node.start,
          end: node.end,
          attributes: node.attributes.map(
            (a) => (
              /** @type {Legacy.LegacyAttributeLike} */
              visit(a)
            )
          ),
          children: node.fragment.nodes.map(
            (child) => (
              /** @type {Legacy.LegacyElementLike} */
              visit(child)
            )
          )
        };
      },
      SvelteHead(node, { visit }) {
        return {
          type: "Head",
          name: "svelte:head",
          start: node.start,
          end: node.end,
          attributes: node.attributes.map(
            (child) => (
              /** @type {Legacy.LegacyAttributeLike} */
              visit(child)
            )
          ),
          children: node.fragment.nodes.map(
            (child) => (
              /** @type {Legacy.LegacyElementLike} */
              visit(child)
            )
          )
        };
      },
      SvelteOptions(node, { visit }) {
        return {
          type: "Options",
          name: "svelte:options",
          start: node.start,
          end: node.end,
          attributes: node.attributes.map(
            (child) => (
              /** @type {Legacy.LegacyAttributeLike} */
              visit(child)
            )
          )
        };
      },
      SvelteSelf(node, { visit }) {
        return {
          type: "InlineComponent",
          name: "svelte:self",
          start: node.start,
          end: node.end,
          attributes: node.attributes.map(
            (child) => (
              /** @type {Legacy.LegacyAttributeLike} */
              visit(child)
            )
          ),
          children: node.fragment.nodes.map(
            (child) => (
              /** @type {Legacy.LegacyElementLike} */
              visit(child)
            )
          )
        };
      },
      SvelteWindow(node, { visit }) {
        return {
          type: "Window",
          name: "svelte:window",
          start: node.start,
          end: node.end,
          attributes: node.attributes.map(
            (child) => (
              /** @type {Legacy.LegacyAttributeLike} */
              visit(child)
            )
          ),
          children: node.fragment.nodes.map(
            (child) => (
              /** @type {Legacy.LegacyElementLike} */
              visit(child)
            )
          )
        };
      },
      Text(node, { path }) {
        const parent = path.at(-1);
        if ((parent == null ? void 0 : parent.type) === "RegularElement" && parent.name === "style") {
          return (
            /** @type {AST.Text} */
            {
              type: "Text",
              start: node.start,
              end: node.end,
              data: node.data
            }
          );
        }
      },
      TitleElement(node, { visit }) {
        return {
          type: "Title",
          name: "title",
          start: node.start,
          end: node.end,
          attributes: node.attributes.map(
            (child) => (
              /** @type {Legacy.LegacyAttributeLike} */
              visit(child)
            )
          ),
          children: node.fragment.nodes.map(
            (child) => (
              /** @type {Legacy.LegacyElementLike} */
              visit(child)
            )
          )
        };
      },
      TransitionDirective(node) {
        return { ...node, type: "Transition" };
      },
      UseDirective(node) {
        return { ...node, type: "Action" };
      },
      LetDirective(node) {
        return { ...node, type: "Let" };
      }
    })
  );
}

// node_modules/svelte/src/compiler/phases/1-parse/acorn.js
var ParserWithTS = Parser.extend(D({ allowSatisfies: true }));
function parse(source2, typescript) {
  const parser = typescript ? ParserWithTS : Parser;
  const { onComment, add_comments } = get_comment_handlers(source2);
  const ast = parser.parse(source2, {
    onComment,
    sourceType: "module",
    ecmaVersion: 13,
    locations: true
  });
  if (typescript) amend(source2, ast);
  add_comments(ast);
  return (
    /** @type {Program} */
    ast
  );
}
function parse_expression_at(source2, typescript, index) {
  const parser = typescript ? ParserWithTS : Parser;
  const { onComment, add_comments } = get_comment_handlers(source2);
  const ast = parser.parseExpressionAt(source2, index, {
    onComment,
    sourceType: "module",
    ecmaVersion: 13,
    locations: true
  });
  if (typescript) amend(source2, ast);
  add_comments(ast);
  return ast;
}
function get_comment_handlers(source2) {
  const comments = [];
  return {
    /**
     * @param {boolean} block
     * @param {string} value
     * @param {number} start
     * @param {number} end
     */
    onComment: (block2, value, start, end) => {
      if (block2 && /\n/.test(value)) {
        let a = start;
        while (a > 0 && source2[a - 1] !== "\n") a -= 1;
        let b = a;
        while (/[ \t]/.test(source2[b])) b += 1;
        const indentation = source2.slice(a, b);
        value = value.replace(new RegExp(`^${indentation}`, "gm"), "");
      }
      comments.push({ type: block2 ? "Block" : "Line", value, start, end });
    },
    /** @param {acorn.Node & { leadingComments?: CommentWithLocation[]; trailingComments?: CommentWithLocation[]; }} ast */
    add_comments(ast) {
      if (comments.length === 0) return;
      walk(ast, null, {
        _(node, { next: next2, path }) {
          let comment;
          while (comments[0] && comments[0].start < node.start) {
            comment = /** @type {CommentWithLocation} */
            comments.shift();
            (node.leadingComments || (node.leadingComments = [])).push(comment);
          }
          next2();
          if (comments[0]) {
            const parent = (
              /** @type {any} */
              path.at(-1)
            );
            if (parent === void 0 || node.end !== parent.end) {
              const slice = source2.slice(node.end, comments[0].start);
              const is_last_in_body = ((parent == null ? void 0 : parent.type) === "BlockStatement" || (parent == null ? void 0 : parent.type) === "Program") && parent.body.indexOf(node) === parent.body.length - 1 || (parent == null ? void 0 : parent.type) === "ArrayExpression" && parent.elements.indexOf(node) === parent.elements.length - 1 || (parent == null ? void 0 : parent.type) === "ObjectExpression" && parent.properties.indexOf(node) === parent.properties.length - 1;
              if (is_last_in_body) {
                let end = node.end;
                while (comments.length) {
                  const comment2 = comments[0];
                  if (parent && comment2.start >= parent.end) break;
                  (node.trailingComments || (node.trailingComments = [])).push(comment2);
                  comments.shift();
                  end = comment2.end;
                }
              } else if (node.end <= comments[0].start && /^[,) \t]*$/.test(slice)) {
                node.trailingComments = [
                  /** @type {CommentWithLocation} */
                  comments.shift()
                ];
              }
            }
          }
        }
      });
      if (comments.length > 0 && (comments[0].start >= ast.end || ast.type === "Program")) {
        (ast.trailingComments || (ast.trailingComments = [])).push(...comments.splice(0));
      }
    }
  };
}
function amend(source2, node) {
  return walk(node, null, {
    _(node2, context) {
      var _a2;
      delete node2.loc.start.index;
      delete node2.loc.end.index;
      if (typeof ((_a2 = node2.loc) == null ? void 0 : _a2.end) === "number") {
        const loc = locator(node2.loc.end);
        if (loc) {
          node2.loc.end = {
            line: loc.line,
            column: loc.column
          };
        }
      }
      if (
        /** @type {any} */
        node2.typeAnnotation && (node2.end === void 0 || node2.end < node2.start)
      ) {
        let end = (
          /** @type {any} */
          node2.typeAnnotation.start
        );
        while (/\s/.test(source2[end - 1])) end -= 1;
        node2.end = end;
      }
      context.next();
    }
  });
}

// node_modules/svelte/src/compiler/errors.js
var _diagnostic;
var InternalCompileError = class extends Error {
  /**
   * @param {string} code
   * @param {string} message
   * @param {[number, number] | undefined} position
   */
  constructor(code, message, position) {
    super(message);
    __publicField(this, "message", "");
    // ensure this property is enumerable
    __privateAdd(this, _diagnostic);
    this.stack = "";
    __privateSet(this, _diagnostic, new CompileDiagnostic(code, message, position));
    Object.assign(this, __privateGet(this, _diagnostic));
    this.name = "CompileError";
  }
  toString() {
    return __privateGet(this, _diagnostic).toString();
  }
  toJSON() {
    return __privateGet(this, _diagnostic).toJSON();
  }
};
_diagnostic = new WeakMap();
function e(node, code, message) {
  const start = typeof node === "number" ? node : node == null ? void 0 : node.start;
  const end = typeof node === "number" ? node : node == null ? void 0 : node.end;
  throw new InternalCompileError(code, message, start !== void 0 ? [start, end ?? start] : void 0);
}
function options_invalid_value(node, details) {
  e(node, "options_invalid_value", `Invalid compiler option: ${details}`);
}
function options_removed(node, details) {
  e(node, "options_removed", `Invalid compiler option: ${details}`);
}
function options_unrecognised(node, keypath) {
  e(node, "options_unrecognised", `Unrecognised compiler option ${keypath}`);
}
function bindable_invalid_location(node) {
  e(node, "bindable_invalid_location", "`$bindable()` can only be used inside a `$props()` declaration");
}
function constant_assignment(node, thing) {
  e(node, "constant_assignment", `Cannot assign to ${thing}`);
}
function constant_binding(node, thing) {
  e(node, "constant_binding", `Cannot bind to ${thing}`);
}
function declaration_duplicate(node, name) {
  e(node, "declaration_duplicate", `\`${name}\` has already been declared`);
}
function declaration_duplicate_module_import(node) {
  e(node, "declaration_duplicate_module_import", "Cannot declare a variable with the same name as an import inside `<script module>`");
}
function derived_invalid_export(node) {
  e(node, "derived_invalid_export", "Cannot export derived state from a module. To expose the current derived value, export a function returning its value");
}
function dollar_binding_invalid(node) {
  e(node, "dollar_binding_invalid", "The $ name is reserved, and cannot be used for variables and imports");
}
function dollar_prefix_invalid(node) {
  e(node, "dollar_prefix_invalid", "The $ prefix is reserved, and cannot be used for variables and imports");
}
function each_item_invalid_assignment(node) {
  e(node, "each_item_invalid_assignment", "Cannot reassign or bind to each block argument in runes mode. Use the array and index variables instead (e.g. `array[i] = value` instead of `entry = value`)");
}
function effect_invalid_placement(node) {
  e(node, "effect_invalid_placement", "`$effect()` can only be used as an expression statement");
}
function global_reference_invalid(node, name) {
  e(node, "global_reference_invalid", `\`${name}\` is an illegal variable name. To reference a global variable called \`${name}\`, use \`globalThis.${name}\``);
}
function host_invalid_placement(node) {
  e(node, "host_invalid_placement", "`$host()` can only be used inside custom element component instances");
}
function import_svelte_internal_forbidden(node) {
  e(node, "import_svelte_internal_forbidden", "Imports of `svelte/internal/*` are forbidden. It contains private runtime code which is subject to change without notice. If you're importing from `svelte/internal/*` to work around a limitation of Svelte, please open an issue at https://github.com/sveltejs/svelte and explain your use case");
}
function invalid_arguments_usage(node) {
  e(node, "invalid_arguments_usage", "The arguments keyword cannot be used within the template or at the top level of a component");
}
function legacy_export_invalid(node) {
  e(node, "legacy_export_invalid", "Cannot use `export let` in runes mode — use `$props()` instead");
}
function legacy_props_invalid(node) {
  e(node, "legacy_props_invalid", "Cannot use `$$props` in runes mode");
}
function legacy_reactive_statement_invalid(node) {
  e(node, "legacy_reactive_statement_invalid", "`$:` is not allowed in runes mode, use `$derived` or `$effect` instead");
}
function legacy_rest_props_invalid(node) {
  e(node, "legacy_rest_props_invalid", "Cannot use `$$restProps` in runes mode");
}
function module_illegal_default_export(node) {
  e(node, "module_illegal_default_export", "A component cannot have a default export");
}
function props_duplicate(node) {
  e(node, "props_duplicate", "Cannot use `$props()` more than once");
}
function props_illegal_name(node) {
  e(node, "props_illegal_name", "Declaring or accessing a prop starting with `$$` is illegal (they are reserved for Svelte internals)");
}
function props_invalid_identifier(node) {
  e(node, "props_invalid_identifier", "`$props()` can only be used with an object destructuring pattern");
}
function props_invalid_pattern(node) {
  e(node, "props_invalid_pattern", "`$props()` assignment must not contain nested properties or computed keys");
}
function props_invalid_placement(node) {
  e(node, "props_invalid_placement", "`$props()` can only be used at the top level of components as a variable declaration initializer");
}
function reactive_declaration_cycle(node, cycle) {
  e(node, "reactive_declaration_cycle", `Cyclical dependency detected: ${cycle}`);
}
function rune_invalid_arguments(node, rune) {
  e(node, "rune_invalid_arguments", `\`${rune}\` cannot be called with arguments`);
}
function rune_invalid_arguments_length(node, rune, args) {
  e(node, "rune_invalid_arguments_length", `\`${rune}\` must be called with ${args}`);
}
function rune_invalid_computed_property(node) {
  e(node, "rune_invalid_computed_property", "Cannot access a computed property of a rune");
}
function rune_invalid_name(node, name) {
  e(node, "rune_invalid_name", `\`${name}\` is not a valid rune`);
}
function rune_invalid_usage(node, rune) {
  e(node, "rune_invalid_usage", `Cannot use \`${rune}\` rune in non-runes mode`);
}
function rune_missing_parentheses(node) {
  e(node, "rune_missing_parentheses", "Cannot use rune without parentheses");
}
function rune_removed(node, name) {
  e(node, "rune_removed", `The \`${name}\` rune has been removed`);
}
function rune_renamed(node, name, replacement) {
  e(node, "rune_renamed", `\`${name}\` is now \`${replacement}\``);
}
function runes_mode_invalid_import(node, name) {
  e(node, "runes_mode_invalid_import", `${name} cannot be used in runes mode`);
}
function snippet_parameter_assignment(node) {
  e(node, "snippet_parameter_assignment", "Cannot reassign or bind to snippet parameter");
}
function state_invalid_export(node) {
  e(node, "state_invalid_export", "Cannot export state from a module if it is reassigned. Either export a function returning the state value or only mutate the state value's properties");
}
function state_invalid_placement(node, rune) {
  e(node, "state_invalid_placement", `\`${rune}(...)\` can only be used as a variable declaration initializer or a class field`);
}
function store_invalid_scoped_subscription(node) {
  e(node, "store_invalid_scoped_subscription", "Cannot subscribe to stores that are not declared at the top level of the component");
}
function store_invalid_subscription(node) {
  e(node, "store_invalid_subscription", "Cannot reference store value inside `<script module>`");
}
function store_invalid_subscription_module(node) {
  e(node, "store_invalid_subscription_module", "Cannot reference store value outside a `.svelte` file");
}
function typescript_invalid_feature(node, feature) {
  e(node, "typescript_invalid_feature", `TypeScript language features like ${feature} are not natively supported, and their use is generally discouraged. Outside of \`<script>\` tags, these features are not supported. For use within \`<script>\` tags, you will need to use a preprocessor to convert it to JavaScript before it gets passed to the Svelte compiler. If you are using \`vitePreprocess\`, make sure to specifically enable preprocessing script tags (\`vitePreprocess({ script: true })\`)`);
}
function css_empty_declaration(node) {
  e(node, "css_empty_declaration", "Declaration cannot be empty");
}
function css_expected_identifier(node) {
  e(node, "css_expected_identifier", "Expected a valid CSS identifier");
}
function css_global_block_invalid_combinator(node, name) {
  e(node, "css_global_block_invalid_combinator", `A \`:global\` selector cannot follow a \`${name}\` combinator`);
}
function css_global_block_invalid_declaration(node) {
  e(node, "css_global_block_invalid_declaration", "A top-level `:global {...}` block can only contain rules, not declarations");
}
function css_global_block_invalid_list(node) {
  e(node, "css_global_block_invalid_list", "A `:global` selector cannot be part of a selector list with more than one item");
}
function css_global_block_invalid_modifier(node) {
  e(node, "css_global_block_invalid_modifier", "A `:global` selector cannot modify an existing selector");
}
function css_global_block_invalid_modifier_start(node) {
  e(node, "css_global_block_invalid_modifier_start", "A `:global` selector can only be modified if it is a descendant of other selectors");
}
function css_global_invalid_placement(node) {
  e(node, "css_global_invalid_placement", "`:global(...)` can be at the start or end of a selector sequence, but not in the middle");
}
function css_global_invalid_selector(node) {
  e(node, "css_global_invalid_selector", "`:global(...)` must contain exactly one selector");
}
function css_global_invalid_selector_list(node) {
  e(node, "css_global_invalid_selector_list", "`:global(...)` must not contain type or universal selectors when used in a compound selector");
}
function css_nesting_selector_invalid_placement(node) {
  e(node, "css_nesting_selector_invalid_placement", "Nesting selectors can only be used inside a rule or as the first selector inside a lone `:global(...)`");
}
function css_selector_invalid(node) {
  e(node, "css_selector_invalid", "Invalid selector");
}
function css_type_selector_invalid_placement(node) {
  e(node, "css_type_selector_invalid_placement", "`:global(...)` must not be followed by a type selector");
}
function animation_duplicate(node) {
  e(node, "animation_duplicate", "An element can only have one 'animate' directive");
}
function animation_invalid_placement(node) {
  e(node, "animation_invalid_placement", "An element that uses the `animate:` directive must be the only child of a keyed `{#each ...}` block");
}
function animation_missing_key(node) {
  e(node, "animation_missing_key", "An element that uses the `animate:` directive must be the only child of a keyed `{#each ...}` block. Did you forget to add a key to your each block?");
}
function attribute_contenteditable_dynamic(node) {
  e(node, "attribute_contenteditable_dynamic", "'contenteditable' attribute cannot be dynamic if element uses two-way binding");
}
function attribute_contenteditable_missing(node) {
  e(node, "attribute_contenteditable_missing", "'contenteditable' attribute is required for textContent, innerHTML and innerText two-way bindings");
}
function attribute_duplicate(node) {
  e(node, "attribute_duplicate", "Attributes need to be unique");
}
function attribute_empty_shorthand(node) {
  e(node, "attribute_empty_shorthand", "Attribute shorthand cannot be empty");
}
function attribute_invalid_event_handler(node) {
  e(node, "attribute_invalid_event_handler", "Event attribute must be a JavaScript expression, not a string");
}
function attribute_invalid_multiple(node) {
  e(node, "attribute_invalid_multiple", "'multiple' attribute must be static if select uses two-way binding");
}
function attribute_invalid_name(node, name) {
  e(node, "attribute_invalid_name", `'${name}' is not a valid attribute name`);
}
function attribute_invalid_sequence_expression(node) {
  e(node, "attribute_invalid_sequence_expression", "Sequence expressions are not allowed as attribute/directive values in runes mode, unless wrapped in parentheses");
}
function attribute_invalid_type(node) {
  e(node, "attribute_invalid_type", "'type' attribute must be a static text value if input uses two-way binding");
}
function attribute_unquoted_sequence(node) {
  e(node, "attribute_unquoted_sequence", "Attribute values containing `{...}` must be enclosed in quote marks, unless the value only contains the expression");
}
function bind_invalid_expression(node) {
  e(node, "bind_invalid_expression", "Can only bind to an Identifier or MemberExpression");
}
function bind_invalid_name(node, name, explanation) {
  e(node, "bind_invalid_name", explanation ? `\`bind:${name}\` is not a valid binding. ${explanation}` : `\`bind:${name}\` is not a valid binding`);
}
function bind_invalid_target(node, name, elements) {
  e(node, "bind_invalid_target", `\`bind:${name}\` can only be used with ${elements}`);
}
function bind_invalid_value(node) {
  e(node, "bind_invalid_value", "Can only bind to state or props");
}
function block_duplicate_clause(node, name) {
  e(node, "block_duplicate_clause", `${name} cannot appear more than once within a block`);
}
function block_invalid_continuation_placement(node) {
  e(node, "block_invalid_continuation_placement", "{:...} block is invalid at this position (did you forget to close the preceding element or block?)");
}
function block_invalid_elseif(node) {
  e(node, "block_invalid_elseif", "'elseif' should be 'else if'");
}
function block_invalid_placement(node, name, location) {
  e(node, "block_invalid_placement", `{#${name} ...} block cannot be ${location}`);
}
function block_unclosed(node) {
  e(node, "block_unclosed", "Block was left open");
}
function block_unexpected_character(node, character) {
  e(node, "block_unexpected_character", `Expected a \`${character}\` character immediately following the opening bracket`);
}
function block_unexpected_close(node) {
  e(node, "block_unexpected_close", "Unexpected block closing tag");
}
function component_invalid_directive(node) {
  e(node, "component_invalid_directive", "This type of directive is not valid on components");
}
function const_tag_cycle(node, cycle) {
  e(node, "const_tag_cycle", `Cyclical dependency detected: ${cycle}`);
}
function const_tag_invalid_expression(node) {
  e(node, "const_tag_invalid_expression", "{@const ...} must consist of a single variable declaration");
}
function const_tag_invalid_placement(node) {
  e(node, "const_tag_invalid_placement", "`{@const}` must be the immediate child of `{#snippet}`, `{#if}`, `{:else if}`, `{:else}`, `{#each}`, `{:then}`, `{:catch}`, `<svelte:fragment>` or `<Component>`");
}
function debug_tag_invalid_arguments(node) {
  e(node, "debug_tag_invalid_arguments", "{@debug ...} arguments must be identifiers, not arbitrary expressions");
}
function directive_invalid_value(node) {
  e(node, "directive_invalid_value", "Directive value must be a JavaScript expression enclosed in curly braces");
}
function directive_missing_name(node, type) {
  e(node, "directive_missing_name", `\`${type}\` name cannot be empty`);
}
function element_invalid_closing_tag(node, name) {
  e(node, "element_invalid_closing_tag", `\`</${name}>\` attempted to close an element that was not open`);
}
function element_invalid_closing_tag_autoclosed(node, name, reason) {
  e(node, "element_invalid_closing_tag_autoclosed", `\`</${name}>\` attempted to close element that was already automatically closed by \`<${reason}>\` (cannot nest \`<${reason}>\` inside \`<${name}>\`)`);
}
function element_unclosed(node, name) {
  e(node, "element_unclosed", `\`<${name}>\` was left open`);
}
function event_handler_invalid_component_modifier(node) {
  e(node, "event_handler_invalid_component_modifier", "Event modifiers other than 'once' can only be used on DOM elements");
}
function event_handler_invalid_modifier(node, list3) {
  e(node, "event_handler_invalid_modifier", `Valid event modifiers are ${list3}`);
}
function event_handler_invalid_modifier_combination(node, modifier1, modifier2) {
  e(node, "event_handler_invalid_modifier_combination", `The '${modifier1}' and '${modifier2}' modifiers cannot be used together`);
}
function expected_attribute_value(node) {
  e(node, "expected_attribute_value", "Expected attribute value");
}
function expected_block_type(node) {
  e(node, "expected_block_type", "Expected 'if', 'each', 'await', 'key' or 'snippet'");
}
function expected_identifier(node) {
  e(node, "expected_identifier", "Expected an identifier");
}
function expected_pattern(node) {
  e(node, "expected_pattern", "Expected identifier or destructure pattern");
}
function expected_token(node, token) {
  e(node, "expected_token", `Expected token ${token}`);
}
function expected_whitespace(node) {
  e(node, "expected_whitespace", "Expected whitespace");
}
function js_parse_error(node, message) {
  e(node, "js_parse_error", `${message}`);
}
function let_directive_invalid_placement(node) {
  e(node, "let_directive_invalid_placement", "`let:` directive at invalid position");
}
function mixed_event_handler_syntaxes(node, name) {
  e(node, "mixed_event_handler_syntaxes", `Mixing old (on:${name}) and new syntaxes for event handling is not allowed. Use only the on${name} syntax`);
}
function node_invalid_placement(node, thing, parent) {
  e(node, "node_invalid_placement", `${thing} is invalid inside \`<${parent}>\``);
}
function render_tag_invalid_call_expression(node) {
  e(node, "render_tag_invalid_call_expression", "Calling a snippet function using apply, bind or call is not allowed");
}
function render_tag_invalid_expression(node) {
  e(node, "render_tag_invalid_expression", "`{@render ...}` tags can only contain call expressions");
}
function render_tag_invalid_spread_argument(node) {
  e(node, "render_tag_invalid_spread_argument", "cannot use spread arguments in `{@render ...}` tags");
}
function script_duplicate(node) {
  e(node, "script_duplicate", "A component can have a single top-level `<script>` element and/or a single top-level `<script module>` element");
}
function script_invalid_attribute_value(node, name) {
  e(node, "script_invalid_attribute_value", `If the \`${name}\` attribute is supplied, it must be a boolean attribute`);
}
function script_invalid_context(node) {
  e(node, "script_invalid_context", 'If the context attribute is supplied, its value must be "module"');
}
function script_reserved_attribute(node, name) {
  e(node, "script_reserved_attribute", `The \`${name}\` attribute is reserved and cannot be used`);
}
function slot_attribute_duplicate(node, name, component) {
  e(node, "slot_attribute_duplicate", `Duplicate slot name '${name}' in <${component}>`);
}
function slot_attribute_invalid(node) {
  e(node, "slot_attribute_invalid", "slot attribute must be a static value");
}
function slot_attribute_invalid_placement(node) {
  e(node, "slot_attribute_invalid_placement", "Element with a slot='...' attribute must be a child of a component or a descendant of a custom element");
}
function slot_default_duplicate(node) {
  e(node, "slot_default_duplicate", 'Found default slot content alongside an explicit slot="default"');
}
function slot_element_invalid_attribute(node) {
  e(node, "slot_element_invalid_attribute", "`<slot>` can only receive attributes and (optionally) let directives");
}
function slot_element_invalid_name(node) {
  e(node, "slot_element_invalid_name", "slot attribute must be a static value");
}
function slot_element_invalid_name_default(node) {
  e(node, "slot_element_invalid_name_default", "`default` is a reserved word — it cannot be used as a slot name");
}
function slot_snippet_conflict(node) {
  e(node, "slot_snippet_conflict", "Cannot use `<slot>` syntax and `{@render ...}` tags in the same component. Migrate towards `{@render ...}` tags completely");
}
function snippet_conflict(node) {
  e(node, "snippet_conflict", "Cannot use explicit children snippet at the same time as implicit children content. Remove either the non-whitespace content or the children snippet block");
}
function snippet_invalid_rest_parameter(node) {
  e(node, "snippet_invalid_rest_parameter", "Snippets do not support rest parameters; use an array instead");
}
function snippet_shadowing_prop(node, prop2) {
  e(node, "snippet_shadowing_prop", `This snippet is shadowing the prop \`${prop2}\` with the same name`);
}
function style_directive_invalid_modifier(node) {
  e(node, "style_directive_invalid_modifier", "`style:` directive can only use the `important` modifier");
}
function style_duplicate(node) {
  e(node, "style_duplicate", "A component can have a single top-level `<style>` element");
}
function svelte_body_illegal_attribute(node) {
  e(node, "svelte_body_illegal_attribute", "`<svelte:body>` does not support non-event attributes or spread attributes");
}
function svelte_component_invalid_this(node) {
  e(node, "svelte_component_invalid_this", "Invalid component definition — must be an `{expression}`");
}
function svelte_component_missing_this(node) {
  e(node, "svelte_component_missing_this", "`<svelte:component>` must have a 'this' attribute");
}
function svelte_element_missing_this(node) {
  e(node, "svelte_element_missing_this", "`<svelte:element>` must have a 'this' attribute with a value");
}
function svelte_fragment_invalid_attribute(node) {
  e(node, "svelte_fragment_invalid_attribute", "`<svelte:fragment>` can only have a slot attribute and (optionally) a let: directive");
}
function svelte_fragment_invalid_placement(node) {
  e(node, "svelte_fragment_invalid_placement", "`<svelte:fragment>` must be the direct child of a component");
}
function svelte_head_illegal_attribute(node) {
  e(node, "svelte_head_illegal_attribute", "`<svelte:head>` cannot have attributes nor directives");
}
function svelte_meta_duplicate(node, name) {
  e(node, "svelte_meta_duplicate", `A component can only have one \`<${name}>\` element`);
}
function svelte_meta_invalid_content(node, name) {
  e(node, "svelte_meta_invalid_content", `<${name}> cannot have children`);
}
function svelte_meta_invalid_placement(node, name) {
  e(node, "svelte_meta_invalid_placement", `\`<${name}>\` tags cannot be inside elements or blocks`);
}
function svelte_meta_invalid_tag(node, list3) {
  e(node, "svelte_meta_invalid_tag", `Valid \`<svelte:...>\` tag names are ${list3}`);
}
function svelte_options_deprecated_tag(node) {
  e(node, "svelte_options_deprecated_tag", '"tag" option is deprecated — use "customElement" instead');
}
function svelte_options_invalid_attribute(node) {
  e(node, "svelte_options_invalid_attribute", "`<svelte:options>` can only receive static attributes");
}
function svelte_options_invalid_attribute_value(node, list3) {
  e(node, "svelte_options_invalid_attribute_value", `Value must be ${list3}, if specified`);
}
function svelte_options_invalid_customelement(node) {
  e(node, "svelte_options_invalid_customelement", '"customElement" must be a string literal defining a valid custom element name or an object of the form { tag?: string; shadow?: "open" | "none"; props?: { [key: string]: { attribute?: string; reflect?: boolean; type: .. } } }');
}
function svelte_options_invalid_customelement_props(node) {
  e(node, "svelte_options_invalid_customelement_props", '"props" must be a statically analyzable object literal of the form "{ [key: string]: { attribute?: string; reflect?: boolean; type?: "String" | "Boolean" | "Number" | "Array" | "Object" }"');
}
function svelte_options_invalid_customelement_shadow(node) {
  e(node, "svelte_options_invalid_customelement_shadow", '"shadow" must be either "open" or "none"');
}
function svelte_options_invalid_tagname(node) {
  e(node, "svelte_options_invalid_tagname", "Tag name must be lowercase and hyphenated");
}
function svelte_options_reserved_tagname(node) {
  e(node, "svelte_options_reserved_tagname", "Tag name is reserved");
}
function svelte_options_unknown_attribute(node, name) {
  e(node, "svelte_options_unknown_attribute", `\`<svelte:options>\` unknown attribute '${name}'`);
}
function svelte_self_invalid_placement(node) {
  e(node, "svelte_self_invalid_placement", "`<svelte:self>` components can only exist inside `{#if}` blocks, `{#each}` blocks, `{#snippet}` blocks or slots passed to components");
}
function tag_invalid_name(node) {
  e(node, "tag_invalid_name", "Expected a valid element or component name. Components must have a valid variable name or dot notation expression");
}
function tag_invalid_placement(node, name, location) {
  e(node, "tag_invalid_placement", `{@${name} ...} tag cannot be ${location}`);
}
function textarea_invalid_content(node) {
  e(node, "textarea_invalid_content", "A `<textarea>` can have either a value attribute or (equivalently) child content, but not both");
}
function title_illegal_attribute(node) {
  e(node, "title_illegal_attribute", "`<title>` cannot have attributes nor directives");
}
function title_invalid_content(node) {
  e(node, "title_invalid_content", "`<title>` can only contain text and {tags}");
}
function transition_conflict(node, type, existing) {
  e(node, "transition_conflict", `Cannot use \`${type}:\` alongside existing \`${existing}:\` directive`);
}
function transition_duplicate(node, type) {
  e(node, "transition_duplicate", `Cannot use multiple \`${type}:\` directives on a single element`);
}
function unexpected_eof(node) {
  e(node, "unexpected_eof", "Unexpected end of input");
}
function unexpected_reserved_word(node, word) {
  e(node, "unexpected_reserved_word", `'${word}' is a reserved word in JavaScript and cannot be used here`);
}
function void_element_invalid_content(node) {
  e(node, "void_element_invalid_content", "Void elements cannot have children or closing tags");
}

// node_modules/svelte/src/compiler/phases/1-parse/read/expression.js
function read_expression(parser) {
  try {
    const node = parse_expression_at(parser.template, parser.ts, parser.index);
    let num_parens = 0;
    for (let i = parser.index; i < /** @type {number} */
    node.start; i += 1) {
      if (parser.template[i] === "(") num_parens += 1;
    }
    let index = (
      /** @type {number} */
      node.end
    );
    if (node.trailingComments !== void 0 && node.trailingComments.length > 0) {
      index = node.trailingComments.at(-1).end;
    }
    while (num_parens > 0) {
      const char = parser.template[index];
      if (char === ")") {
        num_parens -= 1;
      } else if (!regex_whitespace.test(char)) {
        expected_token(index, ")");
      }
      index += 1;
    }
    parser.index = index;
    return (
      /** @type {Expression} */
      node
    );
  } catch (err) {
    parser.acorn_error(err);
  }
}

// node_modules/svelte/src/compiler/utils/sanitize_template_string.js
function sanitize_template_string(str) {
  return str.replace(/(`|\${|\\)/g, "\\$1");
}

// node_modules/svelte/src/compiler/utils/builders.js
function array(elements = []) {
  return { type: "ArrayExpression", elements };
}
function array_pattern(elements) {
  return { type: "ArrayPattern", elements };
}
function assignment_pattern(left, right) {
  return { type: "AssignmentPattern", left, right };
}
function arrow(params, body) {
  return {
    type: "ArrowFunctionExpression",
    params,
    body,
    expression: body.type !== "BlockStatement",
    generator: false,
    async: false,
    metadata: (
      /** @type {any} */
      null
    )
    // should not be used by codegen
  };
}
function assignment(operator, left, right) {
  return { type: "AssignmentExpression", operator, left, right };
}
function async(func) {
  return { ...func, async: true };
}
function await_builder(argument) {
  return { type: "AwaitExpression", argument };
}
function binary(operator, left, right) {
  return { type: "BinaryExpression", operator, left, right };
}
function block(body) {
  return { type: "BlockStatement", body };
}
function labeled(name, body) {
  return { type: "LabeledStatement", label: id(name), body };
}
function call(callee, ...args) {
  if (typeof callee === "string") callee = id(callee);
  args = args.slice();
  let i = args.length;
  let popping = true;
  while (i--) {
    if (!args[i]) {
      if (popping) {
        args.pop();
      } else {
        args[i] = id("undefined");
      }
    } else {
      popping = false;
    }
  }
  return {
    type: "CallExpression",
    callee,
    arguments: (
      /** @type {Array<ESTree.Expression | ESTree.SpreadElement>} */
      args
    ),
    optional: false
  };
}
function maybe_call(callee, ...args) {
  const expression = (
    /** @type {ESTree.SimpleCallExpression} */
    call(callee, ...args)
  );
  expression.optional = true;
  return {
    type: "ChainExpression",
    expression
  };
}
function unary(operator, argument) {
  return { type: "UnaryExpression", argument, operator, prefix: true };
}
function conditional(test, consequent, alternate) {
  return { type: "ConditionalExpression", test, consequent, alternate };
}
function logical(operator, left, right) {
  return { type: "LogicalExpression", operator, left, right };
}
function declaration(kind, declarations) {
  return {
    type: "VariableDeclaration",
    kind,
    declarations
  };
}
function declarator(pattern, init2) {
  if (typeof pattern === "string") pattern = id(pattern);
  return { type: "VariableDeclarator", id: pattern, init: init2 };
}
var empty = {
  type: "EmptyStatement"
};
function export_default(declaration2) {
  return { type: "ExportDefaultDeclaration", declaration: declaration2 };
}
function function_declaration(id2, params, body) {
  return {
    type: "FunctionDeclaration",
    id: id2,
    params,
    body,
    generator: false,
    async: false,
    metadata: (
      /** @type {any} */
      null
    )
    // should not be used by codegen
  };
}
function get(name, body) {
  return prop("get", key(name), function_builder(null, [], block(body)));
}
function id(name) {
  return { type: "Identifier", name };
}
function private_id(name) {
  return { type: "PrivateIdentifier", name };
}
function import_namespace(local) {
  return {
    type: "ImportNamespaceSpecifier",
    local: id(local)
  };
}
function init(name, value) {
  return prop("init", key(name), value);
}
function literal(value) {
  return { type: "Literal", value };
}
function member(object4, property, computed = false, optional = false) {
  if (typeof property === "string") {
    property = id(property);
  }
  return { type: "MemberExpression", object: object4, property, computed, optional };
}
function member_id(path) {
  const parts = path.split(".");
  let expression = id(parts[0]);
  for (let i = 1; i < parts.length; i += 1) {
    expression = member(expression, id(parts[i]));
  }
  return expression;
}
function object(properties) {
  return { type: "ObjectExpression", properties };
}
function object_pattern(properties) {
  return { type: "ObjectPattern", properties };
}
function prop(kind, key2, value, computed = false) {
  return { type: "Property", kind, key: key2, value, method: false, shorthand: false, computed };
}
function prop_def(key2, value, computed = false, is_static = false) {
  return { type: "PropertyDefinition", key: key2, value, computed, static: is_static, decorators: [] };
}
function quasi(cooked, tail = false) {
  const raw = sanitize_template_string(cooked);
  return { type: "TemplateElement", value: { raw, cooked }, tail };
}
function rest(argument) {
  return { type: "RestElement", argument };
}
function sequence(expressions) {
  return { type: "SequenceExpression", expressions };
}
function set(name, body) {
  return prop("set", key(name), function_builder(null, [id("$$value")], block(body)));
}
function spread(argument) {
  return { type: "SpreadElement", argument };
}
function stmt(expression) {
  return { type: "ExpressionStatement", expression };
}
function template(elements, expressions) {
  return { type: "TemplateLiteral", quasis: elements, expressions };
}
function thunk(expression, async2 = false) {
  const fn = arrow([], expression);
  if (async2) fn.async = true;
  return unthunk(fn);
}
function unthunk(expression) {
  if (expression.type === "ArrowFunctionExpression" && expression.async === false && expression.body.type === "CallExpression" && expression.body.callee.type === "Identifier" && expression.params.length === expression.body.arguments.length && expression.params.every((param, index) => {
    const arg = (
      /** @type {ESTree.SimpleCallExpression} */
      expression.body.arguments[index]
    );
    return param.type === "Identifier" && arg.type === "Identifier" && param.name === arg.name;
  })) {
    return expression.body.callee;
  }
  return expression;
}
function new_builder(expression, ...args) {
  if (typeof expression === "string") expression = id(expression);
  return {
    callee: expression,
    arguments: args,
    type: "NewExpression"
  };
}
function update(operator, argument, prefix = false) {
  return { type: "UpdateExpression", operator, argument, prefix };
}
function do_while(test, body) {
  return { type: "DoWhileStatement", test, body };
}
var true_instance = literal(true);
var false_instance = literal(false);
var null_instane = literal(null);
var debugger_builder = {
  type: "DebuggerStatement"
};
var this_instance = {
  type: "ThisExpression"
};
function let_builder(pattern, init2) {
  return declaration("let", [declarator(pattern, init2)]);
}
function const_builder(pattern, init2) {
  return declaration("const", [declarator(pattern, init2)]);
}
function var_builder(pattern, init2) {
  return declaration("var", [declarator(pattern, init2)]);
}
function for_builder(init2, test, update2, body) {
  return { type: "ForStatement", init: init2, test, update: update2, body };
}
function method(kind, key2, params, body, computed = false, is_static = false) {
  return {
    type: "MethodDefinition",
    key: key2,
    kind,
    value: function_builder(null, params, block(body)),
    computed,
    static: is_static,
    decorators: []
  };
}
function function_builder(id2, params, body) {
  return {
    type: "FunctionExpression",
    id: id2,
    params,
    body,
    generator: false,
    async: false,
    metadata: (
      /** @type {any} */
      null
    )
    // should not be used by codegen
  };
}
function if_builder(test, consequent, alternate) {
  return { type: "IfStatement", test, consequent, alternate };
}
function import_all(as, source2) {
  return {
    type: "ImportDeclaration",
    source: literal(source2),
    specifiers: [import_namespace(as)]
  };
}
function imports(parts, source2) {
  return {
    type: "ImportDeclaration",
    source: literal(source2),
    specifiers: parts.map((p) => ({
      type: "ImportSpecifier",
      imported: id(p[0]),
      local: id(p[1])
    }))
  };
}
function return_builder(argument = null) {
  return { type: "ReturnStatement", argument };
}
function throw_error(str) {
  return {
    type: "ThrowStatement",
    argument: new_builder("Error", literal(str))
  };
}
function key(name) {
  return regex_is_valid_identifier.test(name) ? id(name) : literal(name);
}

// node_modules/svelte/src/compiler/utils/ast.js
function object2(expression) {
  while (expression.type === "MemberExpression") {
    expression = /** @type {ESTree.MemberExpression | ESTree.Identifier} */
    expression.object;
  }
  if (expression.type !== "Identifier") {
    return null;
  }
  return expression;
}
function is_text_attribute(attribute) {
  return Array.isArray(attribute.value) && attribute.value.length === 1 && attribute.value[0].type === "Text";
}
function is_expression_attribute(attribute) {
  return attribute.value !== true && !Array.isArray(attribute.value) || Array.isArray(attribute.value) && attribute.value.length === 1 && attribute.value[0].type === "ExpressionTag";
}
function get_attribute_expression(attribute) {
  return Array.isArray(attribute.value) ? (
    /** @type {AST.ExpressionTag} */
    attribute.value[0].expression
  ) : attribute.value.expression;
}
function get_attribute_chunks(value) {
  return Array.isArray(value) ? value : typeof value === "boolean" ? [] : [value];
}
function is_event_attribute(attribute) {
  return is_expression_attribute(attribute) && attribute.name.startsWith("on");
}
function unwrap_pattern(pattern, nodes = []) {
  switch (pattern.type) {
    case "Identifier":
      nodes.push(pattern);
      break;
    case "MemberExpression":
      nodes.push(pattern);
      break;
    case "ObjectPattern":
      for (const prop2 of pattern.properties) {
        if (prop2.type === "RestElement") {
          unwrap_pattern(prop2.argument, nodes);
        } else {
          unwrap_pattern(prop2.value, nodes);
        }
      }
      break;
    case "ArrayPattern":
      for (const element2 of pattern.elements) {
        if (element2) unwrap_pattern(element2, nodes);
      }
      break;
    case "RestElement":
      unwrap_pattern(pattern.argument, nodes);
      break;
    case "AssignmentPattern":
      unwrap_pattern(pattern.left, nodes);
      break;
  }
  return nodes;
}
function extract_identifiers(pattern) {
  return unwrap_pattern(pattern, []).filter((node) => node.type === "Identifier");
}
function extract_all_identifiers_from_expression(expr) {
  let nodes = [];
  let keypath = [];
  walk(
    expr,
    {},
    {
      Identifier(node, { path }) {
        const parent = path.at(-1);
        if ((parent == null ? void 0 : parent.type) !== "MemberExpression" || parent.property !== node || parent.computed) {
          nodes.push(node);
        }
        if ((parent == null ? void 0 : parent.type) === "MemberExpression" && parent.computed && parent.property === node) {
          keypath.push(`[${node.name}]`);
        } else {
          keypath.push(node.name);
        }
      },
      Literal(node, { path }) {
        const value = typeof node.value === "string" ? `"${node.value}"` : String(node.value);
        const parent = path.at(-1);
        if ((parent == null ? void 0 : parent.type) === "MemberExpression" && parent.computed && parent.property === node) {
          keypath.push(`[${value}]`);
        } else {
          keypath.push(value);
        }
      },
      ThisExpression(_, { next: next2 }) {
        keypath.push("this");
        next2();
      }
    }
  );
  return [keypath.join("."), nodes];
}
function extract_identifiers_from_destructuring(node, nodes = []) {
  switch (node.type) {
    case "Identifier":
      nodes.push(node);
      break;
    case "ObjectExpression":
      for (const prop2 of node.properties) {
        if (prop2.type === "Property") {
          extract_identifiers_from_destructuring(
            /** @type {any} */
            prop2.value,
            nodes
          );
        } else {
          extract_identifiers_from_destructuring(
            /** @type {any} */
            prop2.argument,
            nodes
          );
        }
      }
      break;
    case "ArrayExpression":
      for (const element2 of node.elements) {
        if (element2) extract_identifiers_from_destructuring(
          /** @type {any} */
          element2,
          nodes
        );
      }
      break;
  }
  return nodes;
}
function extract_paths(param) {
  return _extract_paths(
    [],
    param,
    (node) => (
      /** @type {ESTree.Identifier | ESTree.MemberExpression} */
      node
    ),
    (node) => (
      /** @type {ESTree.Identifier | ESTree.MemberExpression} */
      node
    ),
    false
  );
}
function _extract_paths(assignments = [], param, expression, update_expression, has_default_value) {
  switch (param.type) {
    case "Identifier":
    case "MemberExpression":
      assignments.push({
        node: param,
        is_rest: false,
        has_default_value,
        expression,
        update_expression
      });
      break;
    case "ObjectPattern":
      for (const prop2 of param.properties) {
        if (prop2.type === "RestElement") {
          const rest_expression = (object4) => {
            const props = [];
            for (const p of param.properties) {
              if (p.type === "Property" && p.key.type !== "PrivateIdentifier") {
                if (p.key.type === "Identifier" && !p.computed) {
                  props.push(literal(p.key.name));
                } else if (p.key.type === "Literal") {
                  props.push(literal(String(p.key.value)));
                } else {
                  props.push(call("String", p.key));
                }
              }
            }
            return call("$.exclude_from_object", expression(object4), array(props));
          };
          if (prop2.argument.type === "Identifier") {
            assignments.push({
              node: prop2.argument,
              is_rest: true,
              has_default_value,
              expression: rest_expression,
              update_expression: rest_expression
            });
          } else {
            _extract_paths(
              assignments,
              prop2.argument,
              rest_expression,
              rest_expression,
              has_default_value
            );
          }
        } else {
          const object_expression = (object4) => member(expression(object4), prop2.key, prop2.computed || prop2.key.type !== "Identifier");
          _extract_paths(
            assignments,
            prop2.value,
            object_expression,
            object_expression,
            has_default_value
          );
        }
      }
      break;
    case "ArrayPattern":
      for (let i = 0; i < param.elements.length; i += 1) {
        const element2 = param.elements[i];
        if (element2) {
          if (element2.type === "RestElement") {
            const rest_expression = (object4) => call(member(expression(object4), "slice"), literal(i));
            if (element2.argument.type === "Identifier") {
              assignments.push({
                node: element2.argument,
                is_rest: true,
                has_default_value,
                expression: rest_expression,
                update_expression: rest_expression
              });
            } else {
              _extract_paths(
                assignments,
                element2.argument,
                rest_expression,
                rest_expression,
                has_default_value
              );
            }
          } else {
            const array_expression = (object4) => member(expression(object4), literal(i), true);
            _extract_paths(
              assignments,
              element2,
              array_expression,
              array_expression,
              has_default_value
            );
          }
        }
      }
      break;
    case "AssignmentPattern": {
      const fallback_expression = (object4) => build_fallback(expression(object4), param.right);
      if (param.left.type === "Identifier") {
        assignments.push({
          node: param.left,
          is_rest: false,
          has_default_value: true,
          expression: fallback_expression,
          update_expression
        });
      } else {
        _extract_paths(assignments, param.left, fallback_expression, update_expression, true);
      }
      break;
    }
  }
  return assignments;
}
function get_parent(path, at) {
  let node = path.at(at);
  if (node.type === "TSNonNullExpression" || node.type === "TSAsExpression") {
    return (
      /** @type {T} */
      path.at(at < 0 ? at - 1 : at + 1)
    );
  }
  return (
    /** @type {T} */
    node
  );
}
function is_simple_expression(node) {
  if (node.type === "Literal" || node.type === "Identifier" || node.type === "ArrowFunctionExpression" || node.type === "FunctionExpression") {
    return true;
  }
  if (node.type === "ConditionalExpression") {
    return is_simple_expression(node.test) && is_simple_expression(node.consequent) && is_simple_expression(node.alternate);
  }
  if (node.type === "BinaryExpression" || node.type === "LogicalExpression") {
    return is_simple_expression(node.left) && is_simple_expression(node.right);
  }
  return false;
}
function unwrap_optional(node) {
  return node.type === "ChainExpression" ? node.expression : node;
}
function is_expression_async(expression) {
  switch (expression.type) {
    case "AwaitExpression": {
      return true;
    }
    case "ArrayPattern": {
      return expression.elements.some((element2) => element2 && is_expression_async(element2));
    }
    case "ArrayExpression": {
      return expression.elements.some((element2) => {
        if (!element2) {
          return false;
        } else if (element2.type === "SpreadElement") {
          return is_expression_async(element2.argument);
        } else {
          return is_expression_async(element2);
        }
      });
    }
    case "AssignmentPattern":
    case "AssignmentExpression":
    case "BinaryExpression":
    case "LogicalExpression": {
      return is_expression_async(expression.left) || is_expression_async(expression.right);
    }
    case "CallExpression":
    case "NewExpression": {
      return expression.callee.type !== "Super" && is_expression_async(expression.callee) || expression.arguments.some((element2) => {
        if (element2.type === "SpreadElement") {
          return is_expression_async(element2.argument);
        } else {
          return is_expression_async(element2);
        }
      });
    }
    case "ChainExpression": {
      return is_expression_async(expression.expression);
    }
    case "ConditionalExpression": {
      return is_expression_async(expression.test) || is_expression_async(expression.alternate) || is_expression_async(expression.consequent);
    }
    case "ImportExpression": {
      return is_expression_async(expression.source);
    }
    case "MemberExpression": {
      return expression.object.type !== "Super" && is_expression_async(expression.object) || expression.property.type !== "PrivateIdentifier" && is_expression_async(expression.property);
    }
    case "ObjectPattern":
    case "ObjectExpression": {
      return expression.properties.some((property) => {
        if (property.type === "SpreadElement") {
          return is_expression_async(property.argument);
        } else if (property.type === "Property") {
          return property.key.type !== "PrivateIdentifier" && is_expression_async(property.key) || is_expression_async(property.value);
        }
      });
    }
    case "RestElement": {
      return is_expression_async(expression.argument);
    }
    case "SequenceExpression":
    case "TemplateLiteral": {
      return expression.expressions.some((subexpression) => is_expression_async(subexpression));
    }
    case "TaggedTemplateExpression": {
      return is_expression_async(expression.tag) || is_expression_async(expression.quasi);
    }
    case "UnaryExpression":
    case "UpdateExpression": {
      return is_expression_async(expression.argument);
    }
    case "YieldExpression": {
      return expression.argument ? is_expression_async(expression.argument) : false;
    }
    default:
      return false;
  }
}
function build_fallback(expression, fallback) {
  if (is_simple_expression(fallback)) {
    return call("$.fallback", expression, fallback);
  }
  if (fallback.type === "AwaitExpression" && is_simple_expression(fallback.argument)) {
    return await_builder(call("$.fallback", expression, fallback.argument));
  }
  return is_expression_async(fallback) ? await_builder(call("$.fallback", expression, thunk(fallback, true), true_instance)) : call("$.fallback", expression, thunk(fallback), true_instance);
}
function build_assignment_value(operator, left, right) {
  return operator === "=" ? right : (
    // turn something like x += 1 into x = x + 1
    binary(
      /** @type {ESTree.BinaryOperator} */
      operator.slice(0, -1),
      left,
      right
    )
  );
}

// node_modules/svelte/src/compiler/phases/1-parse/read/script.js
var regex_closing_script_tag = /<\/script\s*>/;
var regex_starts_with_closing_script_tag = /^<\/script\s*>/;
var RESERVED_ATTRIBUTES = ["server", "client", "worker", "test", "default"];
var ALLOWED_ATTRIBUTES = ["context", "generics", "lang", "module"];
function read_script(parser, start, attributes) {
  const script_start = parser.index;
  const data = parser.read_until(regex_closing_script_tag);
  if (parser.index >= parser.template.length) {
    element_unclosed(parser.template.length, "script");
  }
  const source2 = parser.template.slice(0, script_start).replace(regex_not_newline_characters, " ") + data;
  parser.read(regex_starts_with_closing_script_tag);
  let ast;
  try {
    ast = parse(source2, parser.ts);
  } catch (err) {
    parser.acorn_error(err);
  }
  ast.start = script_start;
  let context = "default";
  for (
    const attribute of
    /** @type {AST.Attribute[]} */
    attributes
  ) {
    if (RESERVED_ATTRIBUTES.includes(attribute.name)) {
      script_reserved_attribute(attribute, attribute.name);
    }
    if (!ALLOWED_ATTRIBUTES.includes(attribute.name)) {
      script_unknown_attribute(attribute);
    }
    if (attribute.name === "module") {
      if (attribute.value !== true) {
        script_invalid_attribute_value(attribute, attribute.name);
      }
      context = "module";
    }
    if (attribute.name === "context") {
      if (attribute.value === true || !is_text_attribute(attribute)) {
        script_invalid_context(attribute);
      }
      const value = attribute.value[0].data;
      if (value !== "module") {
        script_invalid_context(attribute);
      }
      context = "module";
    }
  }
  return {
    type: "Script",
    start,
    end: parser.index,
    context,
    content: ast,
    parent: null,
    // @ts-ignore
    attributes
  };
}

// node_modules/svelte/src/compiler/phases/1-parse/read/style.js
var REGEX_MATCHER = /^[~^$*|]?=/;
var REGEX_CLOSING_BRACKET = /[\s\]]/;
var REGEX_ATTRIBUTE_FLAGS = /^[a-zA-Z]+/;
var REGEX_COMBINATOR = /^(\+|~|>|\|\|)/;
var REGEX_PERCENTAGE = /^\d+(\.\d+)?%/;
var REGEX_NTH_OF = /^(even|odd|\+?(\d+|\d*n(\s*[+-]\s*\d+)?)|-\d*n(\s*\+\s*\d+))((?=\s*[,)])|\s+of\s+)/;
var REGEX_WHITESPACE_OR_COLON = /[\s:]/;
var REGEX_LEADING_HYPHEN_OR_DIGIT = /-?\d/;
var REGEX_VALID_IDENTIFIER_CHAR = /[a-zA-Z0-9_-]/;
var REGEX_COMMENT_CLOSE = /\*\//;
var REGEX_HTML_COMMENT_CLOSE = /-->/;
function read_style(parser, start, attributes) {
  const content_start = parser.index;
  const children = read_body(parser, "</style");
  const content_end = parser.index;
  parser.read(/^<\/style\s*>/);
  return {
    type: "StyleSheet",
    start,
    end: parser.index,
    attributes,
    children,
    content: {
      start: content_start,
      end: content_end,
      styles: parser.template.slice(content_start, content_end),
      comment: null
    }
  };
}
function read_body(parser, close2) {
  const children = [];
  while (parser.index < parser.template.length) {
    allow_comment_or_whitespace(parser);
    if (parser.match(close2)) {
      return children;
    }
    if (parser.match("@")) {
      children.push(read_at_rule(parser));
    } else {
      children.push(read_rule(parser));
    }
  }
  expected_token(parser.template.length, close2);
}
function read_at_rule(parser) {
  const start = parser.index;
  parser.eat("@", true);
  const name = read_identifier(parser);
  const prelude = read_value(parser);
  let block2 = null;
  if (parser.match("{")) {
    block2 = read_block(parser);
  } else {
    parser.eat(";", true);
  }
  return {
    type: "Atrule",
    start,
    end: parser.index,
    name,
    prelude,
    block: block2
  };
}
function read_rule(parser) {
  const start = parser.index;
  return {
    type: "Rule",
    prelude: read_selector_list(parser),
    block: read_block(parser),
    start,
    end: parser.index,
    metadata: {
      parent_rule: null,
      has_local_selectors: false,
      is_global_block: false
    }
  };
}
function read_selector_list(parser, inside_pseudo_class = false) {
  const children = [];
  allow_comment_or_whitespace(parser);
  const start = parser.index;
  while (parser.index < parser.template.length) {
    children.push(read_selector(parser, inside_pseudo_class));
    const end = parser.index;
    allow_comment_or_whitespace(parser);
    if (inside_pseudo_class ? parser.match(")") : parser.match("{")) {
      return {
        type: "SelectorList",
        start,
        end,
        children
      };
    } else {
      parser.eat(",", true);
      allow_comment_or_whitespace(parser);
    }
  }
  unexpected_eof(parser.template.length);
}
function read_selector(parser, inside_pseudo_class = false) {
  const list_start = parser.index;
  const children = [];
  function create_selector(combinator, start) {
    return {
      type: "RelativeSelector",
      combinator,
      selectors: [],
      start,
      end: -1,
      metadata: {
        is_global: false,
        is_global_like: false,
        scoped: false
      }
    };
  }
  let relative_selector = create_selector(null, parser.index);
  while (parser.index < parser.template.length) {
    let start = parser.index;
    if (parser.eat("&")) {
      relative_selector.selectors.push({
        type: "NestingSelector",
        name: "&",
        start,
        end: parser.index
      });
    } else if (parser.eat("*")) {
      let name = "*";
      if (parser.eat("|")) {
        name = read_identifier(parser);
      }
      relative_selector.selectors.push({
        type: "TypeSelector",
        name,
        start,
        end: parser.index
      });
    } else if (parser.eat("#")) {
      relative_selector.selectors.push({
        type: "IdSelector",
        name: read_identifier(parser),
        start,
        end: parser.index
      });
    } else if (parser.eat(".")) {
      relative_selector.selectors.push({
        type: "ClassSelector",
        name: read_identifier(parser),
        start,
        end: parser.index
      });
    } else if (parser.eat("::")) {
      relative_selector.selectors.push({
        type: "PseudoElementSelector",
        name: read_identifier(parser),
        start,
        end: parser.index
      });
      if (parser.eat("(")) {
        read_selector_list(parser, true);
        parser.eat(")", true);
      }
    } else if (parser.eat(":")) {
      const name = read_identifier(parser);
      let args = null;
      if (parser.eat("(")) {
        args = read_selector_list(parser, true);
        parser.eat(")", true);
      }
      relative_selector.selectors.push({
        type: "PseudoClassSelector",
        name,
        args,
        start,
        end: parser.index
      });
    } else if (parser.eat("[")) {
      parser.allow_whitespace();
      const name = read_identifier(parser);
      parser.allow_whitespace();
      let value = null;
      const matcher = parser.read(REGEX_MATCHER);
      if (matcher) {
        parser.allow_whitespace();
        value = read_attribute_value(parser);
      }
      parser.allow_whitespace();
      const flags = parser.read(REGEX_ATTRIBUTE_FLAGS);
      parser.allow_whitespace();
      parser.eat("]", true);
      relative_selector.selectors.push({
        type: "AttributeSelector",
        start,
        end: parser.index,
        name,
        matcher,
        value,
        flags
      });
    } else if (inside_pseudo_class && parser.match_regex(REGEX_NTH_OF)) {
      relative_selector.selectors.push({
        type: "Nth",
        value: (
          /**@type {string} */
          parser.read(REGEX_NTH_OF)
        ),
        start,
        end: parser.index
      });
    } else if (parser.match_regex(REGEX_PERCENTAGE)) {
      relative_selector.selectors.push({
        type: "Percentage",
        value: (
          /** @type {string} */
          parser.read(REGEX_PERCENTAGE)
        ),
        start,
        end: parser.index
      });
    } else if (!parser.match_regex(REGEX_COMBINATOR)) {
      let name = read_identifier(parser);
      if (parser.eat("|")) {
        name = read_identifier(parser);
      }
      relative_selector.selectors.push({
        type: "TypeSelector",
        name,
        start,
        end: parser.index
      });
    }
    const index = parser.index;
    allow_comment_or_whitespace(parser);
    if (parser.match(",") || (inside_pseudo_class ? parser.match(")") : parser.match("{"))) {
      parser.index = index;
      relative_selector.end = index;
      children.push(relative_selector);
      return {
        type: "ComplexSelector",
        start: list_start,
        end: index,
        children,
        metadata: {
          rule: null,
          used: false
        }
      };
    }
    parser.index = index;
    const combinator = read_combinator(parser);
    if (combinator) {
      if (relative_selector.selectors.length > 0) {
        relative_selector.end = index;
        children.push(relative_selector);
      }
      relative_selector = create_selector(combinator, combinator.start);
      parser.allow_whitespace();
      if (parser.match(",") || (inside_pseudo_class ? parser.match(")") : parser.match("{"))) {
        css_selector_invalid(parser.index);
      }
    }
  }
  unexpected_eof(parser.template.length);
}
function read_combinator(parser) {
  const start = parser.index;
  parser.allow_whitespace();
  const index = parser.index;
  const name = parser.read(REGEX_COMBINATOR);
  if (name) {
    const end = parser.index;
    parser.allow_whitespace();
    return {
      type: "Combinator",
      name,
      start: index,
      end
    };
  }
  if (parser.index !== start) {
    return {
      type: "Combinator",
      name: " ",
      start,
      end: parser.index
    };
  }
  return null;
}
function read_block(parser) {
  const start = parser.index;
  parser.eat("{", true);
  const children = [];
  while (parser.index < parser.template.length) {
    allow_comment_or_whitespace(parser);
    if (parser.match("}")) {
      break;
    } else {
      children.push(read_block_item(parser));
    }
  }
  parser.eat("}", true);
  return {
    type: "Block",
    start,
    end: parser.index,
    children
  };
}
function read_block_item(parser) {
  if (parser.match("@")) {
    return read_at_rule(parser);
  }
  const start = parser.index;
  read_value(parser);
  const char = parser.template[parser.index];
  parser.index = start;
  return char === "{" ? read_rule(parser) : read_declaration(parser);
}
function read_declaration(parser) {
  const start = parser.index;
  const property = parser.read_until(REGEX_WHITESPACE_OR_COLON);
  parser.allow_whitespace();
  parser.eat(":");
  let index = parser.index;
  parser.allow_whitespace();
  const value = read_value(parser);
  if (!value && !property.startsWith("--")) {
    css_empty_declaration({ start, end: index });
  }
  const end = parser.index;
  if (!parser.match("}")) {
    parser.eat(";", true);
  }
  return {
    type: "Declaration",
    start,
    end,
    property,
    value
  };
}
function read_value(parser) {
  let value = "";
  let escaped = false;
  let in_url = false;
  let quote_mark = null;
  while (parser.index < parser.template.length) {
    const char = parser.template[parser.index];
    if (escaped) {
      value += "\\" + char;
      escaped = false;
    } else if (char === "\\") {
      escaped = true;
    } else if (char === quote_mark) {
      quote_mark = null;
    } else if (char === ")") {
      in_url = false;
    } else if (quote_mark === null && (char === '"' || char === "'")) {
      quote_mark = char;
    } else if (char === "(" && value.slice(-3) === "url") {
      in_url = true;
    } else if ((char === ";" || char === "{" || char === "}") && !in_url && !quote_mark) {
      return value.trim();
    }
    value += char;
    parser.index++;
  }
  unexpected_eof(parser.template.length);
}
function read_attribute_value(parser) {
  let value = "";
  let escaped = false;
  const quote_mark = parser.eat('"') ? '"' : parser.eat("'") ? "'" : null;
  while (parser.index < parser.template.length) {
    const char = parser.template[parser.index];
    if (escaped) {
      value += "\\" + char;
      escaped = false;
    } else if (char === "\\") {
      escaped = true;
    } else if (quote_mark ? char === quote_mark : REGEX_CLOSING_BRACKET.test(char)) {
      if (quote_mark) {
        parser.eat(quote_mark, true);
      }
      return value.trim();
    } else {
      value += char;
    }
    parser.index++;
  }
  unexpected_eof(parser.template.length);
}
function read_identifier(parser) {
  const start = parser.index;
  let identifier = "";
  if (parser.match("--") || parser.match_regex(REGEX_LEADING_HYPHEN_OR_DIGIT)) {
    css_expected_identifier(start);
  }
  let escaped = false;
  while (parser.index < parser.template.length) {
    const char = parser.template[parser.index];
    if (escaped) {
      identifier += "\\" + char;
      escaped = false;
    } else if (char === "\\") {
      escaped = true;
    } else if (
      /** @type {number} */
      char.codePointAt(0) >= 160 || REGEX_VALID_IDENTIFIER_CHAR.test(char)
    ) {
      identifier += char;
    } else {
      break;
    }
    parser.index++;
  }
  if (identifier === "") {
    css_expected_identifier(start);
  }
  return identifier;
}
function allow_comment_or_whitespace(parser) {
  parser.allow_whitespace();
  while (parser.match("/*") || parser.match("<!--")) {
    if (parser.eat("/*")) {
      parser.read_until(REGEX_COMMENT_CLOSE);
      parser.eat("*/", true);
    }
    if (parser.eat("<!--")) {
      parser.read_until(REGEX_HTML_COMMENT_CLOSE);
      parser.eat("-->", true);
    }
    parser.allow_whitespace();
  }
}

// node_modules/svelte/src/compiler/phases/1-parse/utils/entities.js
var entities_default = {
  "CounterClockwiseContourIntegral;": 8755,
  "ClockwiseContourIntegral;": 8754,
  "DoubleLongLeftRightArrow;": 10234,
  "NotNestedGreaterGreater;": 10914,
  "DiacriticalDoubleAcute;": 733,
  "NotSquareSupersetEqual;": 8931,
  "CloseCurlyDoubleQuote;": 8221,
  "DoubleContourIntegral;": 8751,
  "FilledVerySmallSquare;": 9642,
  "NegativeVeryThinSpace;": 8203,
  "NotPrecedesSlantEqual;": 8928,
  "NotRightTriangleEqual;": 8941,
  "NotSucceedsSlantEqual;": 8929,
  "CapitalDifferentialD;": 8517,
  "DoubleLeftRightArrow;": 8660,
  "DoubleLongRightArrow;": 10233,
  "EmptyVerySmallSquare;": 9643,
  "NestedGreaterGreater;": 8811,
  "NotDoubleVerticalBar;": 8742,
  "NotGreaterSlantEqual;": 10878,
  "NotLeftTriangleEqual;": 8940,
  "NotSquareSubsetEqual;": 8930,
  "OpenCurlyDoubleQuote;": 8220,
  "ReverseUpEquilibrium;": 10607,
  "DoubleLongLeftArrow;": 10232,
  "DownLeftRightVector;": 10576,
  "LeftArrowRightArrow;": 8646,
  "NegativeMediumSpace;": 8203,
  "NotGreaterFullEqual;": 8807,
  "NotRightTriangleBar;": 10704,
  "RightArrowLeftArrow;": 8644,
  "SquareSupersetEqual;": 8850,
  "leftrightsquigarrow;": 8621,
  "DownRightTeeVector;": 10591,
  "DownRightVectorBar;": 10583,
  "LongLeftRightArrow;": 10231,
  "Longleftrightarrow;": 10234,
  "NegativeThickSpace;": 8203,
  "NotLeftTriangleBar;": 10703,
  "PrecedesSlantEqual;": 8828,
  "ReverseEquilibrium;": 8651,
  "RightDoubleBracket;": 10215,
  "RightDownTeeVector;": 10589,
  "RightDownVectorBar;": 10581,
  "RightTriangleEqual;": 8885,
  "SquareIntersection;": 8851,
  "SucceedsSlantEqual;": 8829,
  "blacktriangleright;": 9656,
  "longleftrightarrow;": 10231,
  "DoubleUpDownArrow;": 8661,
  "DoubleVerticalBar;": 8741,
  "DownLeftTeeVector;": 10590,
  "DownLeftVectorBar;": 10582,
  "FilledSmallSquare;": 9724,
  "GreaterSlantEqual;": 10878,
  "LeftDoubleBracket;": 10214,
  "LeftDownTeeVector;": 10593,
  "LeftDownVectorBar;": 10585,
  "LeftTriangleEqual;": 8884,
  "NegativeThinSpace;": 8203,
  "NotGreaterGreater;": 8811,
  "NotLessSlantEqual;": 10877,
  "NotNestedLessLess;": 10913,
  "NotReverseElement;": 8716,
  "NotSquareSuperset;": 8848,
  "NotTildeFullEqual;": 8775,
  "RightAngleBracket;": 10217,
  "RightUpDownVector;": 10575,
  "SquareSubsetEqual;": 8849,
  "VerticalSeparator;": 10072,
  "blacktriangledown;": 9662,
  "blacktriangleleft;": 9666,
  "leftrightharpoons;": 8651,
  "rightleftharpoons;": 8652,
  "twoheadrightarrow;": 8608,
  "DiacriticalAcute;": 180,
  "DiacriticalGrave;": 96,
  "DiacriticalTilde;": 732,
  "DoubleRightArrow;": 8658,
  "DownArrowUpArrow;": 8693,
  "EmptySmallSquare;": 9723,
  "GreaterEqualLess;": 8923,
  "GreaterFullEqual;": 8807,
  "LeftAngleBracket;": 10216,
  "LeftUpDownVector;": 10577,
  "LessEqualGreater;": 8922,
  "NonBreakingSpace;": 160,
  "NotPrecedesEqual;": 10927,
  "NotRightTriangle;": 8939,
  "NotSucceedsEqual;": 10928,
  "NotSucceedsTilde;": 8831,
  "NotSupersetEqual;": 8841,
  "RightTriangleBar;": 10704,
  "RightUpTeeVector;": 10588,
  "RightUpVectorBar;": 10580,
  "UnderParenthesis;": 9181,
  "UpArrowDownArrow;": 8645,
  "circlearrowright;": 8635,
  "downharpoonright;": 8642,
  "ntrianglerighteq;": 8941,
  "rightharpoondown;": 8641,
  "rightrightarrows;": 8649,
  "twoheadleftarrow;": 8606,
  "vartriangleright;": 8883,
  "CloseCurlyQuote;": 8217,
  "ContourIntegral;": 8750,
  "DoubleDownArrow;": 8659,
  "DoubleLeftArrow;": 8656,
  "DownRightVector;": 8641,
  "LeftRightVector;": 10574,
  "LeftTriangleBar;": 10703,
  "LeftUpTeeVector;": 10592,
  "LeftUpVectorBar;": 10584,
  "LowerRightArrow;": 8600,
  "NotGreaterEqual;": 8817,
  "NotGreaterTilde;": 8821,
  "NotHumpDownHump;": 8782,
  "NotLeftTriangle;": 8938,
  "NotSquareSubset;": 8847,
  "OverParenthesis;": 9180,
  "RightDownVector;": 8642,
  "ShortRightArrow;": 8594,
  "UpperRightArrow;": 8599,
  "bigtriangledown;": 9661,
  "circlearrowleft;": 8634,
  "curvearrowright;": 8631,
  "downharpoonleft;": 8643,
  "leftharpoondown;": 8637,
  "leftrightarrows;": 8646,
  "nLeftrightarrow;": 8654,
  "nleftrightarrow;": 8622,
  "ntrianglelefteq;": 8940,
  "rightleftarrows;": 8644,
  "rightsquigarrow;": 8605,
  "rightthreetimes;": 8908,
  "straightepsilon;": 1013,
  "trianglerighteq;": 8885,
  "vartriangleleft;": 8882,
  "DiacriticalDot;": 729,
  "DoubleRightTee;": 8872,
  "DownLeftVector;": 8637,
  "GreaterGreater;": 10914,
  "HorizontalLine;": 9472,
  "InvisibleComma;": 8291,
  "InvisibleTimes;": 8290,
  "LeftDownVector;": 8643,
  "LeftRightArrow;": 8596,
  "Leftrightarrow;": 8660,
  "LessSlantEqual;": 10877,
  "LongRightArrow;": 10230,
  "Longrightarrow;": 10233,
  "LowerLeftArrow;": 8601,
  "NestedLessLess;": 8810,
  "NotGreaterLess;": 8825,
  "NotLessGreater;": 8824,
  "NotSubsetEqual;": 8840,
  "NotVerticalBar;": 8740,
  "OpenCurlyQuote;": 8216,
  "ReverseElement;": 8715,
  "RightTeeVector;": 10587,
  "RightVectorBar;": 10579,
  "ShortDownArrow;": 8595,
  "ShortLeftArrow;": 8592,
  "SquareSuperset;": 8848,
  "TildeFullEqual;": 8773,
  "UpperLeftArrow;": 8598,
  "ZeroWidthSpace;": 8203,
  "curvearrowleft;": 8630,
  "doublebarwedge;": 8966,
  "downdownarrows;": 8650,
  "hookrightarrow;": 8618,
  "leftleftarrows;": 8647,
  "leftrightarrow;": 8596,
  "leftthreetimes;": 8907,
  "longrightarrow;": 10230,
  "looparrowright;": 8620,
  "nshortparallel;": 8742,
  "ntriangleright;": 8939,
  "rightarrowtail;": 8611,
  "rightharpoonup;": 8640,
  "trianglelefteq;": 8884,
  "upharpoonright;": 8638,
  "ApplyFunction;": 8289,
  "DifferentialD;": 8518,
  "DoubleLeftTee;": 10980,
  "DoubleUpArrow;": 8657,
  "LeftTeeVector;": 10586,
  "LeftVectorBar;": 10578,
  "LessFullEqual;": 8806,
  "LongLeftArrow;": 10229,
  "Longleftarrow;": 10232,
  "NotEqualTilde;": 8770,
  "NotTildeEqual;": 8772,
  "NotTildeTilde;": 8777,
  "Poincareplane;": 8460,
  "PrecedesEqual;": 10927,
  "PrecedesTilde;": 8830,
  "RightArrowBar;": 8677,
  "RightTeeArrow;": 8614,
  "RightTriangle;": 8883,
  "RightUpVector;": 8638,
  "SucceedsEqual;": 10928,
  "SucceedsTilde;": 8831,
  "SupersetEqual;": 8839,
  "UpEquilibrium;": 10606,
  "VerticalTilde;": 8768,
  "VeryThinSpace;": 8202,
  "bigtriangleup;": 9651,
  "blacktriangle;": 9652,
  "divideontimes;": 8903,
  "fallingdotseq;": 8786,
  "hookleftarrow;": 8617,
  "leftarrowtail;": 8610,
  "leftharpoonup;": 8636,
  "longleftarrow;": 10229,
  "looparrowleft;": 8619,
  "measuredangle;": 8737,
  "ntriangleleft;": 8938,
  "shortparallel;": 8741,
  "smallsetminus;": 8726,
  "triangleright;": 9657,
  "upharpoonleft;": 8639,
  "varsubsetneqq;": 10955,
  "varsupsetneqq;": 10956,
  "DownArrowBar;": 10515,
  "DownTeeArrow;": 8615,
  "ExponentialE;": 8519,
  "GreaterEqual;": 8805,
  "GreaterTilde;": 8819,
  "HilbertSpace;": 8459,
  "HumpDownHump;": 8782,
  "Intersection;": 8898,
  "LeftArrowBar;": 8676,
  "LeftTeeArrow;": 8612,
  "LeftTriangle;": 8882,
  "LeftUpVector;": 8639,
  "NotCongruent;": 8802,
  "NotHumpEqual;": 8783,
  "NotLessEqual;": 8816,
  "NotLessTilde;": 8820,
  "Proportional;": 8733,
  "RightCeiling;": 8969,
  "RoundImplies;": 10608,
  "ShortUpArrow;": 8593,
  "SquareSubset;": 8847,
  "UnderBracket;": 9141,
  "VerticalLine;": 124,
  "blacklozenge;": 10731,
  "exponentiale;": 8519,
  "risingdotseq;": 8787,
  "triangledown;": 9663,
  "triangleleft;": 9667,
  "varsubsetneq;": 8842,
  "varsupsetneq;": 8843,
  "CircleMinus;": 8854,
  "CircleTimes;": 8855,
  "Equilibrium;": 8652,
  "GreaterLess;": 8823,
  "LeftCeiling;": 8968,
  "LessGreater;": 8822,
  "MediumSpace;": 8287,
  "NotLessLess;": 8810,
  "NotPrecedes;": 8832,
  "NotSucceeds;": 8833,
  "NotSuperset;": 8835,
  "OverBracket;": 9140,
  "RightVector;": 8640,
  "Rrightarrow;": 8667,
  "RuleDelayed;": 10740,
  "SmallCircle;": 8728,
  "SquareUnion;": 8852,
  "SubsetEqual;": 8838,
  "UpDownArrow;": 8597,
  "Updownarrow;": 8661,
  "VerticalBar;": 8739,
  "backepsilon;": 1014,
  "blacksquare;": 9642,
  "circledcirc;": 8858,
  "circleddash;": 8861,
  "curlyeqprec;": 8926,
  "curlyeqsucc;": 8927,
  "diamondsuit;": 9830,
  "eqslantless;": 10901,
  "expectation;": 8496,
  "nRightarrow;": 8655,
  "nrightarrow;": 8603,
  "preccurlyeq;": 8828,
  "precnapprox;": 10937,
  "quaternions;": 8461,
  "straightphi;": 981,
  "succcurlyeq;": 8829,
  "succnapprox;": 10938,
  "thickapprox;": 8776,
  "updownarrow;": 8597,
  "Bernoullis;": 8492,
  "CirclePlus;": 8853,
  "EqualTilde;": 8770,
  "Fouriertrf;": 8497,
  "ImaginaryI;": 8520,
  "Laplacetrf;": 8466,
  "LeftVector;": 8636,
  "Lleftarrow;": 8666,
  "NotElement;": 8713,
  "NotGreater;": 8815,
  "Proportion;": 8759,
  "RightArrow;": 8594,
  "RightFloor;": 8971,
  "Rightarrow;": 8658,
  "ThickSpace;": 8287,
  "TildeEqual;": 8771,
  "TildeTilde;": 8776,
  "UnderBrace;": 9183,
  "UpArrowBar;": 10514,
  "UpTeeArrow;": 8613,
  "circledast;": 8859,
  "complement;": 8705,
  "curlywedge;": 8911,
  "eqslantgtr;": 10902,
  "gtreqqless;": 10892,
  "lessapprox;": 10885,
  "lesseqqgtr;": 10891,
  "lmoustache;": 9136,
  "longmapsto;": 10236,
  "mapstodown;": 8615,
  "mapstoleft;": 8612,
  "nLeftarrow;": 8653,
  "nleftarrow;": 8602,
  "nsubseteqq;": 10949,
  "nsupseteqq;": 10950,
  "precapprox;": 10935,
  "rightarrow;": 8594,
  "rmoustache;": 9137,
  "sqsubseteq;": 8849,
  "sqsupseteq;": 8850,
  "subsetneqq;": 10955,
  "succapprox;": 10936,
  "supsetneqq;": 10956,
  "upuparrows;": 8648,
  "varepsilon;": 1013,
  "varnothing;": 8709,
  "Backslash;": 8726,
  "CenterDot;": 183,
  "CircleDot;": 8857,
  "Congruent;": 8801,
  "Coproduct;": 8720,
  "DoubleDot;": 168,
  "DownArrow;": 8595,
  "DownBreve;": 785,
  "Downarrow;": 8659,
  "HumpEqual;": 8783,
  "LeftArrow;": 8592,
  "LeftFloor;": 8970,
  "Leftarrow;": 8656,
  "LessTilde;": 8818,
  "Mellintrf;": 8499,
  "MinusPlus;": 8723,
  "NotCupCap;": 8813,
  "NotExists;": 8708,
  "NotSubset;": 8834,
  "OverBrace;": 9182,
  "PlusMinus;": 177,
  "Therefore;": 8756,
  "ThinSpace;": 8201,
  "TripleDot;": 8411,
  "UnionPlus;": 8846,
  "backprime;": 8245,
  "backsimeq;": 8909,
  "bigotimes;": 10754,
  "centerdot;": 183,
  "checkmark;": 10003,
  "complexes;": 8450,
  "dotsquare;": 8865,
  "downarrow;": 8595,
  "gtrapprox;": 10886,
  "gtreqless;": 8923,
  "gvertneqq;": 8809,
  "heartsuit;": 9829,
  "leftarrow;": 8592,
  "lesseqgtr;": 8922,
  "lvertneqq;": 8808,
  "ngeqslant;": 10878,
  "nleqslant;": 10877,
  "nparallel;": 8742,
  "nshortmid;": 8740,
  "nsubseteq;": 8840,
  "nsupseteq;": 8841,
  "pitchfork;": 8916,
  "rationals;": 8474,
  "spadesuit;": 9824,
  "subseteqq;": 10949,
  "subsetneq;": 8842,
  "supseteqq;": 10950,
  "supsetneq;": 8843,
  "therefore;": 8756,
  "triangleq;": 8796,
  "varpropto;": 8733,
  "DDotrahd;": 10513,
  "DotEqual;": 8784,
  "Integral;": 8747,
  "LessLess;": 10913,
  "NotEqual;": 8800,
  "NotTilde;": 8769,
  "PartialD;": 8706,
  "Precedes;": 8826,
  "RightTee;": 8866,
  "Succeeds;": 8827,
  "SuchThat;": 8715,
  "Superset;": 8835,
  "Uarrocir;": 10569,
  "UnderBar;": 95,
  "andslope;": 10840,
  "angmsdaa;": 10664,
  "angmsdab;": 10665,
  "angmsdac;": 10666,
  "angmsdad;": 10667,
  "angmsdae;": 10668,
  "angmsdaf;": 10669,
  "angmsdag;": 10670,
  "angmsdah;": 10671,
  "angrtvbd;": 10653,
  "approxeq;": 8778,
  "awconint;": 8755,
  "backcong;": 8780,
  "barwedge;": 8965,
  "bbrktbrk;": 9142,
  "bigoplus;": 10753,
  "bigsqcup;": 10758,
  "biguplus;": 10756,
  "bigwedge;": 8896,
  "boxminus;": 8863,
  "boxtimes;": 8864,
  "bsolhsub;": 10184,
  "capbrcup;": 10825,
  "circledR;": 174,
  "circledS;": 9416,
  "cirfnint;": 10768,
  "clubsuit;": 9827,
  "cupbrcap;": 10824,
  "curlyvee;": 8910,
  "cwconint;": 8754,
  "doteqdot;": 8785,
  "dotminus;": 8760,
  "drbkarow;": 10512,
  "dzigrarr;": 10239,
  "elinters;": 9191,
  "emptyset;": 8709,
  "eqvparsl;": 10725,
  "fpartint;": 10765,
  "geqslant;": 10878,
  "gesdotol;": 10884,
  "gnapprox;": 10890,
  "hksearow;": 10533,
  "hkswarow;": 10534,
  "imagline;": 8464,
  "imagpart;": 8465,
  "infintie;": 10717,
  "integers;": 8484,
  "intercal;": 8890,
  "intlarhk;": 10775,
  "laemptyv;": 10676,
  "ldrushar;": 10571,
  "leqslant;": 10877,
  "lesdotor;": 10883,
  "llcorner;": 8990,
  "lnapprox;": 10889,
  "lrcorner;": 8991,
  "lurdshar;": 10570,
  "mapstoup;": 8613,
  "multimap;": 8888,
  "naturals;": 8469,
  "ncongdot;": 10861,
  "notindot;": 8949,
  "otimesas;": 10806,
  "parallel;": 8741,
  "plusacir;": 10787,
  "pointint;": 10773,
  "precneqq;": 10933,
  "precnsim;": 8936,
  "profalar;": 9006,
  "profline;": 8978,
  "profsurf;": 8979,
  "raemptyv;": 10675,
  "realpart;": 8476,
  "rppolint;": 10770,
  "rtriltri;": 10702,
  "scpolint;": 10771,
  "setminus;": 8726,
  "shortmid;": 8739,
  "smeparsl;": 10724,
  "sqsubset;": 8847,
  "sqsupset;": 8848,
  "subseteq;": 8838,
  "succneqq;": 10934,
  "succnsim;": 8937,
  "supseteq;": 8839,
  "thetasym;": 977,
  "thicksim;": 8764,
  "timesbar;": 10801,
  "triangle;": 9653,
  "triminus;": 10810,
  "trpezium;": 9186,
  "ulcorner;": 8988,
  "urcorner;": 8989,
  "varkappa;": 1008,
  "varsigma;": 962,
  "vartheta;": 977,
  "Because;": 8757,
  "Cayleys;": 8493,
  "Cconint;": 8752,
  "Cedilla;": 184,
  "Diamond;": 8900,
  "DownTee;": 8868,
  "Element;": 8712,
  "Epsilon;": 917,
  "Implies;": 8658,
  "LeftTee;": 8867,
  "NewLine;": 10,
  "NoBreak;": 8288,
  "NotLess;": 8814,
  "Omicron;": 927,
  "OverBar;": 8254,
  "Product;": 8719,
  "UpArrow;": 8593,
  "Uparrow;": 8657,
  "Upsilon;": 933,
  "alefsym;": 8501,
  "angrtvb;": 8894,
  "angzarr;": 9084,
  "asympeq;": 8781,
  "backsim;": 8765,
  "because;": 8757,
  "bemptyv;": 10672,
  "between;": 8812,
  "bigcirc;": 9711,
  "bigodot;": 10752,
  "bigstar;": 9733,
  "bnequiv;": 8801,
  "boxplus;": 8862,
  "ccupssm;": 10832,
  "cemptyv;": 10674,
  "cirscir;": 10690,
  "coloneq;": 8788,
  "congdot;": 10861,
  "cudarrl;": 10552,
  "cudarrr;": 10549,
  "cularrp;": 10557,
  "curarrm;": 10556,
  "dbkarow;": 10511,
  "ddagger;": 8225,
  "ddotseq;": 10871,
  "demptyv;": 10673,
  "diamond;": 8900,
  "digamma;": 989,
  "dotplus;": 8724,
  "dwangle;": 10662,
  "epsilon;": 949,
  "eqcolon;": 8789,
  "equivDD;": 10872,
  "gesdoto;": 10882,
  "gtquest;": 10876,
  "gtrless;": 8823,
  "harrcir;": 10568,
  "intprod;": 10812,
  "isindot;": 8949,
  "larrbfs;": 10527,
  "larrsim;": 10611,
  "lbrksld;": 10639,
  "lbrkslu;": 10637,
  "ldrdhar;": 10599,
  "lesdoto;": 10881,
  "lessdot;": 8918,
  "lessgtr;": 8822,
  "lesssim;": 8818,
  "lotimes;": 10804,
  "lozenge;": 9674,
  "ltquest;": 10875,
  "luruhar;": 10598,
  "maltese;": 10016,
  "minusdu;": 10794,
  "napprox;": 8777,
  "natural;": 9838,
  "nearrow;": 8599,
  "nexists;": 8708,
  "notinva;": 8713,
  "notinvb;": 8951,
  "notinvc;": 8950,
  "notniva;": 8716,
  "notnivb;": 8958,
  "notnivc;": 8957,
  "npolint;": 10772,
  "npreceq;": 10927,
  "nsqsube;": 8930,
  "nsqsupe;": 8931,
  "nsubset;": 8834,
  "nsucceq;": 10928,
  "nsupset;": 8835,
  "nvinfin;": 10718,
  "nvltrie;": 8884,
  "nvrtrie;": 8885,
  "nwarrow;": 8598,
  "olcross;": 10683,
  "omicron;": 959,
  "orderof;": 8500,
  "orslope;": 10839,
  "pertenk;": 8241,
  "planckh;": 8462,
  "pluscir;": 10786,
  "plussim;": 10790,
  "plustwo;": 10791,
  "precsim;": 8830,
  "quatint;": 10774,
  "questeq;": 8799,
  "rarrbfs;": 10528,
  "rarrsim;": 10612,
  "rbrksld;": 10638,
  "rbrkslu;": 10640,
  "rdldhar;": 10601,
  "realine;": 8475,
  "rotimes;": 10805,
  "ruluhar;": 10600,
  "searrow;": 8600,
  "simplus;": 10788,
  "simrarr;": 10610,
  "subedot;": 10947,
  "submult;": 10945,
  "subplus;": 10943,
  "subrarr;": 10617,
  "succsim;": 8831,
  "supdsub;": 10968,
  "supedot;": 10948,
  "suphsol;": 10185,
  "suphsub;": 10967,
  "suplarr;": 10619,
  "supmult;": 10946,
  "supplus;": 10944,
  "swarrow;": 8601,
  "topfork;": 10970,
  "triplus;": 10809,
  "tritime;": 10811,
  "uparrow;": 8593,
  "upsilon;": 965,
  "uwangle;": 10663,
  "vzigzag;": 10650,
  "zigrarr;": 8669,
  "Aacute;": 193,
  "Abreve;": 258,
  "Agrave;": 192,
  "Assign;": 8788,
  "Atilde;": 195,
  "Barwed;": 8966,
  "Bumpeq;": 8782,
  "Cacute;": 262,
  "Ccaron;": 268,
  "Ccedil;": 199,
  "Colone;": 10868,
  "Conint;": 8751,
  "CupCap;": 8781,
  "Dagger;": 8225,
  "Dcaron;": 270,
  "DotDot;": 8412,
  "Dstrok;": 272,
  "Eacute;": 201,
  "Ecaron;": 282,
  "Egrave;": 200,
  "Exists;": 8707,
  "ForAll;": 8704,
  "Gammad;": 988,
  "Gbreve;": 286,
  "Gcedil;": 290,
  "HARDcy;": 1066,
  "Hstrok;": 294,
  "Iacute;": 205,
  "Igrave;": 204,
  "Itilde;": 296,
  "Jsercy;": 1032,
  "Kcedil;": 310,
  "Lacute;": 313,
  "Lambda;": 923,
  "Lcaron;": 317,
  "Lcedil;": 315,
  "Lmidot;": 319,
  "Lstrok;": 321,
  "Nacute;": 323,
  "Ncaron;": 327,
  "Ncedil;": 325,
  "Ntilde;": 209,
  "Oacute;": 211,
  "Odblac;": 336,
  "Ograve;": 210,
  "Oslash;": 216,
  "Otilde;": 213,
  "Otimes;": 10807,
  "Racute;": 340,
  "Rarrtl;": 10518,
  "Rcaron;": 344,
  "Rcedil;": 342,
  "SHCHcy;": 1065,
  "SOFTcy;": 1068,
  "Sacute;": 346,
  "Scaron;": 352,
  "Scedil;": 350,
  "Square;": 9633,
  "Subset;": 8912,
  "Supset;": 8913,
  "Tcaron;": 356,
  "Tcedil;": 354,
  "Tstrok;": 358,
  "Uacute;": 218,
  "Ubreve;": 364,
  "Udblac;": 368,
  "Ugrave;": 217,
  "Utilde;": 360,
  "Vdashl;": 10982,
  "Verbar;": 8214,
  "Vvdash;": 8874,
  "Yacute;": 221,
  "Zacute;": 377,
  "Zcaron;": 381,
  "aacute;": 225,
  "abreve;": 259,
  "agrave;": 224,
  "andand;": 10837,
  "angmsd;": 8737,
  "angsph;": 8738,
  "apacir;": 10863,
  "approx;": 8776,
  "atilde;": 227,
  "barvee;": 8893,
  "barwed;": 8965,
  "becaus;": 8757,
  "bernou;": 8492,
  "bigcap;": 8898,
  "bigcup;": 8899,
  "bigvee;": 8897,
  "bkarow;": 10509,
  "bottom;": 8869,
  "bowtie;": 8904,
  "boxbox;": 10697,
  "bprime;": 8245,
  "brvbar;": 166,
  "bullet;": 8226,
  "bumpeq;": 8783,
  "cacute;": 263,
  "capand;": 10820,
  "capcap;": 10827,
  "capcup;": 10823,
  "capdot;": 10816,
  "ccaron;": 269,
  "ccedil;": 231,
  "circeq;": 8791,
  "cirmid;": 10991,
  "colone;": 8788,
  "commat;": 64,
  "compfn;": 8728,
  "conint;": 8750,
  "coprod;": 8720,
  "copysr;": 8471,
  "cularr;": 8630,
  "cupcap;": 10822,
  "cupcup;": 10826,
  "cupdot;": 8845,
  "curarr;": 8631,
  "curren;": 164,
  "cylcty;": 9005,
  "dagger;": 8224,
  "daleth;": 8504,
  "dcaron;": 271,
  "dfisht;": 10623,
  "divide;": 247,
  "divonx;": 8903,
  "dlcorn;": 8990,
  "dlcrop;": 8973,
  "dollar;": 36,
  "drcorn;": 8991,
  "drcrop;": 8972,
  "dstrok;": 273,
  "eacute;": 233,
  "easter;": 10862,
  "ecaron;": 283,
  "ecolon;": 8789,
  "egrave;": 232,
  "egsdot;": 10904,
  "elsdot;": 10903,
  "emptyv;": 8709,
  "emsp13;": 8196,
  "emsp14;": 8197,
  "eparsl;": 10723,
  "eqcirc;": 8790,
  "equals;": 61,
  "equest;": 8799,
  "female;": 9792,
  "ffilig;": 64259,
  "ffllig;": 64260,
  "forall;": 8704,
  "frac12;": 189,
  "frac13;": 8531,
  "frac14;": 188,
  "frac15;": 8533,
  "frac16;": 8537,
  "frac18;": 8539,
  "frac23;": 8532,
  "frac25;": 8534,
  "frac34;": 190,
  "frac35;": 8535,
  "frac38;": 8540,
  "frac45;": 8536,
  "frac56;": 8538,
  "frac58;": 8541,
  "frac78;": 8542,
  "gacute;": 501,
  "gammad;": 989,
  "gbreve;": 287,
  "gesdot;": 10880,
  "gesles;": 10900,
  "gtlPar;": 10645,
  "gtrarr;": 10616,
  "gtrdot;": 8919,
  "gtrsim;": 8819,
  "hairsp;": 8202,
  "hamilt;": 8459,
  "hardcy;": 1098,
  "hearts;": 9829,
  "hellip;": 8230,
  "hercon;": 8889,
  "homtht;": 8763,
  "horbar;": 8213,
  "hslash;": 8463,
  "hstrok;": 295,
  "hybull;": 8259,
  "hyphen;": 8208,
  "iacute;": 237,
  "igrave;": 236,
  "iiiint;": 10764,
  "iinfin;": 10716,
  "incare;": 8453,
  "inodot;": 305,
  "intcal;": 8890,
  "iquest;": 191,
  "isinsv;": 8947,
  "itilde;": 297,
  "jsercy;": 1112,
  "kappav;": 1008,
  "kcedil;": 311,
  "kgreen;": 312,
  "lAtail;": 10523,
  "lacute;": 314,
  "lagran;": 8466,
  "lambda;": 955,
  "langle;": 10216,
  "larrfs;": 10525,
  "larrhk;": 8617,
  "larrlp;": 8619,
  "larrpl;": 10553,
  "larrtl;": 8610,
  "latail;": 10521,
  "lbrace;": 123,
  "lbrack;": 91,
  "lcaron;": 318,
  "lcedil;": 316,
  "ldquor;": 8222,
  "lesdot;": 10879,
  "lesges;": 10899,
  "lfisht;": 10620,
  "lfloor;": 8970,
  "lharul;": 10602,
  "llhard;": 10603,
  "lmidot;": 320,
  "lmoust;": 9136,
  "loplus;": 10797,
  "lowast;": 8727,
  "lowbar;": 95,
  "lparlt;": 10643,
  "lrhard;": 10605,
  "lsaquo;": 8249,
  "lsquor;": 8218,
  "lstrok;": 322,
  "lthree;": 8907,
  "ltimes;": 8905,
  "ltlarr;": 10614,
  "ltrPar;": 10646,
  "mapsto;": 8614,
  "marker;": 9646,
  "mcomma;": 10793,
  "midast;": 42,
  "midcir;": 10992,
  "middot;": 183,
  "minusb;": 8863,
  "minusd;": 8760,
  "mnplus;": 8723,
  "models;": 8871,
  "mstpos;": 8766,
  "nVDash;": 8879,
  "nVdash;": 8878,
  "nacute;": 324,
  "nbumpe;": 8783,
  "ncaron;": 328,
  "ncedil;": 326,
  "nearhk;": 10532,
  "nequiv;": 8802,
  "nesear;": 10536,
  "nexist;": 8708,
  "nltrie;": 8940,
  "notinE;": 8953,
  "nparsl;": 11005,
  "nprcue;": 8928,
  "nrarrc;": 10547,
  "nrarrw;": 8605,
  "nrtrie;": 8941,
  "nsccue;": 8929,
  "nsimeq;": 8772,
  "ntilde;": 241,
  "numero;": 8470,
  "nvDash;": 8877,
  "nvHarr;": 10500,
  "nvdash;": 8876,
  "nvlArr;": 10498,
  "nvrArr;": 10499,
  "nwarhk;": 10531,
  "nwnear;": 10535,
  "oacute;": 243,
  "odblac;": 337,
  "odsold;": 10684,
  "ograve;": 242,
  "ominus;": 8854,
  "origof;": 8886,
  "oslash;": 248,
  "otilde;": 245,
  "otimes;": 8855,
  "parsim;": 10995,
  "percnt;": 37,
  "period;": 46,
  "permil;": 8240,
  "phmmat;": 8499,
  "planck;": 8463,
  "plankv;": 8463,
  "plusdo;": 8724,
  "plusdu;": 10789,
  "plusmn;": 177,
  "preceq;": 10927,
  "primes;": 8473,
  "prnsim;": 8936,
  "propto;": 8733,
  "prurel;": 8880,
  "puncsp;": 8200,
  "qprime;": 8279,
  "rAtail;": 10524,
  "racute;": 341,
  "rangle;": 10217,
  "rarrap;": 10613,
  "rarrfs;": 10526,
  "rarrhk;": 8618,
  "rarrlp;": 8620,
  "rarrpl;": 10565,
  "rarrtl;": 8611,
  "ratail;": 10522,
  "rbrace;": 125,
  "rbrack;": 93,
  "rcaron;": 345,
  "rcedil;": 343,
  "rdquor;": 8221,
  "rfisht;": 10621,
  "rfloor;": 8971,
  "rharul;": 10604,
  "rmoust;": 9137,
  "roplus;": 10798,
  "rpargt;": 10644,
  "rsaquo;": 8250,
  "rsquor;": 8217,
  "rthree;": 8908,
  "rtimes;": 8906,
  "sacute;": 347,
  "scaron;": 353,
  "scedil;": 351,
  "scnsim;": 8937,
  "searhk;": 10533,
  "seswar;": 10537,
  "sfrown;": 8994,
  "shchcy;": 1097,
  "sigmaf;": 962,
  "sigmav;": 962,
  "simdot;": 10858,
  "smashp;": 10803,
  "softcy;": 1100,
  "solbar;": 9023,
  "spades;": 9824,
  "sqcaps;": 8851,
  "sqcups;": 8852,
  "sqsube;": 8849,
  "sqsupe;": 8850,
  "square;": 9633,
  "squarf;": 9642,
  "ssetmn;": 8726,
  "ssmile;": 8995,
  "sstarf;": 8902,
  "subdot;": 10941,
  "subset;": 8834,
  "subsim;": 10951,
  "subsub;": 10965,
  "subsup;": 10963,
  "succeq;": 10928,
  "supdot;": 10942,
  "supset;": 8835,
  "supsim;": 10952,
  "supsub;": 10964,
  "supsup;": 10966,
  "swarhk;": 10534,
  "swnwar;": 10538,
  "target;": 8982,
  "tcaron;": 357,
  "tcedil;": 355,
  "telrec;": 8981,
  "there4;": 8756,
  "thetav;": 977,
  "thinsp;": 8201,
  "thksim;": 8764,
  "timesb;": 8864,
  "timesd;": 10800,
  "topbot;": 9014,
  "topcir;": 10993,
  "tprime;": 8244,
  "tridot;": 9708,
  "tstrok;": 359,
  "uacute;": 250,
  "ubreve;": 365,
  "udblac;": 369,
  "ufisht;": 10622,
  "ugrave;": 249,
  "ulcorn;": 8988,
  "ulcrop;": 8975,
  "urcorn;": 8989,
  "urcrop;": 8974,
  "utilde;": 361,
  "vangrt;": 10652,
  "varphi;": 981,
  "varrho;": 1009,
  "veebar;": 8891,
  "vellip;": 8942,
  "verbar;": 124,
  "vsubnE;": 10955,
  "vsubne;": 8842,
  "vsupnE;": 10956,
  "vsupne;": 8843,
  "wedbar;": 10847,
  "wedgeq;": 8793,
  "weierp;": 8472,
  "wreath;": 8768,
  "xoplus;": 10753,
  "xotime;": 10754,
  "xsqcup;": 10758,
  "xuplus;": 10756,
  "xwedge;": 8896,
  "yacute;": 253,
  "zacute;": 378,
  "zcaron;": 382,
  "zeetrf;": 8488,
  "AElig;": 198,
  Aacute: 193,
  "Acirc;": 194,
  Agrave: 192,
  "Alpha;": 913,
  "Amacr;": 256,
  "Aogon;": 260,
  "Aring;": 197,
  Atilde: 195,
  "Breve;": 728,
  Ccedil: 199,
  "Ccirc;": 264,
  "Colon;": 8759,
  "Cross;": 10799,
  "Dashv;": 10980,
  "Delta;": 916,
  Eacute: 201,
  "Ecirc;": 202,
  Egrave: 200,
  "Emacr;": 274,
  "Eogon;": 280,
  "Equal;": 10869,
  "Gamma;": 915,
  "Gcirc;": 284,
  "Hacek;": 711,
  "Hcirc;": 292,
  "IJlig;": 306,
  Iacute: 205,
  "Icirc;": 206,
  Igrave: 204,
  "Imacr;": 298,
  "Iogon;": 302,
  "Iukcy;": 1030,
  "Jcirc;": 308,
  "Jukcy;": 1028,
  "Kappa;": 922,
  Ntilde: 209,
  "OElig;": 338,
  Oacute: 211,
  "Ocirc;": 212,
  Ograve: 210,
  "Omacr;": 332,
  "Omega;": 937,
  Oslash: 216,
  Otilde: 213,
  "Prime;": 8243,
  "RBarr;": 10512,
  "Scirc;": 348,
  "Sigma;": 931,
  "THORN;": 222,
  "TRADE;": 8482,
  "TSHcy;": 1035,
  "Theta;": 920,
  "Tilde;": 8764,
  Uacute: 218,
  "Ubrcy;": 1038,
  "Ucirc;": 219,
  Ugrave: 217,
  "Umacr;": 362,
  "Union;": 8899,
  "Uogon;": 370,
  "UpTee;": 8869,
  "Uring;": 366,
  "VDash;": 8875,
  "Vdash;": 8873,
  "Wcirc;": 372,
  "Wedge;": 8896,
  Yacute: 221,
  "Ycirc;": 374,
  aacute: 225,
  "acirc;": 226,
  "acute;": 180,
  "aelig;": 230,
  agrave: 224,
  "aleph;": 8501,
  "alpha;": 945,
  "amacr;": 257,
  "amalg;": 10815,
  "angle;": 8736,
  "angrt;": 8735,
  "angst;": 197,
  "aogon;": 261,
  "aring;": 229,
  "asymp;": 8776,
  atilde: 227,
  "awint;": 10769,
  "bcong;": 8780,
  "bdquo;": 8222,
  "bepsi;": 1014,
  "blank;": 9251,
  "blk12;": 9618,
  "blk14;": 9617,
  "blk34;": 9619,
  "block;": 9608,
  "boxDL;": 9559,
  "boxDR;": 9556,
  "boxDl;": 9558,
  "boxDr;": 9555,
  "boxHD;": 9574,
  "boxHU;": 9577,
  "boxHd;": 9572,
  "boxHu;": 9575,
  "boxUL;": 9565,
  "boxUR;": 9562,
  "boxUl;": 9564,
  "boxUr;": 9561,
  "boxVH;": 9580,
  "boxVL;": 9571,
  "boxVR;": 9568,
  "boxVh;": 9579,
  "boxVl;": 9570,
  "boxVr;": 9567,
  "boxdL;": 9557,
  "boxdR;": 9554,
  "boxdl;": 9488,
  "boxdr;": 9484,
  "boxhD;": 9573,
  "boxhU;": 9576,
  "boxhd;": 9516,
  "boxhu;": 9524,
  "boxuL;": 9563,
  "boxuR;": 9560,
  "boxul;": 9496,
  "boxur;": 9492,
  "boxvH;": 9578,
  "boxvL;": 9569,
  "boxvR;": 9566,
  "boxvh;": 9532,
  "boxvl;": 9508,
  "boxvr;": 9500,
  "breve;": 728,
  brvbar: 166,
  "bsemi;": 8271,
  "bsime;": 8909,
  "bsolb;": 10693,
  "bumpE;": 10926,
  "bumpe;": 8783,
  "caret;": 8257,
  "caron;": 711,
  "ccaps;": 10829,
  ccedil: 231,
  "ccirc;": 265,
  "ccups;": 10828,
  "cedil;": 184,
  "check;": 10003,
  "clubs;": 9827,
  "colon;": 58,
  "comma;": 44,
  "crarr;": 8629,
  "cross;": 10007,
  "csube;": 10961,
  "csupe;": 10962,
  "ctdot;": 8943,
  "cuepr;": 8926,
  "cuesc;": 8927,
  "cupor;": 10821,
  curren: 164,
  "cuvee;": 8910,
  "cuwed;": 8911,
  "cwint;": 8753,
  "dashv;": 8867,
  "dblac;": 733,
  "ddarr;": 8650,
  "delta;": 948,
  "dharl;": 8643,
  "dharr;": 8642,
  "diams;": 9830,
  "disin;": 8946,
  divide: 247,
  "doteq;": 8784,
  "dtdot;": 8945,
  "dtrif;": 9662,
  "duarr;": 8693,
  "duhar;": 10607,
  "eDDot;": 10871,
  eacute: 233,
  "ecirc;": 234,
  "efDot;": 8786,
  egrave: 232,
  "emacr;": 275,
  "empty;": 8709,
  "eogon;": 281,
  "eplus;": 10865,
  "epsiv;": 1013,
  "eqsim;": 8770,
  "equiv;": 8801,
  "erDot;": 8787,
  "erarr;": 10609,
  "esdot;": 8784,
  "exist;": 8707,
  "fflig;": 64256,
  "filig;": 64257,
  "fjlig;": 102,
  "fllig;": 64258,
  "fltns;": 9649,
  "forkv;": 10969,
  frac12: 189,
  frac14: 188,
  frac34: 190,
  "frasl;": 8260,
  "frown;": 8994,
  "gamma;": 947,
  "gcirc;": 285,
  "gescc;": 10921,
  "gimel;": 8503,
  "gneqq;": 8809,
  "gnsim;": 8935,
  "grave;": 96,
  "gsime;": 10894,
  "gsiml;": 10896,
  "gtcir;": 10874,
  "gtdot;": 8919,
  "harrw;": 8621,
  "hcirc;": 293,
  "hoarr;": 8703,
  iacute: 237,
  "icirc;": 238,
  "iexcl;": 161,
  igrave: 236,
  "iiint;": 8749,
  "iiota;": 8489,
  "ijlig;": 307,
  "imacr;": 299,
  "image;": 8465,
  "imath;": 305,
  "imped;": 437,
  "infin;": 8734,
  "iogon;": 303,
  "iprod;": 10812,
  iquest: 191,
  "isinE;": 8953,
  "isins;": 8948,
  "isinv;": 8712,
  "iukcy;": 1110,
  "jcirc;": 309,
  "jmath;": 567,
  "jukcy;": 1108,
  "kappa;": 954,
  "lAarr;": 8666,
  "lBarr;": 10510,
  "langd;": 10641,
  "laquo;": 171,
  "larrb;": 8676,
  "lates;": 10925,
  "lbarr;": 10508,
  "lbbrk;": 10098,
  "lbrke;": 10635,
  "lceil;": 8968,
  "ldquo;": 8220,
  "lescc;": 10920,
  "lhard;": 8637,
  "lharu;": 8636,
  "lhblk;": 9604,
  "llarr;": 8647,
  "lltri;": 9722,
  "lneqq;": 8808,
  "lnsim;": 8934,
  "loang;": 10220,
  "loarr;": 8701,
  "lobrk;": 10214,
  "lopar;": 10629,
  "lrarr;": 8646,
  "lrhar;": 8651,
  "lrtri;": 8895,
  "lsime;": 10893,
  "lsimg;": 10895,
  "lsquo;": 8216,
  "ltcir;": 10873,
  "ltdot;": 8918,
  "ltrie;": 8884,
  "ltrif;": 9666,
  "mDDot;": 8762,
  "mdash;": 8212,
  "micro;": 181,
  middot: 183,
  "minus;": 8722,
  "mumap;": 8888,
  "nabla;": 8711,
  "napid;": 8779,
  "napos;": 329,
  "natur;": 9838,
  "nbump;": 8782,
  "ncong;": 8775,
  "ndash;": 8211,
  "neArr;": 8663,
  "nearr;": 8599,
  "nedot;": 8784,
  "nesim;": 8770,
  "ngeqq;": 8807,
  "ngsim;": 8821,
  "nhArr;": 8654,
  "nharr;": 8622,
  "nhpar;": 10994,
  "nlArr;": 8653,
  "nlarr;": 8602,
  "nleqq;": 8806,
  "nless;": 8814,
  "nlsim;": 8820,
  "nltri;": 8938,
  "notin;": 8713,
  "notni;": 8716,
  "npart;": 8706,
  "nprec;": 8832,
  "nrArr;": 8655,
  "nrarr;": 8603,
  "nrtri;": 8939,
  "nsime;": 8772,
  "nsmid;": 8740,
  "nspar;": 8742,
  "nsubE;": 10949,
  "nsube;": 8840,
  "nsucc;": 8833,
  "nsupE;": 10950,
  "nsupe;": 8841,
  ntilde: 241,
  "numsp;": 8199,
  "nvsim;": 8764,
  "nwArr;": 8662,
  "nwarr;": 8598,
  oacute: 243,
  "ocirc;": 244,
  "odash;": 8861,
  "oelig;": 339,
  "ofcir;": 10687,
  ograve: 242,
  "ohbar;": 10677,
  "olarr;": 8634,
  "olcir;": 10686,
  "oline;": 8254,
  "omacr;": 333,
  "omega;": 969,
  "operp;": 10681,
  "oplus;": 8853,
  "orarr;": 8635,
  "order;": 8500,
  oslash: 248,
  otilde: 245,
  "ovbar;": 9021,
  "parsl;": 11005,
  "phone;": 9742,
  "plusb;": 8862,
  "pluse;": 10866,
  plusmn: 177,
  "pound;": 163,
  "prcue;": 8828,
  "prime;": 8242,
  "prnap;": 10937,
  "prsim;": 8830,
  "quest;": 63,
  "rAarr;": 8667,
  "rBarr;": 10511,
  "radic;": 8730,
  "rangd;": 10642,
  "range;": 10661,
  "raquo;": 187,
  "rarrb;": 8677,
  "rarrc;": 10547,
  "rarrw;": 8605,
  "ratio;": 8758,
  "rbarr;": 10509,
  "rbbrk;": 10099,
  "rbrke;": 10636,
  "rceil;": 8969,
  "rdquo;": 8221,
  "reals;": 8477,
  "rhard;": 8641,
  "rharu;": 8640,
  "rlarr;": 8644,
  "rlhar;": 8652,
  "rnmid;": 10990,
  "roang;": 10221,
  "roarr;": 8702,
  "robrk;": 10215,
  "ropar;": 10630,
  "rrarr;": 8649,
  "rsquo;": 8217,
  "rtrie;": 8885,
  "rtrif;": 9656,
  "sbquo;": 8218,
  "sccue;": 8829,
  "scirc;": 349,
  "scnap;": 10938,
  "scsim;": 8831,
  "sdotb;": 8865,
  "sdote;": 10854,
  "seArr;": 8664,
  "searr;": 8600,
  "setmn;": 8726,
  "sharp;": 9839,
  "sigma;": 963,
  "simeq;": 8771,
  "simgE;": 10912,
  "simlE;": 10911,
  "simne;": 8774,
  "slarr;": 8592,
  "smile;": 8995,
  "smtes;": 10924,
  "sqcap;": 8851,
  "sqcup;": 8852,
  "sqsub;": 8847,
  "sqsup;": 8848,
  "srarr;": 8594,
  "starf;": 9733,
  "strns;": 175,
  "subnE;": 10955,
  "subne;": 8842,
  "supnE;": 10956,
  "supne;": 8843,
  "swArr;": 8665,
  "swarr;": 8601,
  "szlig;": 223,
  "theta;": 952,
  "thkap;": 8776,
  "thorn;": 254,
  "tilde;": 732,
  "times;": 215,
  "trade;": 8482,
  "trisb;": 10701,
  "tshcy;": 1115,
  "twixt;": 8812,
  uacute: 250,
  "ubrcy;": 1118,
  "ucirc;": 251,
  "udarr;": 8645,
  "udhar;": 10606,
  ugrave: 249,
  "uharl;": 8639,
  "uharr;": 8638,
  "uhblk;": 9600,
  "ultri;": 9720,
  "umacr;": 363,
  "uogon;": 371,
  "uplus;": 8846,
  "upsih;": 978,
  "uring;": 367,
  "urtri;": 9721,
  "utdot;": 8944,
  "utrif;": 9652,
  "uuarr;": 8648,
  "vBarv;": 10985,
  "vDash;": 8872,
  "varpi;": 982,
  "vdash;": 8866,
  "veeeq;": 8794,
  "vltri;": 8882,
  "vnsub;": 8834,
  "vnsup;": 8835,
  "vprop;": 8733,
  "vrtri;": 8883,
  "wcirc;": 373,
  "wedge;": 8743,
  "xcirc;": 9711,
  "xdtri;": 9661,
  "xhArr;": 10234,
  "xharr;": 10231,
  "xlArr;": 10232,
  "xlarr;": 10229,
  "xodot;": 10752,
  "xrArr;": 10233,
  "xrarr;": 10230,
  "xutri;": 9651,
  yacute: 253,
  "ycirc;": 375,
  AElig: 198,
  Acirc: 194,
  "Aopf;": 120120,
  Aring: 197,
  "Ascr;": 119964,
  "Auml;": 196,
  "Barv;": 10983,
  "Beta;": 914,
  "Bopf;": 120121,
  "Bscr;": 8492,
  "CHcy;": 1063,
  "COPY;": 169,
  "Cdot;": 266,
  "Copf;": 8450,
  "Cscr;": 119966,
  "DJcy;": 1026,
  "DScy;": 1029,
  "DZcy;": 1039,
  "Darr;": 8609,
  "Dopf;": 120123,
  "Dscr;": 119967,
  Ecirc: 202,
  "Edot;": 278,
  "Eopf;": 120124,
  "Escr;": 8496,
  "Esim;": 10867,
  "Euml;": 203,
  "Fopf;": 120125,
  "Fscr;": 8497,
  "GJcy;": 1027,
  "Gdot;": 288,
  "Gopf;": 120126,
  "Gscr;": 119970,
  "Hopf;": 8461,
  "Hscr;": 8459,
  "IEcy;": 1045,
  "IOcy;": 1025,
  Icirc: 206,
  "Idot;": 304,
  "Iopf;": 120128,
  "Iota;": 921,
  "Iscr;": 8464,
  "Iuml;": 207,
  "Jopf;": 120129,
  "Jscr;": 119973,
  "KHcy;": 1061,
  "KJcy;": 1036,
  "Kopf;": 120130,
  "Kscr;": 119974,
  "LJcy;": 1033,
  "Lang;": 10218,
  "Larr;": 8606,
  "Lopf;": 120131,
  "Lscr;": 8466,
  "Mopf;": 120132,
  "Mscr;": 8499,
  "NJcy;": 1034,
  "Nopf;": 8469,
  "Nscr;": 119977,
  Ocirc: 212,
  "Oopf;": 120134,
  "Oscr;": 119978,
  "Ouml;": 214,
  "Popf;": 8473,
  "Pscr;": 119979,
  "QUOT;": 34,
  "Qopf;": 8474,
  "Qscr;": 119980,
  "Rang;": 10219,
  "Rarr;": 8608,
  "Ropf;": 8477,
  "Rscr;": 8475,
  "SHcy;": 1064,
  "Sopf;": 120138,
  "Sqrt;": 8730,
  "Sscr;": 119982,
  "Star;": 8902,
  THORN: 222,
  "TScy;": 1062,
  "Topf;": 120139,
  "Tscr;": 119983,
  "Uarr;": 8607,
  Ucirc: 219,
  "Uopf;": 120140,
  "Upsi;": 978,
  "Uscr;": 119984,
  "Uuml;": 220,
  "Vbar;": 10987,
  "Vert;": 8214,
  "Vopf;": 120141,
  "Vscr;": 119985,
  "Wopf;": 120142,
  "Wscr;": 119986,
  "Xopf;": 120143,
  "Xscr;": 119987,
  "YAcy;": 1071,
  "YIcy;": 1031,
  "YUcy;": 1070,
  "Yopf;": 120144,
  "Yscr;": 119988,
  "Yuml;": 376,
  "ZHcy;": 1046,
  "Zdot;": 379,
  "Zeta;": 918,
  "Zopf;": 8484,
  "Zscr;": 119989,
  acirc: 226,
  acute: 180,
  aelig: 230,
  "andd;": 10844,
  "andv;": 10842,
  "ange;": 10660,
  "aopf;": 120146,
  "apid;": 8779,
  "apos;": 39,
  aring: 229,
  "ascr;": 119990,
  "auml;": 228,
  "bNot;": 10989,
  "bbrk;": 9141,
  "beta;": 946,
  "beth;": 8502,
  "bnot;": 8976,
  "bopf;": 120147,
  "boxH;": 9552,
  "boxV;": 9553,
  "boxh;": 9472,
  "boxv;": 9474,
  "bscr;": 119991,
  "bsim;": 8765,
  "bsol;": 92,
  "bull;": 8226,
  "bump;": 8782,
  "caps;": 8745,
  "cdot;": 267,
  cedil: 184,
  "cent;": 162,
  "chcy;": 1095,
  "cirE;": 10691,
  "circ;": 710,
  "cire;": 8791,
  "comp;": 8705,
  "cong;": 8773,
  "copf;": 120148,
  "copy;": 169,
  "cscr;": 119992,
  "csub;": 10959,
  "csup;": 10960,
  "cups;": 8746,
  "dArr;": 8659,
  "dHar;": 10597,
  "darr;": 8595,
  "dash;": 8208,
  "diam;": 8900,
  "djcy;": 1106,
  "dopf;": 120149,
  "dscr;": 119993,
  "dscy;": 1109,
  "dsol;": 10742,
  "dtri;": 9663,
  "dzcy;": 1119,
  "eDot;": 8785,
  "ecir;": 8790,
  ecirc: 234,
  "edot;": 279,
  "emsp;": 8195,
  "ensp;": 8194,
  "eopf;": 120150,
  "epar;": 8917,
  "epsi;": 949,
  "escr;": 8495,
  "esim;": 8770,
  "euml;": 235,
  "euro;": 8364,
  "excl;": 33,
  "flat;": 9837,
  "fnof;": 402,
  "fopf;": 120151,
  "fork;": 8916,
  "fscr;": 119995,
  "gdot;": 289,
  "geqq;": 8807,
  "gesl;": 8923,
  "gjcy;": 1107,
  "gnap;": 10890,
  "gneq;": 10888,
  "gopf;": 120152,
  "gscr;": 8458,
  "gsim;": 8819,
  "gtcc;": 10919,
  "gvnE;": 8809,
  "hArr;": 8660,
  "half;": 189,
  "harr;": 8596,
  "hbar;": 8463,
  "hopf;": 120153,
  "hscr;": 119997,
  icirc: 238,
  "iecy;": 1077,
  iexcl: 161,
  "imof;": 8887,
  "iocy;": 1105,
  "iopf;": 120154,
  "iota;": 953,
  "iscr;": 119998,
  "isin;": 8712,
  "iuml;": 239,
  "jopf;": 120155,
  "jscr;": 119999,
  "khcy;": 1093,
  "kjcy;": 1116,
  "kopf;": 120156,
  "kscr;": 12e4,
  "lArr;": 8656,
  "lHar;": 10594,
  "lang;": 10216,
  laquo: 171,
  "larr;": 8592,
  "late;": 10925,
  "lcub;": 123,
  "ldca;": 10550,
  "ldsh;": 8626,
  "leqq;": 8806,
  "lesg;": 8922,
  "ljcy;": 1113,
  "lnap;": 10889,
  "lneq;": 10887,
  "lopf;": 120157,
  "lozf;": 10731,
  "lpar;": 40,
  "lscr;": 120001,
  "lsim;": 8818,
  "lsqb;": 91,
  "ltcc;": 10918,
  "ltri;": 9667,
  "lvnE;": 8808,
  "macr;": 175,
  "male;": 9794,
  "malt;": 10016,
  micro: 181,
  "mlcp;": 10971,
  "mldr;": 8230,
  "mopf;": 120158,
  "mscr;": 120002,
  "nGtv;": 8811,
  "nLtv;": 8810,
  "nang;": 8736,
  "napE;": 10864,
  "nbsp;": 160,
  "ncap;": 10819,
  "ncup;": 10818,
  "ngeq;": 8817,
  "nges;": 10878,
  "ngtr;": 8815,
  "nisd;": 8954,
  "njcy;": 1114,
  "nldr;": 8229,
  "nleq;": 8816,
  "nles;": 10877,
  "nmid;": 8740,
  "nopf;": 120159,
  "npar;": 8742,
  "npre;": 10927,
  "nsce;": 10928,
  "nscr;": 120003,
  "nsim;": 8769,
  "nsub;": 8836,
  "nsup;": 8837,
  "ntgl;": 8825,
  "ntlg;": 8824,
  "nvap;": 8781,
  "nvge;": 8805,
  "nvgt;": 62,
  "nvle;": 8804,
  "nvlt;": 60,
  "oast;": 8859,
  "ocir;": 8858,
  ocirc: 244,
  "odiv;": 10808,
  "odot;": 8857,
  "ogon;": 731,
  "oint;": 8750,
  "omid;": 10678,
  "oopf;": 120160,
  "opar;": 10679,
  "ordf;": 170,
  "ordm;": 186,
  "oror;": 10838,
  "oscr;": 8500,
  "osol;": 8856,
  "ouml;": 246,
  "para;": 182,
  "part;": 8706,
  "perp;": 8869,
  "phiv;": 981,
  "plus;": 43,
  "popf;": 120161,
  pound: 163,
  "prap;": 10935,
  "prec;": 8826,
  "prnE;": 10933,
  "prod;": 8719,
  "prop;": 8733,
  "pscr;": 120005,
  "qint;": 10764,
  "qopf;": 120162,
  "qscr;": 120006,
  "quot;": 34,
  "rArr;": 8658,
  "rHar;": 10596,
  "race;": 8765,
  "rang;": 10217,
  raquo: 187,
  "rarr;": 8594,
  "rcub;": 125,
  "rdca;": 10551,
  "rdsh;": 8627,
  "real;": 8476,
  "rect;": 9645,
  "rhov;": 1009,
  "ring;": 730,
  "ropf;": 120163,
  "rpar;": 41,
  "rscr;": 120007,
  "rsqb;": 93,
  "rtri;": 9657,
  "scap;": 10936,
  "scnE;": 10934,
  "sdot;": 8901,
  "sect;": 167,
  "semi;": 59,
  "sext;": 10038,
  "shcy;": 1096,
  "sime;": 8771,
  "simg;": 10910,
  "siml;": 10909,
  "smid;": 8739,
  "smte;": 10924,
  "solb;": 10692,
  "sopf;": 120164,
  "spar;": 8741,
  "squf;": 9642,
  "sscr;": 120008,
  "star;": 9734,
  "subE;": 10949,
  "sube;": 8838,
  "succ;": 8827,
  "sung;": 9834,
  "sup1;": 185,
  "sup2;": 178,
  "sup3;": 179,
  "supE;": 10950,
  "supe;": 8839,
  szlig: 223,
  "tbrk;": 9140,
  "tdot;": 8411,
  thorn: 254,
  times: 215,
  "tint;": 8749,
  "toea;": 10536,
  "topf;": 120165,
  "tosa;": 10537,
  "trie;": 8796,
  "tscr;": 120009,
  "tscy;": 1094,
  "uArr;": 8657,
  "uHar;": 10595,
  "uarr;": 8593,
  ucirc: 251,
  "uopf;": 120166,
  "upsi;": 965,
  "uscr;": 120010,
  "utri;": 9653,
  "uuml;": 252,
  "vArr;": 8661,
  "vBar;": 10984,
  "varr;": 8597,
  "vert;": 124,
  "vopf;": 120167,
  "vscr;": 120011,
  "wopf;": 120168,
  "wscr;": 120012,
  "xcap;": 8898,
  "xcup;": 8899,
  "xmap;": 10236,
  "xnis;": 8955,
  "xopf;": 120169,
  "xscr;": 120013,
  "xvee;": 8897,
  "yacy;": 1103,
  "yicy;": 1111,
  "yopf;": 120170,
  "yscr;": 120014,
  "yucy;": 1102,
  "yuml;": 255,
  "zdot;": 380,
  "zeta;": 950,
  "zhcy;": 1078,
  "zopf;": 120171,
  "zscr;": 120015,
  "zwnj;": 8204,
  "AMP;": 38,
  "Acy;": 1040,
  "Afr;": 120068,
  "And;": 10835,
  Auml: 196,
  "Bcy;": 1041,
  "Bfr;": 120069,
  COPY: 169,
  "Cap;": 8914,
  "Cfr;": 8493,
  "Chi;": 935,
  "Cup;": 8915,
  "Dcy;": 1044,
  "Del;": 8711,
  "Dfr;": 120071,
  "Dot;": 168,
  "ENG;": 330,
  "ETH;": 208,
  "Ecy;": 1069,
  "Efr;": 120072,
  "Eta;": 919,
  Euml: 203,
  "Fcy;": 1060,
  "Ffr;": 120073,
  "Gcy;": 1043,
  "Gfr;": 120074,
  "Hat;": 94,
  "Hfr;": 8460,
  "Icy;": 1048,
  "Ifr;": 8465,
  "Int;": 8748,
  Iuml: 207,
  "Jcy;": 1049,
  "Jfr;": 120077,
  "Kcy;": 1050,
  "Kfr;": 120078,
  "Lcy;": 1051,
  "Lfr;": 120079,
  "Lsh;": 8624,
  "Map;": 10501,
  "Mcy;": 1052,
  "Mfr;": 120080,
  "Ncy;": 1053,
  "Nfr;": 120081,
  "Not;": 10988,
  "Ocy;": 1054,
  "Ofr;": 120082,
  Ouml: 214,
  "Pcy;": 1055,
  "Pfr;": 120083,
  "Phi;": 934,
  "Psi;": 936,
  QUOT: 34,
  "Qfr;": 120084,
  "REG;": 174,
  "Rcy;": 1056,
  "Rfr;": 8476,
  "Rho;": 929,
  "Rsh;": 8625,
  "Scy;": 1057,
  "Sfr;": 120086,
  "Sub;": 8912,
  "Sum;": 8721,
  "Sup;": 8913,
  "Tab;": 9,
  "Tau;": 932,
  "Tcy;": 1058,
  "Tfr;": 120087,
  "Ucy;": 1059,
  "Ufr;": 120088,
  Uuml: 220,
  "Vcy;": 1042,
  "Vee;": 8897,
  "Vfr;": 120089,
  "Wfr;": 120090,
  "Xfr;": 120091,
  "Ycy;": 1067,
  "Yfr;": 120092,
  "Zcy;": 1047,
  "Zfr;": 8488,
  "acE;": 8766,
  "acd;": 8767,
  "acy;": 1072,
  "afr;": 120094,
  "amp;": 38,
  "and;": 8743,
  "ang;": 8736,
  "apE;": 10864,
  "ape;": 8778,
  "ast;": 42,
  auml: 228,
  "bcy;": 1073,
  "bfr;": 120095,
  "bne;": 61,
  "bot;": 8869,
  "cap;": 8745,
  cent: 162,
  "cfr;": 120096,
  "chi;": 967,
  "cir;": 9675,
  copy: 169,
  "cup;": 8746,
  "dcy;": 1076,
  "deg;": 176,
  "dfr;": 120097,
  "die;": 168,
  "div;": 247,
  "dot;": 729,
  "ecy;": 1101,
  "efr;": 120098,
  "egs;": 10902,
  "ell;": 8467,
  "els;": 10901,
  "eng;": 331,
  "eta;": 951,
  "eth;": 240,
  euml: 235,
  "fcy;": 1092,
  "ffr;": 120099,
  "gEl;": 10892,
  "gap;": 10886,
  "gcy;": 1075,
  "gel;": 8923,
  "geq;": 8805,
  "ges;": 10878,
  "gfr;": 120100,
  "ggg;": 8921,
  "glE;": 10898,
  "gla;": 10917,
  "glj;": 10916,
  "gnE;": 8809,
  "gne;": 10888,
  "hfr;": 120101,
  "icy;": 1080,
  "iff;": 8660,
  "ifr;": 120102,
  "int;": 8747,
  iuml: 239,
  "jcy;": 1081,
  "jfr;": 120103,
  "kcy;": 1082,
  "kfr;": 120104,
  "lEg;": 10891,
  "lap;": 10885,
  "lat;": 10923,
  "lcy;": 1083,
  "leg;": 8922,
  "leq;": 8804,
  "les;": 10877,
  "lfr;": 120105,
  "lgE;": 10897,
  "lnE;": 8808,
  "lne;": 10887,
  "loz;": 9674,
  "lrm;": 8206,
  "lsh;": 8624,
  macr: 175,
  "map;": 8614,
  "mcy;": 1084,
  "mfr;": 120106,
  "mho;": 8487,
  "mid;": 8739,
  "nGg;": 8921,
  "nGt;": 8811,
  "nLl;": 8920,
  "nLt;": 8810,
  "nap;": 8777,
  nbsp: 160,
  "ncy;": 1085,
  "nfr;": 120107,
  "ngE;": 8807,
  "nge;": 8817,
  "ngt;": 8815,
  "nis;": 8956,
  "niv;": 8715,
  "nlE;": 8806,
  "nle;": 8816,
  "nlt;": 8814,
  "not;": 172,
  "npr;": 8832,
  "nsc;": 8833,
  "num;": 35,
  "ocy;": 1086,
  "ofr;": 120108,
  "ogt;": 10689,
  "ohm;": 937,
  "olt;": 10688,
  "ord;": 10845,
  ordf: 170,
  ordm: 186,
  "orv;": 10843,
  ouml: 246,
  "par;": 8741,
  para: 182,
  "pcy;": 1087,
  "pfr;": 120109,
  "phi;": 966,
  "piv;": 982,
  "prE;": 10931,
  "pre;": 10927,
  "psi;": 968,
  "qfr;": 120110,
  quot: 34,
  "rcy;": 1088,
  "reg;": 174,
  "rfr;": 120111,
  "rho;": 961,
  "rlm;": 8207,
  "rsh;": 8625,
  "scE;": 10932,
  "sce;": 10928,
  "scy;": 1089,
  sect: 167,
  "sfr;": 120112,
  "shy;": 173,
  "sim;": 8764,
  "smt;": 10922,
  "sol;": 47,
  "squ;": 9633,
  "sub;": 8834,
  "sum;": 8721,
  sup1: 185,
  sup2: 178,
  sup3: 179,
  "sup;": 8835,
  "tau;": 964,
  "tcy;": 1090,
  "tfr;": 120113,
  "top;": 8868,
  "ucy;": 1091,
  "ufr;": 120114,
  "uml;": 168,
  uuml: 252,
  "vcy;": 1074,
  "vee;": 8744,
  "vfr;": 120115,
  "wfr;": 120116,
  "xfr;": 120117,
  "ycy;": 1099,
  "yen;": 165,
  "yfr;": 120118,
  yuml: 255,
  "zcy;": 1079,
  "zfr;": 120119,
  "zwj;": 8205,
  AMP: 38,
  "DD;": 8517,
  ETH: 208,
  "GT;": 62,
  "Gg;": 8921,
  "Gt;": 8811,
  "Im;": 8465,
  "LT;": 60,
  "Ll;": 8920,
  "Lt;": 8810,
  "Mu;": 924,
  "Nu;": 925,
  "Or;": 10836,
  "Pi;": 928,
  "Pr;": 10939,
  REG: 174,
  "Re;": 8476,
  "Sc;": 10940,
  "Xi;": 926,
  "ac;": 8766,
  "af;": 8289,
  amp: 38,
  "ap;": 8776,
  "dd;": 8518,
  deg: 176,
  "ee;": 8519,
  "eg;": 10906,
  "el;": 10905,
  eth: 240,
  "gE;": 8807,
  "ge;": 8805,
  "gg;": 8811,
  "gl;": 8823,
  "gt;": 62,
  "ic;": 8291,
  "ii;": 8520,
  "in;": 8712,
  "it;": 8290,
  "lE;": 8806,
  "le;": 8804,
  "lg;": 8822,
  "ll;": 8810,
  "lt;": 60,
  "mp;": 8723,
  "mu;": 956,
  "ne;": 8800,
  "ni;": 8715,
  not: 172,
  "nu;": 957,
  "oS;": 9416,
  "or;": 8744,
  "pi;": 960,
  "pm;": 177,
  "pr;": 8826,
  reg: 174,
  "rx;": 8478,
  "sc;": 8827,
  shy: 173,
  uml: 168,
  "wp;": 8472,
  "wr;": 8768,
  "xi;": 958,
  yen: 165,
  GT: 62,
  LT: 60,
  gt: 62,
  lt: 60
};

// node_modules/svelte/src/compiler/phases/1-parse/utils/html.js
var windows_1252 = [
  8364,
  129,
  8218,
  402,
  8222,
  8230,
  8224,
  8225,
  710,
  8240,
  352,
  8249,
  338,
  141,
  381,
  143,
  144,
  8216,
  8217,
  8220,
  8221,
  8226,
  8211,
  8212,
  732,
  8482,
  353,
  8250,
  339,
  157,
  382,
  376
];
function reg_exp_entity(entity_name, is_attribute_value) {
  if (is_attribute_value && !entity_name.endsWith(";")) {
    return `${entity_name}\\b(?!=)`;
  }
  return entity_name;
}
function get_entity_pattern(is_attribute_value) {
  const reg_exp_num = "#(?:x[a-fA-F\\d]+|\\d+)(?:;)?";
  const reg_exp_entities = Object.keys(entities_default).map(
    /** @param {any} entity_name */
    (entity_name) => reg_exp_entity(entity_name, is_attribute_value)
  );
  const entity_pattern = new RegExp(`&(${reg_exp_num}|${reg_exp_entities.join("|")})`, "g");
  return entity_pattern;
}
var entity_pattern_content = get_entity_pattern(false);
var entity_pattern_attr_value = get_entity_pattern(true);
function decode_character_references(html, is_attribute_value) {
  const entity_pattern = is_attribute_value ? entity_pattern_attr_value : entity_pattern_content;
  return html.replace(
    entity_pattern,
    /**
     * @param {any} match
     * @param {keyof typeof entities} entity
     */
    (match, entity) => {
      let code;
      if (entity[0] !== "#") {
        code = entities_default[entity];
      } else if (entity[1] === "x") {
        code = parseInt(entity.substring(2), 16);
      } else {
        code = parseInt(entity.substring(1), 10);
      }
      if (!code) {
        return match;
      }
      return String.fromCodePoint(validate_code(code));
    }
  );
}
var NUL = 0;
function validate_code(code) {
  if (code === 10) {
    return 32;
  }
  if (code < 128) {
    return code;
  }
  if (code <= 159) {
    return windows_1252[code - 128];
  }
  if (code < 55296) {
    return code;
  }
  if (code <= 57343) {
    return NUL;
  }
  if (code <= 65535) {
    return code;
  }
  if (code >= 65536 && code <= 131071) {
    return code;
  }
  if (code >= 131072 && code <= 196607) {
    return code;
  }
  return NUL;
}

// node_modules/svelte/src/compiler/phases/1-parse/utils/create.js
function create_fragment(transparent = false) {
  return {
    type: "Fragment",
    nodes: [],
    metadata: {
      transparent,
      dynamic: false
    }
  };
}

// node_modules/svelte/src/compiler/phases/nodes.js
var element_nodes = [
  "SvelteElement",
  "RegularElement",
  "SvelteFragment",
  "Component",
  "SvelteComponent",
  "SvelteSelf",
  "SlotElement"
];
function is_element_node(node) {
  return element_nodes.includes(node.type);
}
function is_custom_element_node(node) {
  return node.type === "RegularElement" && node.name.includes("-");
}
function create_attribute(name, start, end, value) {
  return {
    type: "Attribute",
    start,
    end,
    name,
    value,
    parent: null,
    metadata: {
      expression: create_expression_metadata(),
      delegated: null
    }
  };
}
function create_expression_metadata() {
  return {
    dependencies: /* @__PURE__ */ new Set(),
    has_state: false,
    has_call: false
  };
}

// node_modules/svelte/src/html-tree-validation.js
var autoclosing_children = {
  // based on http://developers.whatwg.org/syntax.html#syntax-tag-omission
  li: { direct: ["li"] },
  // https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dt#technical_summary
  dt: { descendant: ["dt", "dd"], reset_by: ["dl"] },
  dd: { descendant: ["dt", "dd"], reset_by: ["dl"] },
  p: {
    descendant: [
      "address",
      "article",
      "aside",
      "blockquote",
      "div",
      "dl",
      "fieldset",
      "footer",
      "form",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "header",
      "hgroup",
      "hr",
      "main",
      "menu",
      "nav",
      "ol",
      "p",
      "pre",
      "section",
      "table",
      "ul"
    ]
  },
  rt: { descendant: ["rt", "rp"] },
  rp: { descendant: ["rt", "rp"] },
  optgroup: { descendant: ["optgroup"] },
  option: { descendant: ["option", "optgroup"] },
  thead: { direct: ["tbody", "tfoot"] },
  tbody: { direct: ["tbody", "tfoot"] },
  tfoot: { direct: ["tbody"] },
  tr: { direct: ["tr", "tbody"] },
  td: { direct: ["td", "th", "tr"] },
  th: { direct: ["td", "th", "tr"] }
};
function closing_tag_omitted(current, next2) {
  const disallowed = autoclosing_children[current];
  if (disallowed) {
    if (!next2 || ("direct" in disallowed ? disallowed.direct : disallowed.descendant).includes(next2)) {
      return true;
    }
  }
  return false;
}
var disallowed_children = {
  ...autoclosing_children,
  optgroup: { only: ["option", "#text"] },
  // Strictly speaking, seeing an <option> doesn't mean we're in a <select>, but we assume it here
  option: { only: ["#text"] },
  form: { descendant: ["form"] },
  a: { descendant: ["a"] },
  button: { descendant: ["button"] },
  h1: { descendant: ["h1", "h2", "h3", "h4", "h5", "h6"] },
  h2: { descendant: ["h1", "h2", "h3", "h4", "h5", "h6"] },
  h3: { descendant: ["h1", "h2", "h3", "h4", "h5", "h6"] },
  h4: { descendant: ["h1", "h2", "h3", "h4", "h5", "h6"] },
  h5: { descendant: ["h1", "h2", "h3", "h4", "h5", "h6"] },
  h6: { descendant: ["h1", "h2", "h3", "h4", "h5", "h6"] },
  // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
  select: { only: ["option", "optgroup", "#text", "hr", "script", "template"] },
  // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
  // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
  // No special behavior since these rules fall back to "in body" mode for
  // all except special table nodes which cause bad parsing behavior anyway.
  // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
  tr: { only: ["th", "td", "style", "script", "template"] },
  // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
  tbody: { only: ["tr", "style", "script", "template"] },
  thead: { only: ["tr", "style", "script", "template"] },
  tfoot: { only: ["tr", "style", "script", "template"] },
  // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
  colgroup: { only: ["col", "template"] },
  // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
  table: {
    only: ["caption", "colgroup", "tbody", "thead", "tfoot", "style", "script", "template"]
  },
  // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
  head: {
    only: [
      "base",
      "basefont",
      "bgsound",
      "link",
      "meta",
      "title",
      "noscript",
      "noframes",
      "style",
      "script",
      "template"
    ]
  },
  // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
  html: { only: ["head", "body", "frameset"] },
  frameset: { only: ["frame"] },
  "#document": { only: ["html"] }
};
function is_tag_valid_with_ancestor(tag2, ancestors) {
  if (tag2.includes("-")) return true;
  const target = ancestors[ancestors.length - 1];
  const disallowed = disallowed_children[target];
  if (!disallowed) return true;
  if ("reset_by" in disallowed && disallowed.reset_by) {
    for (let i = ancestors.length - 2; i >= 0; i--) {
      const ancestor = ancestors[i];
      if (ancestor.includes("-")) return true;
      if (disallowed.reset_by.includes(ancestors[i])) {
        return true;
      }
    }
  }
  return "descendant" in disallowed ? !disallowed.descendant.includes(tag2) : true;
}
function is_tag_valid_with_parent(tag2, parent_tag) {
  if (tag2.includes("-") || (parent_tag == null ? void 0 : parent_tag.includes("-"))) return true;
  if (parent_tag !== null) {
    const disallowed = disallowed_children[parent_tag];
    if (disallowed) {
      if ("direct" in disallowed && disallowed.direct.includes(tag2)) {
        return false;
      }
      if ("descendant" in disallowed && disallowed.descendant.includes(tag2)) {
        return false;
      }
      if ("only" in disallowed && disallowed.only) {
        return disallowed.only.includes(tag2);
      }
    }
  }
  switch (tag2) {
    case "body":
    case "caption":
    case "col":
    case "colgroup":
    case "frameset":
    case "frame":
    case "head":
    case "html":
    case "tbody":
    case "td":
    case "tfoot":
    case "th":
    case "thead":
    case "tr":
      return false;
  }
  return true;
}

// node_modules/svelte/src/compiler/utils/string.js
function list(strings, conjunction = "or") {
  if (strings.length === 1) return strings[0];
  if (strings.length === 2) return `${strings[0]} ${conjunction} ${strings[1]}`;
  return `${strings.slice(0, -1).join(", ")} ${conjunction} ${strings[strings.length - 1]}`;
}

// node_modules/svelte/src/compiler/phases/1-parse/state/element.js
var regex_invalid_unquoted_attribute_value = /^(\/>|[\s"'=<>`])/;
var regex_closing_textarea_tag = /^<\/textarea(\s[^>]*)?>/i;
var regex_closing_comment = /-->/;
var regex_whitespace_or_slash_or_closing_tag = /(\s|\/|>)/;
var regex_token_ending_character = /[\s=/>"']/;
var regex_starts_with_quote_characters = /^["']/;
var regex_attribute_value = /^(?:"([^"]*)"|'([^'])*'|([^>\s]+))/;
var regex_valid_element_name = /^(?:![a-zA-Z]+|[a-zA-Z](?:[a-zA-Z0-9-]*[a-zA-Z0-9])?|[a-zA-Z][a-zA-Z0-9]*:[a-zA-Z][a-zA-Z0-9-]*[a-zA-Z0-9])$/;
var regex_valid_component_name = (
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#identifiers adjusted for our needs
  // (must start with uppercase letter if no dots, can contain dots)
  new RegExp("^(?:\\p{Lu}[$\\u200c\\u200d\\p{ID_Continue}.]*|\\p{ID_Start}[$\\u200c\\u200d\\p{ID_Continue}]*(?:\\.[$\\u200c\\u200d\\p{ID_Continue}]+)+)$", "u")
);
var root_only_meta_tags = /* @__PURE__ */ new Map([
  ["svelte:head", "SvelteHead"],
  ["svelte:options", "SvelteOptions"],
  ["svelte:window", "SvelteWindow"],
  ["svelte:document", "SvelteDocument"],
  ["svelte:body", "SvelteBody"]
]);
var meta_tags = new Map([
  ...root_only_meta_tags,
  ["svelte:element", "SvelteElement"],
  ["svelte:component", "SvelteComponent"],
  ["svelte:self", "SvelteSelf"],
  ["svelte:fragment", "SvelteFragment"]
]);
function element(parser) {
  const start = parser.index++;
  let parent = parser.current();
  if (parser.eat("!--")) {
    const data = parser.read_until(regex_closing_comment);
    parser.eat("-->", true);
    parser.append({
      type: "Comment",
      start,
      end: parser.index,
      data
    });
    return;
  }
  const is_closing_tag = parser.eat("/");
  const name = parser.read_until(regex_whitespace_or_slash_or_closing_tag);
  if (is_closing_tag) {
    parser.allow_whitespace();
    parser.eat(">", true);
    if (is_void(name)) {
      void_element_invalid_content(start);
    }
    while (
      /** @type {AST.RegularElement} */
      parent.name !== name
    ) {
      if (parent.type !== "RegularElement") {
        if (parser.last_auto_closed_tag && parser.last_auto_closed_tag.tag === name) {
          element_invalid_closing_tag_autoclosed(start, name, parser.last_auto_closed_tag.reason);
        } else {
          element_invalid_closing_tag(start, name);
        }
      }
      parent.end = start;
      parser.pop();
      parent = parser.current();
    }
    parent.end = parser.index;
    parser.pop();
    if (parser.last_auto_closed_tag && parser.stack.length < parser.last_auto_closed_tag.depth) {
      parser.last_auto_closed_tag = void 0;
    }
    return;
  }
  if (name.startsWith("svelte:") && !meta_tags.has(name)) {
    const bounds = { start: start + 1, end: start + 1 + name.length };
    svelte_meta_invalid_tag(bounds, list(Array.from(meta_tags.keys())));
  }
  if (!regex_valid_element_name.test(name) && !regex_valid_component_name.test(name)) {
    const bounds = { start: start + 1, end: start + 1 + name.length };
    tag_invalid_name(bounds);
  }
  if (root_only_meta_tags.has(name)) {
    if (name in parser.meta_tags) {
      svelte_meta_duplicate(start, name);
    }
    if (parent.type !== "Root") {
      svelte_meta_invalid_placement(start, name);
    }
    parser.meta_tags[name] = true;
  }
  const type = meta_tags.has(name) ? meta_tags.get(name) : regex_valid_component_name.test(name) ? "Component" : name === "title" && parent_is_head(parser.stack) ? "TitleElement" : (
    // TODO Svelte 6/7: once slots are removed in favor of snippets, always keep slot as a regular element
    name === "slot" && !parent_is_shadowroot_template(parser.stack) ? "SlotElement" : "RegularElement"
  );
  const element2 = type === "RegularElement" ? {
    type,
    start,
    end: -1,
    name,
    attributes: [],
    fragment: create_fragment(true),
    metadata: {
      svg: false,
      mathml: false,
      scoped: false,
      has_spread: false,
      path: []
    },
    parent: null
  } : (
    /** @type {ElementLike} */
    {
      type,
      start,
      end: -1,
      name,
      attributes: [],
      fragment: create_fragment(true),
      parent: null,
      metadata: {
        // unpopulated at first, differs between types
      }
    }
  );
  parser.allow_whitespace();
  if (parent.type === "RegularElement" && closing_tag_omitted(parent.name, name)) {
    parent.end = start;
    parser.pop();
    parser.last_auto_closed_tag = {
      tag: parent.name,
      reason: name,
      depth: parser.stack.length
    };
  }
  const unique_names = [];
  const current = parser.current();
  const is_top_level_script_or_style = (name === "script" || name === "style") && current.type === "Root";
  const read = is_top_level_script_or_style ? read_static_attribute : read_attribute;
  let attribute;
  while (attribute = read(parser)) {
    if (attribute.type === "Attribute" || attribute.type === "BindDirective" || attribute.type === "StyleDirective" || attribute.type === "ClassDirective") {
      const type2 = attribute.type === "BindDirective" ? "Attribute" : attribute.type;
      if (unique_names.includes(type2 + attribute.name)) {
        attribute_duplicate(attribute);
      } else if (attribute.name !== "this") {
        unique_names.push(type2 + attribute.name);
      }
    }
    element2.attributes.push(attribute);
    parser.allow_whitespace();
  }
  if (element2.type === "SvelteComponent") {
    const index = element2.attributes.findIndex(
      /** @param {any} attr */
      (attr) => attr.type === "Attribute" && attr.name === "this"
    );
    if (index === -1) {
      svelte_component_missing_this(start);
    }
    const definition = (
      /** @type {AST.Attribute} */
      element2.attributes.splice(index, 1)[0]
    );
    if (!is_expression_attribute(definition)) {
      svelte_component_invalid_this(definition.start);
    }
    element2.expression = get_attribute_expression(definition);
  }
  if (element2.type === "SvelteElement") {
    const index = element2.attributes.findIndex(
      /** @param {any} attr */
      (attr) => attr.type === "Attribute" && attr.name === "this"
    );
    if (index === -1) {
      svelte_element_missing_this(start);
    }
    const definition = (
      /** @type {AST.Attribute} */
      element2.attributes.splice(index, 1)[0]
    );
    if (definition.value === true) {
      svelte_element_missing_this(definition);
    }
    if (!is_expression_attribute(definition)) {
      svelte_element_invalid_this(definition);
      const chunk = (
        /** @type {Array<AST.ExpressionTag | AST.Text>} */
        definition.value[0]
      );
      element2.tag = chunk.type === "Text" ? {
        type: "Literal",
        value: chunk.data,
        raw: `'${chunk.raw}'`,
        start: chunk.start,
        end: chunk.end
      } : chunk.expression;
    } else {
      element2.tag = get_attribute_expression(definition);
    }
  }
  if (is_top_level_script_or_style) {
    parser.eat(">", true);
    let prev_comment = null;
    for (let i = current.fragment.nodes.length - 1; i >= 0; i--) {
      const node = current.fragment.nodes[i];
      if (i === current.fragment.nodes.length - 1 && node.end !== start) {
        break;
      }
      if (node.type === "Comment") {
        prev_comment = node;
        break;
      } else if (node.type !== "Text" || node.data.trim()) {
        break;
      }
    }
    if (name === "script") {
      const content = read_script(parser, start, element2.attributes);
      if (prev_comment) {
        content.content.leadingComments = [{ type: "Line", value: prev_comment.data }];
      }
      if (content.context === "module") {
        if (current.module) script_duplicate(start);
        current.module = content;
      } else {
        if (current.instance) script_duplicate(start);
        current.instance = content;
      }
    } else {
      const content = read_style(parser, start, element2.attributes);
      content.content.comment = prev_comment;
      if (current.css) style_duplicate(start);
      current.css = content;
    }
    return;
  }
  parser.append(element2);
  const self_closing = parser.eat("/") || is_void(name);
  parser.eat(">", true);
  if (self_closing) {
    element2.end = parser.index;
  } else if (name === "textarea") {
    element2.fragment.nodes = read_sequence(
      parser,
      () => regex_closing_textarea_tag.test(parser.template.slice(parser.index)),
      "inside <textarea>"
    );
    parser.read(regex_closing_textarea_tag);
    element2.end = parser.index;
  } else if (name === "script" || name === "style") {
    const start2 = parser.index;
    const data = parser.read_until(new RegExp(`</${name}>`));
    const end = parser.index;
    const node = {
      start: start2,
      end,
      type: "Text",
      data,
      raw: data,
      parent: null
    };
    element2.fragment.nodes.push(node);
    parser.eat(`</${name}>`, true);
    element2.end = parser.index;
  } else {
    parser.stack.push(element2);
    parser.fragments.push(element2.fragment);
  }
}
function parent_is_head(stack) {
  let i = stack.length;
  while (i--) {
    const { type } = stack[i];
    if (type === "SvelteHead") return true;
    if (type === "RegularElement" || type === "Component") return false;
  }
  return false;
}
function parent_is_shadowroot_template(stack) {
  let i = stack.length;
  while (i--) {
    if (stack[i].type === "RegularElement" && /** @type {AST.RegularElement} */
    stack[i].attributes.some(
      (a) => a.type === "Attribute" && a.name === "shadowrootmode"
    )) {
      return true;
    }
  }
  return false;
}
function read_static_attribute(parser) {
  const start = parser.index;
  const name = parser.read_until(regex_token_ending_character);
  if (!name) return null;
  let value = true;
  if (parser.eat("=")) {
    parser.allow_whitespace();
    let raw = parser.match_regex(regex_attribute_value);
    if (!raw) {
      expected_attribute_value(parser.index);
    }
    parser.index += raw.length;
    const quoted = raw[0] === '"' || raw[0] === "'";
    if (quoted) {
      raw = raw.slice(1, -1);
    }
    value = [
      {
        start: parser.index - raw.length - (quoted ? 1 : 0),
        end: quoted ? parser.index - 1 : parser.index,
        type: "Text",
        raw,
        data: decode_character_references(raw, true),
        parent: null
      }
    ];
  }
  if (parser.match_regex(regex_starts_with_quote_characters)) {
    expected_token(parser.index, "=");
  }
  return create_attribute(name, start, parser.index, value);
}
function read_attribute(parser) {
  const start = parser.index;
  if (parser.eat("{")) {
    parser.allow_whitespace();
    if (parser.eat("...")) {
      const expression = read_expression(parser);
      parser.allow_whitespace();
      parser.eat("}", true);
      const spread2 = {
        type: "SpreadAttribute",
        start,
        end: parser.index,
        expression,
        parent: null,
        metadata: {
          expression: create_expression_metadata()
        }
      };
      return spread2;
    } else {
      const value_start = parser.index;
      const name2 = parser.read_identifier();
      if (name2 === null) {
        attribute_empty_shorthand(start);
      }
      parser.allow_whitespace();
      parser.eat("}", true);
      const expression = {
        type: "ExpressionTag",
        start: value_start,
        end: value_start + name2.length,
        expression: {
          start: value_start,
          end: value_start + name2.length,
          type: "Identifier",
          name: name2
        },
        parent: null,
        metadata: {
          expression: create_expression_metadata()
        }
      };
      return create_attribute(name2, start, parser.index, expression);
    }
  }
  const name = parser.read_until(regex_token_ending_character);
  if (!name) return null;
  let end = parser.index;
  parser.allow_whitespace();
  const colon_index = name.indexOf(":");
  const type = colon_index !== -1 && get_directive_type(name.slice(0, colon_index));
  let value = true;
  if (parser.eat("=")) {
    parser.allow_whitespace();
    value = read_attribute_value2(parser);
    end = parser.index;
  } else if (parser.match_regex(regex_starts_with_quote_characters)) {
    expected_token(parser.index, "=");
  }
  if (type) {
    const [directive_name, ...modifiers2] = name.slice(colon_index + 1).split("|");
    if (directive_name === "") {
      directive_missing_name({ start, end: start + colon_index + 1 }, name);
    }
    if (type === "StyleDirective") {
      return {
        start,
        end,
        type,
        name: directive_name,
        modifiers: (
          /** @type {Array<'important'>} */
          modifiers2
        ),
        value,
        parent: null,
        metadata: {
          expression: create_expression_metadata()
        }
      };
    }
    const first_value = value === true ? void 0 : Array.isArray(value) ? value[0] : value;
    let expression = null;
    if (first_value) {
      const attribute_contains_text = (
        /** @type {any[]} */
        value.length > 1 || first_value.type === "Text"
      );
      if (attribute_contains_text) {
        directive_invalid_value(
          /** @type {number} */
          first_value.start
        );
      } else {
        expression = first_value.expression;
      }
    }
    const directive = {
      start,
      end,
      type,
      name: directive_name,
      modifiers: modifiers2,
      expression,
      metadata: {
        expression: create_expression_metadata()
      }
    };
    if (directive.type === "TransitionDirective") {
      const direction = name.slice(0, colon_index);
      directive.intro = direction === "in" || direction === "transition";
      directive.outro = direction === "out" || direction === "transition";
    }
    if ((directive.type === "BindDirective" || directive.type === "ClassDirective") && !directive.expression) {
      directive.expression = /** @type {any} */
      {
        start: start + colon_index + 1,
        end,
        type: "Identifier",
        name: directive.name
      };
    }
    return directive;
  }
  return create_attribute(name, start, end, value);
}
function get_directive_type(name) {
  if (name === "use") return "UseDirective";
  if (name === "animate") return "AnimateDirective";
  if (name === "bind") return "BindDirective";
  if (name === "class") return "ClassDirective";
  if (name === "style") return "StyleDirective";
  if (name === "on") return "OnDirective";
  if (name === "let") return "LetDirective";
  if (name === "in" || name === "out" || name === "transition") return "TransitionDirective";
  return false;
}
function read_attribute_value2(parser) {
  var _a2;
  const quote_mark = parser.eat("'") ? "'" : parser.eat('"') ? '"' : null;
  if (quote_mark && parser.eat(quote_mark)) {
    return [
      {
        start: parser.index - 1,
        end: parser.index - 1,
        type: "Text",
        raw: "",
        data: "",
        parent: null
      }
    ];
  }
  let value;
  try {
    value = read_sequence(
      parser,
      () => {
        if (quote_mark) return parser.match(quote_mark);
        return !!parser.match_regex(regex_invalid_unquoted_attribute_value);
      },
      "in attribute value"
    );
  } catch (error) {
    if (error.code === "js_parse_error") {
      const pos = (_a2 = error.position) == null ? void 0 : _a2[0];
      if (pos !== void 0 && parser.template.slice(pos - 1, pos + 1) === "/>") {
        parser.index = pos;
        expected_token(pos, quote_mark || "}");
      }
    }
    throw error;
  }
  if (value.length === 0 && !quote_mark) {
    expected_attribute_value(parser.index);
  }
  if (quote_mark) parser.index += 1;
  if (quote_mark || value.length > 1 || value[0].type === "Text") {
    return value;
  } else {
    return value[0];
  }
}
function read_sequence(parser, done, location) {
  let current_chunk = {
    start: parser.index,
    end: -1,
    type: "Text",
    raw: "",
    data: "",
    parent: null
  };
  const chunks = [];
  function flush(end) {
    if (current_chunk.raw) {
      current_chunk.data = decode_character_references(current_chunk.raw, true);
      current_chunk.end = end;
      chunks.push(current_chunk);
    }
  }
  while (parser.index < parser.template.length) {
    const index = parser.index;
    if (done()) {
      flush(parser.index);
      return chunks;
    } else if (parser.eat("{")) {
      if (parser.match("#")) {
        const index2 = parser.index - 1;
        parser.eat("#");
        const name = parser.read_until(/[^a-z]/);
        block_invalid_placement(index2, name, location);
      } else if (parser.match("@")) {
        const index2 = parser.index - 1;
        parser.eat("@");
        const name = parser.read_until(/[^a-z]/);
        tag_invalid_placement(index2, name, location);
      }
      flush(parser.index - 1);
      parser.allow_whitespace();
      const expression = read_expression(parser);
      parser.allow_whitespace();
      parser.eat("}", true);
      const chunk = {
        type: "ExpressionTag",
        start: index,
        end: parser.index,
        expression,
        parent: null,
        metadata: {
          expression: create_expression_metadata()
        }
      };
      chunks.push(chunk);
      current_chunk = {
        start: parser.index,
        end: -1,
        type: "Text",
        raw: "",
        data: "",
        parent: null
      };
    } else {
      current_chunk.raw += parser.template[parser.index++];
    }
  }
  unexpected_eof(parser.template.length);
}

// node_modules/svelte/src/compiler/phases/1-parse/utils/full_char_code_at.js
function full_char_code_at(str, i) {
  const code = str.charCodeAt(i);
  if (code <= 55295 || code >= 57344) return code;
  const next2 = str.charCodeAt(i + 1);
  return (code << 10) + next2 - 56613888;
}

// node_modules/svelte/src/compiler/phases/1-parse/utils/bracket.js
var SQUARE_BRACKET_OPEN = "[".charCodeAt(0);
var SQUARE_BRACKET_CLOSE = "]".charCodeAt(0);
var CURLY_BRACKET_OPEN = "{".charCodeAt(0);
var CURLY_BRACKET_CLOSE = "}".charCodeAt(0);
function is_bracket_open(code) {
  return code === SQUARE_BRACKET_OPEN || code === CURLY_BRACKET_OPEN;
}
function is_bracket_close(code) {
  return code === SQUARE_BRACKET_CLOSE || code === CURLY_BRACKET_CLOSE;
}
function is_bracket_pair(open2, close2) {
  return open2 === SQUARE_BRACKET_OPEN && close2 === SQUARE_BRACKET_CLOSE || open2 === CURLY_BRACKET_OPEN && close2 === CURLY_BRACKET_CLOSE;
}
function get_bracket_close(open2) {
  if (open2 === SQUARE_BRACKET_OPEN) {
    return SQUARE_BRACKET_CLOSE;
  }
  if (open2 === CURLY_BRACKET_OPEN) {
    return CURLY_BRACKET_CLOSE;
  }
}

// node_modules/svelte/src/compiler/phases/1-parse/read/context.js
function read_pattern(parser) {
  const start = parser.index;
  let i = parser.index;
  const code = full_char_code_at(parser.template, i);
  if (isIdentifierStart(code, true)) {
    const name = (
      /** @type {string} */
      parser.read_identifier()
    );
    const annotation = read_type_annotation(parser);
    return {
      type: "Identifier",
      name,
      start,
      loc: {
        start: (
          /** @type {Location} */
          locator(start)
        ),
        end: (
          /** @type {Location} */
          locator(parser.index)
        )
      },
      end: parser.index,
      typeAnnotation: annotation
    };
  }
  if (!is_bracket_open(code)) {
    expected_pattern(i);
  }
  const bracket_stack = [code];
  i += code <= 65535 ? 1 : 2;
  while (i < parser.template.length) {
    const code2 = full_char_code_at(parser.template, i);
    if (is_bracket_open(code2)) {
      bracket_stack.push(code2);
    } else if (is_bracket_close(code2)) {
      const popped = (
        /** @type {number} */
        bracket_stack.pop()
      );
      if (!is_bracket_pair(popped, code2)) {
        expected_token(i, String.fromCharCode(
          /** @type {number} */
          get_bracket_close(popped)
        ));
      }
      if (bracket_stack.length === 0) {
        i += code2 <= 65535 ? 1 : 2;
        break;
      }
    }
    i += code2 <= 65535 ? 1 : 2;
  }
  parser.index = i;
  const pattern_string = parser.template.slice(start, i);
  try {
    let space_with_newline = parser.template.slice(0, start).replace(regex_not_newline_characters, " ");
    const first_space = space_with_newline.indexOf(" ");
    space_with_newline = space_with_newline.slice(0, first_space) + space_with_newline.slice(first_space + 1);
    const expression = (
      /** @type {any} */
      parse_expression_at(`${space_with_newline}(${pattern_string} = 1)`, parser.ts, start - 1).left
    );
    expression.typeAnnotation = read_type_annotation(parser);
    if (expression.typeAnnotation) {
      expression.end = expression.typeAnnotation.end;
    }
    return expression;
  } catch (error) {
    parser.acorn_error(error);
  }
}
function read_type_annotation(parser) {
  const start = parser.index;
  parser.allow_whitespace();
  if (!parser.eat(":")) {
    parser.index = start;
    return void 0;
  }
  const insert = "_ as ";
  let a = parser.index - insert.length;
  const template3 = parser.template.slice(0, a).replace(/[^\n]/g, " ") + insert + // If this is a type annotation for a function parameter, Acorn-TS will treat subsequent
  // parameters as part of a sequence expression instead, and will then error on optional
  // parameters (`?:`). Therefore replace that sequence with something that will not error.
  parser.template.slice(parser.index).replace(/\?\s*:/g, ":");
  let expression = parse_expression_at(template3, parser.ts, a);
  if (expression.type === "AssignmentExpression") {
    let b = expression.right.start;
    while (template3[b] !== "=") b -= 1;
    expression = parse_expression_at(template3.slice(0, b), parser.ts, a);
  }
  if (expression.type === "SequenceExpression") {
    expression = expression.expressions[0];
  }
  parser.index = /** @type {number} */
  expression.end;
  return {
    type: "TSTypeAnnotation",
    start,
    end: parser.index,
    typeAnnotation: (
      /** @type {any} */
      expression.typeAnnotation
    )
  };
}

// node_modules/svelte/src/compiler/phases/1-parse/state/tag.js
var regex_whitespace_with_closing_curly_brace = /^\s*}/;
function tag(parser) {
  const start = parser.index;
  parser.index += 1;
  parser.allow_whitespace();
  if (parser.eat("#")) return open(parser);
  if (parser.eat(":")) return next(parser);
  if (parser.eat("@")) return special(parser);
  if (parser.match("/")) {
    if (!parser.match("/*") && !parser.match("//")) {
      parser.eat("/");
      return close(parser);
    }
  }
  const expression = read_expression(parser);
  parser.allow_whitespace();
  parser.eat("}", true);
  parser.append({
    type: "ExpressionTag",
    start,
    end: parser.index,
    expression,
    metadata: {
      expression: create_expression_metadata()
    }
  });
}
function open(parser) {
  let start = parser.index - 2;
  while (parser.template[start] !== "{") start -= 1;
  if (parser.eat("if")) {
    parser.require_whitespace();
    const block2 = parser.append({
      type: "IfBlock",
      elseif: false,
      start,
      end: -1,
      test: read_expression(parser),
      consequent: create_fragment(),
      alternate: null
    });
    parser.allow_whitespace();
    parser.eat("}", true);
    parser.stack.push(block2);
    parser.fragments.push(block2.consequent);
    return;
  }
  if (parser.eat("each")) {
    parser.require_whitespace();
    const template3 = parser.template;
    let end = parser.template.length;
    let expression;
    while (!expression) {
      try {
        expression = read_expression(parser);
      } catch (err) {
        end = /** @type {any} */
        err.position[0] - 2;
        while (end > start && parser.template.slice(end, end + 2) !== "as") {
          end -= 1;
        }
        if (end <= start) throw err;
        parser.template = template3.slice(0, end);
      }
    }
    parser.template = template3;
    parser.allow_whitespace();
    if (!parser.match("as")) {
      if (expression.type === "SequenceExpression") {
        expression = expression.expressions[0];
      }
      let assertion = null;
      let end2 = expression.end;
      expression = walk(expression, null, {
        // @ts-expect-error
        TSAsExpression(node, context2) {
          if (node.end === /** @type {Expression} */
          expression.end) {
            assertion = node;
            end2 = node.expression.end;
            return node.expression;
          }
          context2.next();
        }
      });
      expression.end = end2;
      if (assertion) {
        let end3 = (
          /** @type {any} */
          /** @type {any} */
          assertion.typeAnnotation.start - 2
        );
        while (parser.template.slice(end3, end3 + 2) !== "as") end3 -= 1;
        parser.index = end3;
      }
    }
    parser.eat("as", true);
    parser.require_whitespace();
    const context = read_pattern(parser);
    parser.allow_whitespace();
    let index;
    let key2;
    if (parser.eat(",")) {
      parser.allow_whitespace();
      index = parser.read_identifier();
      if (!index) {
        expected_identifier(parser.index);
      }
      parser.allow_whitespace();
    }
    if (parser.eat("(")) {
      parser.allow_whitespace();
      key2 = read_expression(parser);
      parser.allow_whitespace();
      parser.eat(")", true);
      parser.allow_whitespace();
    }
    parser.eat("}", true);
    const block2 = parser.append({
      type: "EachBlock",
      start,
      end: -1,
      expression,
      body: create_fragment(),
      context,
      index,
      key: key2,
      metadata: (
        /** @type {any} */
        null
      )
      // filled in later
    });
    parser.stack.push(block2);
    parser.fragments.push(block2.body);
    return;
  }
  if (parser.eat("await")) {
    parser.require_whitespace();
    const expression = read_expression(parser);
    parser.allow_whitespace();
    const block2 = parser.append({
      type: "AwaitBlock",
      start,
      end: -1,
      expression,
      value: null,
      error: null,
      pending: null,
      then: null,
      catch: null
    });
    if (parser.eat("then")) {
      if (parser.match_regex(regex_whitespace_with_closing_curly_brace)) {
        parser.allow_whitespace();
      } else {
        parser.require_whitespace();
        block2.value = read_pattern(parser);
        parser.allow_whitespace();
      }
      block2.then = create_fragment();
      parser.fragments.push(block2.then);
    } else if (parser.eat("catch")) {
      if (parser.match_regex(regex_whitespace_with_closing_curly_brace)) {
        parser.allow_whitespace();
      } else {
        parser.require_whitespace();
        block2.error = read_pattern(parser);
        parser.allow_whitespace();
      }
      block2.catch = create_fragment();
      parser.fragments.push(block2.catch);
    } else {
      block2.pending = create_fragment();
      parser.fragments.push(block2.pending);
    }
    parser.eat("}", true);
    parser.stack.push(block2);
    return;
  }
  if (parser.eat("key")) {
    parser.require_whitespace();
    const expression = read_expression(parser);
    parser.allow_whitespace();
    parser.eat("}", true);
    const block2 = parser.append({
      type: "KeyBlock",
      start,
      end: -1,
      expression,
      fragment: create_fragment()
    });
    parser.stack.push(block2);
    parser.fragments.push(block2.fragment);
    return;
  }
  if (parser.eat("snippet")) {
    parser.require_whitespace();
    const name_start = parser.index;
    const name = parser.read_identifier();
    const name_end = parser.index;
    if (name === null) {
      expected_identifier(parser.index);
    }
    parser.allow_whitespace();
    const params_start = parser.index;
    parser.eat("(", true);
    let parentheses = 1;
    while (parser.index < parser.template.length && (!parser.match(")") || parentheses !== 1)) {
      if (parser.match("(")) parentheses++;
      if (parser.match(")")) parentheses--;
      parser.index += 1;
    }
    parser.eat(")", true);
    const prelude = parser.template.slice(0, params_start).replace(/\S/g, " ");
    const params = parser.template.slice(params_start, parser.index);
    let function_expression = (
      /** @type {ArrowFunctionExpression} */
      parse_expression_at(prelude + `${params} => {}`, parser.ts, params_start)
    );
    parser.allow_whitespace();
    parser.eat("}", true);
    const block2 = parser.append({
      type: "SnippetBlock",
      start,
      end: -1,
      expression: {
        type: "Identifier",
        start: name_start,
        end: name_end,
        name
      },
      parameters: function_expression.params,
      body: create_fragment()
    });
    parser.stack.push(block2);
    parser.fragments.push(block2.body);
    return;
  }
  expected_block_type(parser.index);
}
function next(parser) {
  const start = parser.index - 1;
  const block2 = parser.current();
  if (block2.type === "IfBlock") {
    if (!parser.eat("else")) expected_token(start, "{:else} or {:else if}");
    if (parser.eat("if")) block_invalid_elseif(start);
    parser.allow_whitespace();
    parser.fragments.pop();
    block2.alternate = create_fragment();
    parser.fragments.push(block2.alternate);
    if (parser.eat("if")) {
      parser.require_whitespace();
      const expression = read_expression(parser);
      parser.allow_whitespace();
      parser.eat("}", true);
      let elseif_start = start - 1;
      while (parser.template[elseif_start] !== "{") elseif_start -= 1;
      const child = parser.append({
        start: elseif_start,
        end: -1,
        type: "IfBlock",
        elseif: true,
        test: expression,
        consequent: create_fragment(),
        alternate: null
      });
      parser.stack.push(child);
      parser.fragments.pop();
      parser.fragments.push(child.consequent);
    } else {
      parser.allow_whitespace();
      parser.eat("}", true);
    }
    return;
  }
  if (block2.type === "EachBlock") {
    if (!parser.eat("else")) expected_token(start, "{:else}");
    parser.allow_whitespace();
    parser.eat("}", true);
    block2.fallback = create_fragment();
    parser.fragments.pop();
    parser.fragments.push(block2.fallback);
    return;
  }
  if (block2.type === "AwaitBlock") {
    if (parser.eat("then")) {
      if (block2.then) {
        block_duplicate_clause(start, "{:then}");
      }
      if (!parser.eat("}")) {
        parser.require_whitespace();
        block2.value = read_pattern(parser);
        parser.allow_whitespace();
        parser.eat("}", true);
      }
      block2.then = create_fragment();
      parser.fragments.pop();
      parser.fragments.push(block2.then);
      return;
    }
    if (parser.eat("catch")) {
      if (block2.catch) {
        block_duplicate_clause(start, "{:catch}");
      }
      if (!parser.eat("}")) {
        parser.require_whitespace();
        block2.error = read_pattern(parser);
        parser.allow_whitespace();
        parser.eat("}", true);
      }
      block2.catch = create_fragment();
      parser.fragments.pop();
      parser.fragments.push(block2.catch);
      return;
    }
    expected_token(start, "{:then ...} or {:catch ...}");
  }
  block_invalid_continuation_placement(start);
}
function close(parser) {
  const start = parser.index - 1;
  let block2 = parser.current();
  switch (block2.type) {
    case "IfBlock":
      parser.eat("if", true);
      parser.allow_whitespace();
      parser.eat("}", true);
      while (block2.elseif) {
        block2.end = parser.index;
        parser.stack.pop();
        block2 = /** @type {AST.IfBlock} */
        parser.current();
      }
      block2.end = parser.index;
      parser.pop();
      return;
    case "EachBlock":
      parser.eat("each", true);
      break;
    case "KeyBlock":
      parser.eat("key", true);
      break;
    case "AwaitBlock":
      parser.eat("await", true);
      break;
    case "SnippetBlock":
      parser.eat("snippet", true);
      break;
    case "RegularElement":
      block_unexpected_close(start);
      break;
    default:
      block_unexpected_close(start);
  }
  parser.allow_whitespace();
  parser.eat("}", true);
  block2.end = parser.index;
  parser.pop();
}
function special(parser) {
  let start = parser.index;
  while (parser.template[start] !== "{") start -= 1;
  if (parser.eat("html")) {
    parser.require_whitespace();
    const expression = read_expression(parser);
    parser.allow_whitespace();
    parser.eat("}", true);
    parser.append({
      type: "HtmlTag",
      start,
      end: parser.index,
      expression
    });
    return;
  }
  if (parser.eat("debug")) {
    let identifiers;
    if (parser.read(regex_whitespace_with_closing_curly_brace)) {
      identifiers = [];
    } else {
      const expression = read_expression(parser);
      identifiers = expression.type === "SequenceExpression" ? (
        /** @type {Identifier[]} */
        expression.expressions
      ) : [
        /** @type {Identifier} */
        expression
      ];
      identifiers.forEach(
        /** @param {any} node */
        (node) => {
          if (node.type !== "Identifier") {
            debug_tag_invalid_arguments(
              /** @type {number} */
              node.start
            );
          }
        }
      );
      parser.allow_whitespace();
      parser.eat("}", true);
    }
    parser.append({
      type: "DebugTag",
      start,
      end: parser.index,
      identifiers
    });
    return;
  }
  if (parser.eat("const")) {
    parser.require_whitespace();
    const id2 = read_pattern(parser);
    parser.allow_whitespace();
    parser.eat("=", true);
    parser.allow_whitespace();
    const expression_start = parser.index;
    const init2 = read_expression(parser);
    if (init2.type === "SequenceExpression" && !parser.template.substring(expression_start, init2.start).includes("(")) {
      const_tag_invalid_expression(init2);
    }
    parser.allow_whitespace();
    parser.eat("}", true);
    parser.append({
      type: "ConstTag",
      start,
      end: parser.index,
      declaration: {
        type: "VariableDeclaration",
        kind: "const",
        declarations: [{ type: "VariableDeclarator", id: id2, init: init2, start: id2.start, end: init2.end }],
        start: start + 2,
        // start at const, not at @const
        end: parser.index - 1
      }
    });
  }
  if (parser.eat("render")) {
    parser.require_whitespace();
    const expression = read_expression(parser);
    if (expression.type !== "CallExpression" && (expression.type !== "ChainExpression" || expression.expression.type !== "CallExpression")) {
      render_tag_invalid_expression(expression);
    }
    parser.allow_whitespace();
    parser.eat("}", true);
    parser.append({
      type: "RenderTag",
      start,
      end: parser.index,
      expression,
      metadata: {
        dynamic: false,
        args_with_call_expression: /* @__PURE__ */ new Set()
      }
    });
  }
}

// node_modules/svelte/src/compiler/phases/1-parse/state/text.js
function text(parser) {
  const start = parser.index;
  let data = "";
  while (parser.index < parser.template.length && !parser.match("<") && !parser.match("{")) {
    data += parser.template[parser.index++];
  }
  parser.append({
    type: "Text",
    start,
    end: parser.index,
    raw: data,
    data: decode_character_references(data, false)
  });
}

// node_modules/svelte/src/compiler/phases/1-parse/state/fragment.js
function fragment(parser) {
  if (parser.match("<")) {
    return element;
  }
  if (parser.match("{")) {
    return tag;
  }
  return text;
}

// node_modules/svelte/src/compiler/phases/1-parse/read/options.js
function read_options(node) {
  var _a2, _b2, _c, _d;
  const component_options = {
    start: node.start,
    end: node.end,
    // @ts-ignore
    attributes: node.attributes
  };
  if (!node) {
    return component_options;
  }
  for (const attribute of node.attributes) {
    if (attribute.type !== "Attribute") {
      svelte_options_invalid_attribute(attribute);
    }
    const { name } = attribute;
    switch (name) {
      case "runes": {
        component_options.runes = get_boolean_value(attribute);
        break;
      }
      case "tag": {
        svelte_options_deprecated_tag(attribute);
        break;
      }
      case "customElement": {
        const ce = {};
        const { value: v } = attribute;
        const value = v === true || Array.isArray(v) ? v : [v];
        if (value === true) {
          svelte_options_invalid_customelement(attribute);
        } else if (value[0].type === "Text") {
          const tag3 = get_static_value(attribute);
          validate_tag(attribute, tag3);
          ce.tag = tag3;
          component_options.customElement = ce;
          break;
        } else if (value[0].expression.type !== "ObjectExpression") {
          if (value[0].expression.type === "Literal" && value[0].expression.value === null) {
            break;
          }
          svelte_options_invalid_customelement(attribute);
        }
        const properties = [];
        for (const property of value[0].expression.properties) {
          if (property.type !== "Property" || property.computed || property.key.type !== "Identifier") {
            svelte_options_invalid_customelement(attribute);
          }
          properties.push([property.key.name, property.value]);
        }
        const tag2 = properties.find(([name2]) => name2 === "tag");
        if (tag2) {
          const tag_value = (_a2 = tag2[1]) == null ? void 0 : _a2.value;
          validate_tag(tag2, tag_value);
          ce.tag = tag_value;
        }
        const props = (_b2 = properties.find(([name2]) => name2 === "props")) == null ? void 0 : _b2[1];
        if (props) {
          if (props.type !== "ObjectExpression") {
            svelte_options_invalid_customelement_props(attribute);
          }
          ce.props = {};
          for (
            const property of
            /** @type {ObjectExpression} */
            props.properties
          ) {
            if (property.type !== "Property" || property.computed || property.key.type !== "Identifier" || property.value.type !== "ObjectExpression") {
              svelte_options_invalid_customelement_props(attribute);
            }
            ce.props[property.key.name] = {};
            for (const prop2 of property.value.properties) {
              if (prop2.type !== "Property" || prop2.computed || prop2.key.type !== "Identifier" || prop2.value.type !== "Literal") {
                svelte_options_invalid_customelement_props(attribute);
              }
              if (prop2.key.name === "type") {
                if (["String", "Number", "Boolean", "Array", "Object"].indexOf(
                  /** @type {string} */
                  prop2.value.value
                ) === -1) {
                  svelte_options_invalid_customelement_props(attribute);
                }
                ce.props[property.key.name].type = /** @type {any} */
                prop2.value.value;
              } else if (prop2.key.name === "reflect") {
                if (typeof prop2.value.value !== "boolean") {
                  svelte_options_invalid_customelement_props(attribute);
                }
                ce.props[property.key.name].reflect = prop2.value.value;
              } else if (prop2.key.name === "attribute") {
                if (typeof prop2.value.value !== "string") {
                  svelte_options_invalid_customelement_props(attribute);
                }
                ce.props[property.key.name].attribute = prop2.value.value;
              } else {
                svelte_options_invalid_customelement_props(attribute);
              }
            }
          }
        }
        const shadow = (_c = properties.find(([name2]) => name2 === "shadow")) == null ? void 0 : _c[1];
        if (shadow) {
          const shadowdom = shadow == null ? void 0 : shadow.value;
          if (shadowdom !== "open" && shadowdom !== "none") {
            svelte_options_invalid_customelement_shadow(shadow);
          }
          ce.shadow = shadowdom;
        }
        const extend = (_d = properties.find(([name2]) => name2 === "extend")) == null ? void 0 : _d[1];
        if (extend) {
          ce.extend = extend;
        }
        component_options.customElement = ce;
        break;
      }
      case "namespace": {
        const value = get_static_value(attribute);
        if (value === NAMESPACE_SVG) {
          component_options.namespace = "svg";
        } else if (value === NAMESPACE_MATHML) {
          component_options.namespace = "mathml";
        } else if (value === "html" || value === "mathml" || value === "svg") {
          component_options.namespace = value;
        } else {
          svelte_options_invalid_attribute_value(attribute, `"html", "mathml" or "svg"`);
        }
        break;
      }
      case "css": {
        const value = get_static_value(attribute);
        if (value === "injected") {
          component_options.css = value;
        } else {
          svelte_options_invalid_attribute_value(attribute, `"injected"`);
        }
        break;
      }
      case "immutable": {
        component_options.immutable = get_boolean_value(attribute);
        break;
      }
      case "preserveWhitespace": {
        component_options.preserveWhitespace = get_boolean_value(attribute);
        break;
      }
      case "accessors": {
        component_options.accessors = get_boolean_value(attribute);
        break;
      }
      default:
        svelte_options_unknown_attribute(attribute, name);
    }
  }
  return component_options;
}
function get_static_value(attribute) {
  const { value } = attribute;
  if (value === true) return true;
  const chunk = Array.isArray(value) ? value[0] : value;
  if (!chunk) return true;
  if (value.length > 1) {
    return null;
  }
  if (chunk.type === "Text") return chunk.data;
  if (chunk.expression.type !== "Literal") {
    return null;
  }
  return chunk.expression.value;
}
function get_boolean_value(attribute) {
  const value = get_static_value(attribute);
  if (typeof value !== "boolean") {
    svelte_options_invalid_attribute_value(attribute, "true or false");
  }
  return value;
}
var tag_name_char = "[a-z0-9_.·À-ÖØ-öø-ͽͿ-῿‌-‍‿-⁀⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�𐀀-󯿿-]";
var regex_valid_tag_name = new RegExp(`^[a-z]${tag_name_char}*-${tag_name_char}*$`, "u");
var reserved_tag_names = [
  "annotation-xml",
  "color-profile",
  "font-face",
  "font-face-src",
  "font-face-uri",
  "font-face-format",
  "font-face-name",
  "missing-glyph"
];
function validate_tag(attribute, tag2) {
  if (typeof tag2 !== "string") {
    svelte_options_invalid_tagname(attribute);
  }
  if (tag2) {
    if (!regex_valid_tag_name.test(tag2)) {
      svelte_options_invalid_tagname(attribute);
    } else if (reserved_tag_names.includes(tag2)) {
      svelte_options_reserved_tagname(attribute);
    }
  }
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/shared/special-element.js
function disallow_children(node) {
  const { nodes } = node.fragment;
  if (nodes.length > 0) {
    const first = nodes[0];
    const last = nodes[nodes.length - 1];
    svelte_meta_invalid_content({ start: first.start, end: last.end }, node.name);
  }
}

// node_modules/svelte/src/compiler/phases/1-parse/index.js
var regex_position_indicator = / \(\d+:\d+\)$/;
var regex_lang_attribute = /<!--[^]*?-->|<script\s+(?:[^>]*|(?:[^=>'"/]+=(?:"[^"]*"|'[^']*'|[^>\s]+)\s+)*)lang=(["'])?([^"' >]+)\1[^>]*>/g;
var Parser2 = class {
  /** @param {string} template */
  constructor(template3) {
    /**
     * @readonly
     * @type {string}
     */
    __publicField(this, "template");
    /** */
    __publicField(this, "index", 0);
    /** Whether we're parsing in TypeScript mode */
    __publicField(this, "ts", false);
    /** @type {TemplateNode[]} */
    __publicField(this, "stack", []);
    /** @type {AST.Fragment[]} */
    __publicField(this, "fragments", []);
    /** @type {AST.Root} */
    __publicField(this, "root");
    /** @type {Record<string, boolean>} */
    __publicField(this, "meta_tags", {});
    /** @type {LastAutoClosedTag | undefined} */
    __publicField(this, "last_auto_closed_tag");
    if (typeof template3 !== "string") {
      throw new TypeError("Template must be a string");
    }
    this.template = template3.trimEnd();
    let match_lang;
    do
      match_lang = regex_lang_attribute.exec(template3);
    while (match_lang && match_lang[0][1] !== "s");
    regex_lang_attribute.lastIndex = 0;
    this.ts = (match_lang == null ? void 0 : match_lang[2]) === "ts";
    this.root = {
      css: null,
      js: [],
      // @ts-ignore
      start: null,
      // @ts-ignore
      end: null,
      type: "Root",
      fragment: create_fragment(),
      options: null,
      metadata: {
        ts: this.ts
      }
    };
    this.stack.push(this.root);
    this.fragments.push(this.root.fragment);
    let state = fragment;
    while (this.index < this.template.length) {
      state = state(this) || fragment;
    }
    if (this.stack.length > 1) {
      const current = this.current();
      if (current.type === "RegularElement") {
        current.end = current.start + 1;
        element_unclosed(current, current.name);
      } else {
        current.end = current.start + 1;
        block_unclosed(current);
      }
    }
    if (state !== fragment) {
      unexpected_eof(this.index);
    }
    if (this.root.fragment.nodes.length) {
      let start = (
        /** @type {number} */
        this.root.fragment.nodes[0].start
      );
      while (regex_whitespace.test(template3[start])) start += 1;
      let end = (
        /** @type {number} */
        this.root.fragment.nodes[this.root.fragment.nodes.length - 1].end
      );
      while (regex_whitespace.test(template3[end - 1])) end -= 1;
      this.root.start = start;
      this.root.end = end;
    } else {
      this.root.start = this.root.end = null;
    }
    const options_index = this.root.fragment.nodes.findIndex(
      /** @param {any} thing */
      (thing) => thing.type === "SvelteOptions"
    );
    if (options_index !== -1) {
      const options = (
        /** @type {AST.SvelteOptionsRaw} */
        this.root.fragment.nodes[options_index]
      );
      this.root.fragment.nodes.splice(options_index, 1);
      this.root.options = read_options(options);
      disallow_children(options);
      Object.defineProperty(this.root.options, "__raw__", {
        value: options,
        enumerable: false
      });
    }
  }
  current() {
    return this.stack[this.stack.length - 1];
  }
  /**
   * @param {any} err
   * @returns {never}
   */
  acorn_error(err) {
    js_parse_error(err.pos, err.message.replace(regex_position_indicator, ""));
  }
  /**
   * @param {string} str
   * @param {boolean} required
   */
  eat(str, required = false) {
    if (this.match(str)) {
      this.index += str.length;
      return true;
    }
    if (required) {
      expected_token(this.index, str);
    }
    return false;
  }
  /** @param {string} str */
  match(str) {
    const length = str.length;
    if (length === 1) {
      return this.template[this.index] === str;
    }
    return this.template.slice(this.index, this.index + length) === str;
  }
  /**
   * Match a regex at the current index
   * @param {RegExp} pattern  Should have a ^ anchor at the start so the regex doesn't search past the beginning, resulting in worse performance
   */
  match_regex(pattern) {
    const match = pattern.exec(this.template.slice(this.index));
    if (!match || match.index !== 0) return null;
    return match[0];
  }
  allow_whitespace() {
    while (this.index < this.template.length && regex_whitespace.test(this.template[this.index])) {
      this.index++;
    }
  }
  /**
   * Search for a regex starting at the current index and return the result if it matches
   * @param {RegExp} pattern  Should have a ^ anchor at the start so the regex doesn't search past the beginning, resulting in worse performance
   */
  read(pattern) {
    const result = this.match_regex(pattern);
    if (result) this.index += result.length;
    return result;
  }
  /** @param {any} allow_reserved */
  read_identifier(allow_reserved = false) {
    const start = this.index;
    let i = this.index;
    const code = full_char_code_at(this.template, i);
    if (!isIdentifierStart(code, true)) return null;
    i += code <= 65535 ? 1 : 2;
    while (i < this.template.length) {
      const code2 = full_char_code_at(this.template, i);
      if (!isIdentifierChar(code2, true)) break;
      i += code2 <= 65535 ? 1 : 2;
    }
    const identifier = this.template.slice(this.index, this.index = i);
    if (!allow_reserved && is_reserved(identifier)) {
      unexpected_reserved_word(start, identifier);
    }
    return identifier;
  }
  /** @param {RegExp} pattern */
  read_until(pattern) {
    if (this.index >= this.template.length) {
      unexpected_eof(this.template.length);
    }
    const start = this.index;
    const match = pattern.exec(this.template.slice(start));
    if (match) {
      this.index = start + match.index;
      return this.template.slice(start, this.index);
    }
    this.index = this.template.length;
    return this.template.slice(start);
  }
  require_whitespace() {
    if (!regex_whitespace.test(this.template[this.index])) {
      expected_whitespace(this.index);
    }
    this.allow_whitespace();
  }
  pop() {
    this.fragments.pop();
    return this.stack.pop();
  }
  /**
   * @template T
   * @param {Omit<T, 'prev' | 'parent'>} node
   * @returns {T}
   */
  append(node) {
    const current = this.current();
    const fragment2 = this.fragments.at(-1);
    Object.defineProperties(node, {
      prev: {
        enumerable: false,
        value: (fragment2 == null ? void 0 : fragment2.nodes.at(-1)) ?? null
      },
      parent: {
        enumerable: false,
        configurable: true,
        value: current
      }
    });
    fragment2.nodes.push(node);
    return node;
  }
};
function parse2(template3) {
  const parser = new Parser2(template3);
  return parser.root;
}

// node_modules/svelte/src/compiler/phases/1-parse/remove_typescript_nodes.js
function remove_this_param(node, context) {
  var _a2;
  if (((_a2 = node.params[0]) == null ? void 0 : _a2.type) === "Identifier" && node.params[0].name === "this") {
    node.params.shift();
  }
  return context.next();
}
var visitors = {
  Decorator(node) {
    typescript_invalid_feature(node, "decorators (related TSC proposal is not stage 4 yet)");
  },
  ImportDeclaration(node) {
    var _a2;
    if (node.importKind === "type") return empty;
    if (((_a2 = node.specifiers) == null ? void 0 : _a2.length) > 0) {
      const specifiers = node.specifiers.filter((s) => s.importKind !== "type");
      if (specifiers.length === 0) return empty;
      return { ...node, specifiers };
    }
    return node;
  },
  ExportNamedDeclaration(node, context) {
    if (node.exportKind === "type") return empty;
    if (node.declaration) {
      return context.next();
    }
    if (node.specifiers) {
      const specifiers = node.specifiers.filter((s) => s.exportKind !== "type");
      if (specifiers.length === 0) return empty;
      return { ...node, specifiers };
    }
    return node;
  },
  ExportDefaultDeclaration(node) {
    if (node.exportKind === "type") return empty;
    return node;
  },
  ExportAllDeclaration(node) {
    if (node.exportKind === "type") return empty;
    return node;
  },
  PropertyDefinition(node) {
    if (node.accessor) {
      typescript_invalid_feature(
        node,
        "accessor fields (related TSC proposal is not stage 4 yet)"
      );
    }
  },
  TSAsExpression(node, context) {
    return context.visit(node.expression);
  },
  TSSatisfiesExpression(node, context) {
    return context.visit(node.expression);
  },
  TSNonNullExpression(node, context) {
    return context.visit(node.expression);
  },
  TSTypeAnnotation() {
    return empty;
  },
  TSInterfaceDeclaration() {
    return empty;
  },
  TSTypeAliasDeclaration() {
    return empty;
  },
  TSTypeParameterDeclaration() {
    return empty;
  },
  TSTypeParameterInstantiation() {
    return empty;
  },
  TSEnumDeclaration(node) {
    typescript_invalid_feature(node, "enums");
  },
  TSParameterProperty(node, context) {
    var _a2;
    if (node.accessibility && ((_a2 = context.path.at(-2)) == null ? void 0 : _a2.kind) === "constructor") {
      typescript_invalid_feature(node, "accessibility modifiers on constructor parameters");
    }
    return node.parameter;
  },
  FunctionExpression: remove_this_param,
  FunctionDeclaration: remove_this_param,
  TSDeclareFunction() {
    return empty;
  },
  ClassDeclaration(node, context) {
    if (node.declare) {
      return empty;
    }
    return context.next();
  },
  VariableDeclaration(node, context) {
    if (node.declare) {
      return empty;
    }
    return context.next();
  },
  TSModuleDeclaration(node, context) {
    if (!node.body) return empty;
    const cleaned = (
      /** @type {any[]} */
      node.body.body.map((entry) => context.visit(entry))
    );
    if (cleaned.some((entry) => entry !== empty)) {
      typescript_invalid_feature(node, "namespaces with non-type nodes");
    }
    return empty;
  }
};
function remove_typescript_nodes(ast) {
  return walk(ast, null, visitors);
}

// node_modules/svelte/src/compiler/utils/slot.js
function determine_slot(node) {
  if (!is_element_node(node)) return null;
  for (const attribute of node.attributes) {
    if (attribute.type !== "Attribute") continue;
    if (attribute.name !== "slot") continue;
    if (!is_text_attribute(attribute)) continue;
    return (
      /** @type {string} */
      attribute.value[0].data
    );
  }
  return null;
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/shared/utils.js
function validate_assignment(node, argument, state) {
  validate_no_const_assignment(node, argument, state.scope, false);
  if (argument.type === "Identifier") {
    const binding = state.scope.get(argument.name);
    if (state.analysis.runes) {
      if ((binding == null ? void 0 : binding.kind) === "derived") {
        constant_assignment(node, "derived state");
      }
      if ((binding == null ? void 0 : binding.kind) === "each") {
        each_item_invalid_assignment(node);
      }
    }
    if ((binding == null ? void 0 : binding.kind) === "snippet") {
      snippet_parameter_assignment(node);
    }
  }
  let object4 = (
    /** @type {Expression | Super} */
    argument
  );
  let property = null;
  while (object4.type === "MemberExpression") {
    property = object4.property;
    object4 = object4.object;
  }
  if (object4.type === "ThisExpression" && (property == null ? void 0 : property.type) === "PrivateIdentifier") {
    if (state.private_derived_state.includes(property.name)) {
      constant_assignment(node, "derived state");
    }
  }
}
function validate_no_const_assignment(node, argument, scope, is_binding) {
  if (argument.type === "ArrayPattern") {
    for (const element2 of argument.elements) {
      if (element2) {
        validate_no_const_assignment(node, element2, scope, is_binding);
      }
    }
  } else if (argument.type === "ObjectPattern") {
    for (const element2 of argument.properties) {
      if (element2.type === "Property") {
        validate_no_const_assignment(node, element2.value, scope, is_binding);
      }
    }
  } else if (argument.type === "Identifier") {
    const binding = scope.get(argument.name);
    if ((binding == null ? void 0 : binding.kind) === "derived" || (binding == null ? void 0 : binding.declaration_kind) === "import" || (binding == null ? void 0 : binding.declaration_kind) === "const" && binding.kind !== "each") {
      const thing = binding.declaration_kind === "import" ? "import" : binding.kind === "derived" ? "derived state" : "constant";
      if (is_binding) {
        constant_binding(node, thing);
      } else {
        constant_assignment(node, thing);
      }
    }
  }
}
function validate_opening_tag(node, state, expected) {
  if (state.analysis.source[node.start + 1] !== expected) {
    block_unexpected_character({ start: node.start, end: node.start + 5 }, expected);
  }
}
function validate_block_not_empty(node, context) {
  if (!node) return;
  if (node.nodes.length === 1 && node.nodes[0].type === "Text" && !node.nodes[0].raw.trim()) {
    block_empty(node.nodes[0]);
  }
}
function ensure_no_module_import_conflict(node, state) {
  var _a2;
  const ids = extract_identifiers(node.id);
  for (const id2 of ids) {
    if (state.ast_type === "instance" && state.scope === state.analysis.instance.scope && ((_a2 = state.analysis.module.scope.get(id2.name)) == null ? void 0 : _a2.declaration_kind) === "import") {
      declaration_duplicate_module_import(node.id);
    }
  }
}
function is_safe_identifier(expression, scope) {
  let node = expression;
  while (node.type === "MemberExpression") node = node.object;
  if (node.type !== "Identifier") return false;
  const binding = scope.get(node.name);
  if (!binding) return true;
  if (binding.kind === "store_sub") {
    return is_safe_identifier({ name: node.name.slice(1), type: "Identifier" }, scope);
  }
  return binding.declaration_kind !== "import" && binding.kind !== "prop" && binding.kind !== "bindable_prop" && binding.kind !== "rest_prop";
}
function is_pure(node, context) {
  if (node.type !== "Identifier" && node.type !== "MemberExpression") {
    return false;
  }
  const left = object2(node);
  if (!left) return false;
  if (left.type === "Identifier") {
    const binding = context.state.scope.get(left.name);
    if (binding === null) return true;
  }
  return false;
}
function validate_identifier_name(binding, function_depth) {
  var _a2;
  if (!binding) return;
  const declaration_kind = binding.declaration_kind;
  if (declaration_kind !== "synthetic" && declaration_kind !== "param" && declaration_kind !== "rest_param" && (!function_depth || function_depth <= 1)) {
    const node = binding.node;
    if (node.name === "$") {
      dollar_binding_invalid(node);
    } else if (node.name.startsWith("$") && // import type { $Type } from "" - these are normally already filtered out,
    // but for the migration they aren't, and throwing here is preventing the migration to complete
    // TODO -> once migration script is gone we can remove this check
    !(((_a2 = binding.initial) == null ? void 0 : _a2.type) === "ImportDeclaration" && /** @type {any} */
    binding.initial.importKind === "type")) {
      dollar_prefix_invalid(node);
    }
  }
}

// node_modules/svelte/src/compiler/phases/scope.js
var _porous;
var _Scope = class _Scope {
  /**
   *
   * @param {ScopeRoot} root
   * @param {Scope | null} parent
   * @param {boolean} porous
   */
  constructor(root, parent, porous) {
    /** @type {ScopeRoot} */
    __publicField(this, "root");
    /**
     * The immediate parent scope
     * @type {Scope | null}
     */
    __publicField(this, "parent");
    /**
     * Whether or not `var` declarations are contained by this scope
     * @type {boolean}
     */
    __privateAdd(this, _porous);
    /**
     * A map of every identifier declared by this scope, and all the
     * identifiers that reference it
     * @type {Map<string, Binding>}
     */
    __publicField(this, "declarations", /* @__PURE__ */ new Map());
    /**
     * A map of declarators to the bindings they declare
     * @type {Map<VariableDeclarator | AST.LetDirective, Binding[]>}
     */
    __publicField(this, "declarators", /* @__PURE__ */ new Map());
    /**
     * A set of all the names referenced with this scope
     * — useful for generating unique names
     * @type {Map<string, { node: Identifier; path: SvelteNode[] }[]>}
     */
    __publicField(this, "references", /* @__PURE__ */ new Map());
    /**
     * The scope depth allows us to determine if a state variable is referenced in its own scope,
     * which is usually an error. Block statements do not increase this value
     */
    __publicField(this, "function_depth", 0);
    this.root = root;
    this.parent = parent;
    __privateSet(this, _porous, porous);
    this.function_depth = parent ? parent.function_depth + (porous ? 0 : 1) : 0;
  }
  /**
   * @param {Identifier} node
   * @param {Binding['kind']} kind
   * @param {DeclarationKind} declaration_kind
   * @param {null | Expression | FunctionDeclaration | ClassDeclaration | ImportDeclaration | AST.EachBlock} initial
   * @returns {Binding}
   */
  declare(node, kind, declaration_kind, initial = null) {
    if (this.parent) {
      if (declaration_kind === "var" && __privateGet(this, _porous)) {
        return this.parent.declare(node, kind, declaration_kind);
      }
      if (declaration_kind === "import") {
        return this.parent.declare(node, kind, declaration_kind, initial);
      }
    }
    if (this.declarations.has(node.name)) {
      declaration_duplicate(node, node.name);
    }
    const binding = {
      node,
      references: [],
      legacy_dependencies: [],
      initial,
      reassigned: false,
      mutated: false,
      updated: false,
      scope: this,
      kind,
      declaration_kind,
      is_called: false,
      prop_alias: null,
      metadata: null
    };
    validate_identifier_name(binding, this.function_depth);
    this.declarations.set(node.name, binding);
    this.root.conflicts.add(node.name);
    return binding;
  }
  child(porous = false) {
    return new _Scope(this.root, this, porous);
  }
  /**
   * @param {string} preferred_name
   * @returns {string}
   */
  generate(preferred_name) {
    if (__privateGet(this, _porous)) {
      return (
        /** @type {Scope} */
        this.parent.generate(preferred_name)
      );
    }
    preferred_name = preferred_name.replace(/[^a-zA-Z0-9_$]/g, "_").replace(/^[0-9]/, "_");
    let name = preferred_name;
    let n = 1;
    while (this.references.has(name) || this.declarations.has(name) || this.root.conflicts.has(name) || is_reserved(name)) {
      name = `${preferred_name}_${n++}`;
    }
    this.references.set(name, []);
    this.root.conflicts.add(name);
    return name;
  }
  /**
   * @param {string} name
   * @returns {Binding | null}
   */
  get(name) {
    var _a2;
    return this.declarations.get(name) ?? ((_a2 = this.parent) == null ? void 0 : _a2.get(name)) ?? null;
  }
  /**
   * @param {VariableDeclarator | AST.LetDirective} node
   * @returns {Binding[]}
   */
  get_bindings(node) {
    const bindings = this.declarators.get(node);
    if (!bindings) {
      throw new Error("No binding found for declarator");
    }
    return bindings;
  }
  /**
   * @param {string} name
   * @returns {Scope | null}
   */
  owner(name) {
    return this.declarations.has(name) ? this : this.parent && this.parent.owner(name);
  }
  /**
   * @param {Identifier} node
   * @param {SvelteNode[]} path
   */
  reference(node, path) {
    path = [...path];
    let references = this.references.get(node.name);
    if (!references) this.references.set(node.name, references = []);
    references.push({ node, path });
    const binding = this.declarations.get(node.name);
    if (binding) {
      binding.references.push({ node, path });
    } else if (this.parent) {
      this.parent.reference(node, path);
    } else {
      this.root.conflicts.add(node.name);
    }
  }
};
_porous = new WeakMap();
var Scope = _Scope;
var ScopeRoot = class {
  constructor() {
    /** @type {Set<string>} */
    __publicField(this, "conflicts", /* @__PURE__ */ new Set());
  }
  /**
   * @param {string} preferred_name
   */
  unique(preferred_name) {
    preferred_name = preferred_name.replace(/[^a-zA-Z0-9_$]/g, "_");
    let final_name = preferred_name;
    let n = 1;
    while (this.conflicts.has(final_name)) {
      final_name = `${preferred_name}_${n++}`;
    }
    this.conflicts.add(final_name);
    const id2 = id(final_name);
    return id2;
  }
};
function create_scopes(ast, root, allow_reactive_declarations, parent) {
  const scopes = /* @__PURE__ */ new Map();
  const scope = new Scope(root, parent, false);
  scopes.set(ast, scope);
  const state = { scope };
  const references = [];
  const updates = [];
  const possible_implicit_declarations = [];
  function add_params(scope2, params) {
    for (const param of params) {
      for (const node of extract_identifiers(param)) {
        scope2.declare(node, "normal", param.type === "RestElement" ? "rest_param" : "param");
      }
    }
  }
  const create_block_scope = (node, { state: state2, next: next2 }) => {
    const scope2 = state2.scope.child(true);
    scopes.set(node, scope2);
    next2({ scope: scope2 });
  };
  const SvelteFragment4 = (node, { state: state2, next: next2 }) => {
    const scope2 = state2.scope.child();
    scopes.set(node, scope2);
    next2({ scope: scope2 });
  };
  const Component4 = (node, context) => {
    node.metadata.scopes = {
      default: context.state.scope.child()
    };
    if (node.type === "SvelteComponent") {
      context.visit(node.expression);
    }
    const default_state = determine_slot(node) ? context.state : { scope: node.metadata.scopes.default };
    for (const attribute of node.attributes) {
      if (attribute.type === "LetDirective") {
        context.visit(attribute, default_state);
      } else {
        context.visit(attribute);
      }
    }
    for (const child of node.fragment.nodes) {
      let state2 = default_state;
      const slot_name = determine_slot(child);
      if (slot_name !== null) {
        node.metadata.scopes[slot_name] = context.state.scope.child();
        state2 = {
          scope: node.metadata.scopes[slot_name]
        };
      }
      context.visit(child, state2);
    }
  };
  const SvelteDirective = (node, { state: state2, path, visit }) => {
    state2.scope.reference(id(node.name.split(".")[0]), path);
    if (node.expression) {
      visit(node.expression);
    }
  };
  walk(ast, state, {
    // references
    Identifier(node, { path, state: state2 }) {
      const parent2 = path.at(-1);
      if (parent2 && is_reference(
        node,
        /** @type {Node} */
        parent2
      ) && // TSTypeAnnotation, TSInterfaceDeclaration etc - these are normally already filtered out,
      // but for the migration they aren't, so we need to filter them out here
      // TODO -> once migration script is gone we can remove this check
      !parent2.type.startsWith("TS")) {
        references.push([state2.scope, { node, path: path.slice() }]);
      }
    },
    LabeledStatement(node, { path, next: next2 }) {
      if (path.length > 1 || !allow_reactive_declarations) return next2();
      if (node.label.name !== "$") return next2();
      const scope2 = state.scope.child();
      scopes.set(node, scope2);
      if (node.body.type === "ExpressionStatement" && node.body.expression.type === "AssignmentExpression") {
        for (const id2 of extract_identifiers(node.body.expression.left)) {
          if (!id2.name.startsWith("$")) {
            possible_implicit_declarations.push(id2);
          }
        }
      }
      next2({ scope: scope2 });
    },
    SvelteFragment: SvelteFragment4,
    SlotElement: SvelteFragment4,
    SvelteElement: SvelteFragment4,
    RegularElement: SvelteFragment4,
    LetDirective(node, context) {
      const scope2 = context.state.scope;
      const bindings = [];
      scope2.declarators.set(node, bindings);
      if (node.expression) {
        for (const id2 of extract_identifiers_from_destructuring(node.expression)) {
          const binding = scope2.declare(id2, "template", "const");
          scope2.reference(id2, [context.path[context.path.length - 1], node]);
          bindings.push(binding);
        }
      } else {
        const id2 = {
          name: node.name,
          type: "Identifier",
          start: node.start,
          end: node.end
        };
        const binding = scope2.declare(id2, "template", "const");
        scope2.reference(id2, [context.path[context.path.length - 1], node]);
        bindings.push(binding);
      }
    },
    Component: (node, context) => {
      context.state.scope.reference(id(node.name), context.path);
      Component4(node, context);
    },
    SvelteSelf: Component4,
    SvelteComponent: Component4,
    // updates
    AssignmentExpression(node, { state: state2, next: next2 }) {
      updates.push([state2.scope, node.left]);
      next2();
    },
    UpdateExpression(node, { state: state2, next: next2 }) {
      updates.push([
        state2.scope,
        /** @type {Identifier | MemberExpression} */
        node.argument
      ]);
      next2();
    },
    ImportDeclaration(node, { state: state2 }) {
      for (const specifier of node.specifiers) {
        state2.scope.declare(specifier.local, "normal", "import", node);
      }
    },
    FunctionExpression(node, { state: state2, next: next2 }) {
      const scope2 = state2.scope.child();
      scopes.set(node, scope2);
      if (node.id) scope2.declare(node.id, "normal", "function");
      add_params(scope2, node.params);
      next2({ scope: scope2 });
    },
    FunctionDeclaration(node, { state: state2, next: next2 }) {
      if (node.id) state2.scope.declare(node.id, "normal", "function", node);
      const scope2 = state2.scope.child();
      scopes.set(node, scope2);
      add_params(scope2, node.params);
      next2({ scope: scope2 });
    },
    ArrowFunctionExpression(node, { state: state2, next: next2 }) {
      const scope2 = state2.scope.child();
      scopes.set(node, scope2);
      add_params(scope2, node.params);
      next2({ scope: scope2 });
    },
    ForStatement: create_block_scope,
    ForInStatement: create_block_scope,
    ForOfStatement: create_block_scope,
    SwitchStatement: create_block_scope,
    BlockStatement(node, context) {
      const parent2 = context.path.at(-1);
      if ((parent2 == null ? void 0 : parent2.type) === "FunctionDeclaration" || (parent2 == null ? void 0 : parent2.type) === "FunctionExpression" || (parent2 == null ? void 0 : parent2.type) === "ArrowFunctionExpression") {
        context.next();
      } else {
        create_block_scope(node, context);
      }
    },
    ClassDeclaration(node, { state: state2, next: next2 }) {
      if (node.id) state2.scope.declare(node.id, "normal", "let", node);
      next2();
    },
    VariableDeclaration(node, { state: state2, path, next: next2 }) {
      var _a2;
      const is_parent_const_tag = ((_a2 = path.at(-1)) == null ? void 0 : _a2.type) === "ConstTag";
      for (const declarator2 of node.declarations) {
        const bindings = [];
        state2.scope.declarators.set(declarator2, bindings);
        for (const id2 of extract_identifiers(declarator2.id)) {
          const binding = state2.scope.declare(
            id2,
            is_parent_const_tag ? "template" : "normal",
            node.kind,
            declarator2.init
          );
          bindings.push(binding);
        }
      }
      next2();
    },
    CatchClause(node, { state: state2, next: next2 }) {
      if (node.param) {
        const scope2 = state2.scope.child(true);
        scopes.set(node, scope2);
        for (const id2 of extract_identifiers(node.param)) {
          scope2.declare(id2, "normal", "let");
        }
        next2({ scope: scope2 });
      } else {
        next2();
      }
    },
    EachBlock(node, { state: state2, visit }) {
      visit(node.expression);
      const scope2 = state2.scope.child();
      scopes.set(node, scope2);
      for (const id2 of extract_identifiers(node.context)) {
        const binding = scope2.declare(id2, "each", "const");
        let inside_rest = false;
        let is_rest_id = false;
        walk(node.context, null, {
          Identifier(node2) {
            if (inside_rest && node2 === id2) {
              is_rest_id = true;
            }
          },
          RestElement(_, { next: next2 }) {
            const prev = inside_rest;
            inside_rest = true;
            next2();
            inside_rest = prev;
          }
        });
        binding.metadata = { inside_rest: is_rest_id };
      }
      visit(node.context, { scope: scope2 });
      if (node.index) {
        const is_keyed = node.key && (node.key.type !== "Identifier" || !node.index || node.key.name !== node.index);
        scope2.declare(id(node.index), is_keyed ? "template" : "normal", "const", node);
      }
      if (node.key) visit(node.key, { scope: scope2 });
      for (const child of node.body.nodes) {
        visit(child, { scope: scope2 });
      }
      if (node.fallback) visit(node.fallback, { scope: scope2 });
      let needs_array_deduplication = false;
      for (const [name] of scope2.declarations) {
        if (state2.scope.get(name) !== null) {
          needs_array_deduplication = true;
        }
      }
      node.metadata = {
        expression: create_expression_metadata(),
        keyed: false,
        contains_group_binding: false,
        array_name: needs_array_deduplication ? state2.scope.root.unique("$$array") : null,
        index: scope2.root.unique("$$index"),
        declarations: scope2.declarations,
        is_controlled: false
      };
    },
    AwaitBlock(node, context) {
      context.visit(node.expression);
      if (node.pending) {
        context.visit(node.pending);
      }
      if (node.then) {
        context.visit(node.then);
        if (node.value) {
          const then_scope = (
            /** @type {Scope} */
            scopes.get(node.then)
          );
          const value_scope = context.state.scope.child();
          scopes.set(node.value, value_scope);
          context.visit(node.value, { scope: value_scope });
          for (const id2 of extract_identifiers(node.value)) {
            then_scope.declare(id2, "template", "const");
            value_scope.declare(id2, "normal", "const");
          }
        }
      }
      if (node.catch) {
        context.visit(node.catch);
        if (node.error) {
          const catch_scope = (
            /** @type {Scope} */
            scopes.get(node.catch)
          );
          const error_scope = context.state.scope.child();
          scopes.set(node.error, error_scope);
          context.visit(node.error, { scope: error_scope });
          for (const id2 of extract_identifiers(node.error)) {
            catch_scope.declare(id2, "template", "const");
            error_scope.declare(id2, "normal", "const");
          }
        }
      }
    },
    SnippetBlock(node, context) {
      const state2 = context.state;
      const is_top_level = !context.path.at(-2);
      let scope2 = state2.scope;
      if (is_top_level) {
        scope2 = /** @type {Scope} */
        parent;
      }
      scope2.declare(node.expression, "normal", "function", node.expression);
      const child_scope = state2.scope.child();
      scopes.set(node, child_scope);
      for (const param of node.parameters) {
        for (const id2 of extract_identifiers(param)) {
          child_scope.declare(id2, "snippet", "let");
        }
      }
      context.next({ scope: child_scope });
    },
    Fragment: (node, context) => {
      const scope2 = context.state.scope.child(node.metadata.transparent);
      scopes.set(node, scope2);
      context.next({ scope: scope2 });
    },
    BindDirective(node, context) {
      updates.push([
        context.state.scope,
        /** @type {Identifier | MemberExpression} */
        node.expression
      ]);
      context.next();
    },
    TransitionDirective: SvelteDirective,
    AnimateDirective: SvelteDirective,
    UseDirective: SvelteDirective,
    // using it's own function instead of `SvelteDirective` because
    // StyleDirective doesn't have expressions and are generally already
    // handled by `Identifier`. This is the special case for the shorthand
    // eg <button style:height /> where the variable has the same name of
    // the css property
    StyleDirective(node, { path, state: state2, next: next2 }) {
      if (node.value === true) {
        state2.scope.reference(id(node.name), path.concat(node));
      }
      next2();
    }
    // TODO others
  });
  for (const id2 of possible_implicit_declarations) {
    const binding = scope.get(id2.name);
    if (binding) continue;
    scope.declare(id2, "legacy_reactive", "let");
  }
  for (const [scope2, { node, path }] of references) {
    scope2.reference(node, path);
  }
  for (const [scope2, node] of updates) {
    for (const expression of unwrap_pattern(node)) {
      const left = object2(expression);
      const binding = left && scope2.get(left.name);
      if (binding !== null && left !== binding.node) {
        binding.updated = true;
        if (left === expression) {
          binding.reassigned = true;
        } else {
          binding.mutated = true;
        }
      }
    }
  }
  return {
    scope,
    scopes
  };
}
function set_scope(node, { next: next2, state }) {
  const scope = state.scopes.get(node);
  next2(scope !== void 0 && scope !== state.scope ? { ...state, scope } : state);
}
function get_rune(node, scope) {
  if (!node) return null;
  if (node.type !== "CallExpression") return null;
  let n = node.callee;
  let joined = "";
  while (n.type === "MemberExpression") {
    if (n.computed) return null;
    if (n.property.type !== "Identifier") return null;
    joined = "." + n.property.name + joined;
    n = n.object;
  }
  if (n.type === "CallExpression" && n.callee.type === "Identifier") {
    joined = "()" + joined;
    n = n.callee;
  }
  if (n.type !== "Identifier") return null;
  joined = n.name + joined;
  if (!is_rune(joined)) return null;
  const binding = scope.get(n.name);
  if (binding !== null) return null;
  return joined;
}

// node_modules/svelte/src/compiler/phases/2-analyze/utils/check_graph_for_cycles.js
function check_graph_for_cycles(edges) {
  const graph = edges.reduce((g, edge) => {
    const [u, v] = edge;
    if (!g.has(u)) g.set(u, []);
    if (!g.has(v)) g.set(v, []);
    g.get(u).push(v);
    return g;
  }, /* @__PURE__ */ new Map());
  const visited = /* @__PURE__ */ new Set();
  const on_stack = /* @__PURE__ */ new Set();
  const cycles = [];
  function visit(v) {
    var _a2;
    visited.add(v);
    on_stack.add(v);
    (_a2 = graph.get(v)) == null ? void 0 : _a2.forEach((w2) => {
      if (!visited.has(w2)) {
        visit(w2);
      } else if (on_stack.has(w2)) {
        cycles.push([...on_stack, w2]);
      }
    });
    on_stack.delete(v);
  }
  graph.forEach((_, v) => {
    if (!visited.has(v)) {
      visit(v);
    }
  });
  return cycles[0];
}

// node_modules/svelte/src/compiler/phases/css.js
var regex_css_browser_prefix = /^-((webkit)|(moz)|(o)|(ms))-/;
var regex_css_name_boundary = /^[\s,;}]$/;
function remove_css_prefix(name) {
  return name.replace(regex_css_browser_prefix, "");
}
var is_keyframes_node = (node) => remove_css_prefix(node.name) === "keyframes";

// node_modules/svelte/src/compiler/phases/2-analyze/css/css-analyze.js
function is_global(relative_selector) {
  const first = relative_selector.selectors[0];
  return first.type === "PseudoClassSelector" && first.name === "global" && (first.args === null || // Only these two selector types keep the whole selector global, because e.g.
  // :global(button).x means that the selector is still scoped because of the .x
  relative_selector.selectors.every(
    (selector) => selector.type === "PseudoClassSelector" || selector.type === "PseudoElementSelector"
  ));
}
function is_global_block_selector(simple_selector) {
  return simple_selector.type === "PseudoClassSelector" && simple_selector.name === "global" && simple_selector.args === null;
}
var css_visitors = {
  Atrule(node, context) {
    if (is_keyframes_node(node)) {
      if (!node.prelude.startsWith("-global-")) {
        context.state.keyframes.push(node.prelude);
      }
    }
    context.next();
  },
  ComplexSelector(node, context) {
    var _a2, _b2, _c, _d, _e, _f;
    context.next();
    {
      const global = node.children.find(is_global);
      if (global) {
        const idx = node.children.indexOf(global);
        if (global.selectors[0].args !== null && idx !== 0 && idx !== node.children.length - 1) {
          for (let i = idx + 1; i < node.children.length; i++) {
            if (!is_global(node.children[i])) {
              css_global_invalid_placement(global.selectors[0]);
            }
          }
        }
      }
    }
    for (const relative_selector of node.children) {
      for (let i = 0; i < relative_selector.selectors.length; i++) {
        const selector = relative_selector.selectors[i];
        if (selector.type === "PseudoClassSelector" && selector.name === "global") {
          const child = (_a2 = selector.args) == null ? void 0 : _a2.children[0].children[0];
          if ((child == null ? void 0 : child.selectors[0].type) === "TypeSelector" && i !== 0) {
            css_global_invalid_selector_list(selector);
          }
          if (((_b2 = relative_selector.selectors[i + 1]) == null ? void 0 : _b2.type) === "TypeSelector") {
            css_type_selector_invalid_placement(relative_selector.selectors[i + 1]);
          }
          if (selector.args !== null && selector.args.children.length > 1 && (node.children.length > 1 || relative_selector.selectors.length > 1)) {
            css_global_invalid_selector(selector);
          }
        }
      }
    }
    node.metadata.rule = context.state.rule;
    (_c = node.metadata).used || (_c.used = node.children.every(
      ({ metadata }) => metadata.is_global || metadata.is_global_like
    ));
    if (((_d = node.metadata.rule) == null ? void 0 : _d.metadata.parent_rule) && ((_f = (_e = node.children[0]) == null ? void 0 : _e.selectors[0]) == null ? void 0 : _f.type) === "NestingSelector") {
      const parent_is_global = node.metadata.rule.metadata.parent_rule.prelude.children.some(
        (child) => child.children.length === 1 && child.children[0].metadata.is_global
      );
      if (parent_is_global) {
        node.metadata.used = true;
      }
    }
  },
  RelativeSelector(node, context) {
    var _a2, _b2, _c, _d;
    const parent = (
      /** @type {Css.ComplexSelector} */
      context.path.at(-1)
    );
    if (node.combinator != null && !((_a2 = context.state.rule) == null ? void 0 : _a2.metadata.parent_rule) && parent.children[0] === node && ((_b2 = context.path.at(-3)) == null ? void 0 : _b2.type) !== "PseudoClassSelector") {
      css_selector_invalid(node.combinator);
    }
    node.metadata.is_global = node.selectors.length >= 1 && is_global(node);
    if (node.selectors.length === 1) {
      const first = node.selectors[0];
      (_c = node.metadata).is_global_like || (_c.is_global_like = first.type === "PseudoClassSelector" && first.name === "host" || first.type === "PseudoElementSelector" && [
        "view-transition",
        "view-transition-group",
        "view-transition-old",
        "view-transition-new",
        "view-transition-image-pair"
      ].includes(first.name));
    }
    (_d = node.metadata).is_global_like || (_d.is_global_like = !!node.selectors.find(
      (child) => child.type === "PseudoClassSelector" && child.name === "root"
    ));
    context.next();
  },
  Rule(node, context) {
    node.metadata.parent_rule = context.state.rule;
    node.metadata.is_global_block = node.prelude.children.some((selector) => {
      let is_global_block = false;
      for (const child of selector.children) {
        const idx = child.selectors.findIndex(is_global_block_selector);
        if (is_global_block) {
          child.metadata.is_global_like = true;
        }
        if (idx !== -1) {
          is_global_block = true;
          for (let i = idx + 1; i < child.selectors.length; i++) {
            walk(
              /** @type {Css.Node} */
              child.selectors[i],
              null,
              {
                ComplexSelector(node2) {
                  node2.metadata.used = true;
                }
              }
            );
          }
        }
      }
      return is_global_block;
    });
    if (node.metadata.is_global_block) {
      if (node.prelude.children.length > 1) {
        css_global_block_invalid_list(node.prelude);
      }
      const complex_selector = node.prelude.children[0];
      const global_selector = complex_selector.children.find((r, selector_idx) => {
        const idx = r.selectors.findIndex(is_global_block_selector);
        if (idx === 0) {
          if (r.selectors.length > 1 && selector_idx === 0 && node.metadata.parent_rule === null) {
            css_global_block_invalid_modifier_start(r.selectors[1]);
          }
          return true;
        } else if (idx !== -1) {
          css_global_block_invalid_modifier(r.selectors[idx]);
        }
      });
      if (!global_selector) {
        throw new Error("Internal error: global block without :global selector");
      }
      if (global_selector.combinator && global_selector.combinator.name !== " ") {
        css_global_block_invalid_combinator(global_selector, global_selector.combinator.name);
      }
      const declaration2 = node.block.children.find((child) => child.type === "Declaration");
      if (declaration2 && // :global { color: red; } is invalid, but foo :global { color: red; } is valid
      node.prelude.children.length === 1 && node.prelude.children[0].children.length === 1 && node.prelude.children[0].children[0].selectors.length === 1) {
        css_global_block_invalid_declaration(declaration2);
      }
    }
    context.next({
      ...context.state,
      rule: node
    });
    node.metadata.has_local_selectors = node.prelude.children.some((selector) => {
      return selector.children.some(
        ({ metadata }) => !metadata.is_global && !metadata.is_global_like
      );
    });
  },
  NestingSelector(node, context) {
    var _a2, _b2;
    const rule = (
      /** @type {Css.Rule} */
      context.state.rule
    );
    const parent_rule = rule.metadata.parent_rule;
    if (!parent_rule) {
      const children = rule.prelude.children;
      const selectors = children[0].children[0].selectors;
      if (children.length > 1 || selectors.length > 1 || selectors[0].type !== "PseudoClassSelector" || selectors[0].name !== "global" || ((_b2 = (_a2 = selectors[0].args) == null ? void 0 : _a2.children[0]) == null ? void 0 : _b2.children[0].selectors[0]) !== node) {
        css_nesting_selector_invalid_placement(node);
      }
    } else if (
      // :global { &.foo { ... } } is invalid
      parent_rule.metadata.is_global_block && !parent_rule.metadata.parent_rule && parent_rule.prelude.children[0].children.length === 1 && parent_rule.prelude.children[0].children[0].selectors.length === 1
    ) {
      css_global_block_invalid_modifier_start(node);
    }
    context.next();
  }
};
function analyze_css(stylesheet, analysis) {
  walk(stylesheet, { keyframes: analysis.css.keyframes, rule: null }, css_visitors);
}

// node_modules/svelte/src/compiler/phases/2-analyze/css/utils.js
var UNKNOWN = {};
function gather_possible_values(node, set2) {
  if (node.type === "Literal") {
    set2.add(String(node.value));
  } else if (node.type === "ConditionalExpression") {
    gather_possible_values(node.consequent, set2);
    gather_possible_values(node.alternate, set2);
  } else {
    set2.add(UNKNOWN);
  }
}
function get_possible_values(chunk) {
  const values = /* @__PURE__ */ new Set();
  if (chunk.type === "Text") {
    values.add(chunk.data);
  } else {
    gather_possible_values(chunk.expression, values);
  }
  if (values.has(UNKNOWN)) return null;
  return values;
}

// node_modules/svelte/src/compiler/phases/2-analyze/css/css-prune.js
var NODE_PROBABLY_EXISTS = 0;
var NODE_DEFINITELY_EXISTS = 1;
var whitelist_attribute_selector = /* @__PURE__ */ new Map([
  ["details", ["open"]],
  ["dialog", ["open"]]
]);
var descendant_combinator = {
  type: "Combinator",
  name: " ",
  start: -1,
  end: -1
};
var nesting_selector = {
  type: "RelativeSelector",
  start: -1,
  end: -1,
  combinator: null,
  selectors: [
    {
      type: "NestingSelector",
      name: "&",
      start: -1,
      end: -1
    }
  ],
  metadata: {
    is_global: false,
    is_global_like: false,
    scoped: false
  }
};
function prune(stylesheet, element2) {
  if (element2.type === "RenderTag") {
    const parent = get_element_parent(element2);
    if (!parent) return;
    walk(stylesheet, { stylesheet, element: parent, from_render_tag: true }, visitors2);
  } else {
    walk(stylesheet, { stylesheet, element: element2, from_render_tag: false }, visitors2);
  }
}
var visitors2 = {
  Rule(node, context) {
    if (node.metadata.is_global_block) {
      context.visit(node.prelude);
    } else {
      context.next();
    }
  },
  ComplexSelector(node, context) {
    var _a2;
    const selectors = truncate(node);
    const inner = selectors[selectors.length - 1];
    if (((_a2 = node.metadata.rule) == null ? void 0 : _a2.metadata.parent_rule) && selectors.length > 0) {
      let has_explicit_nesting_selector = false;
      for (let selector of selectors) {
        walk(
          selector,
          {},
          {
            // @ts-ignore
            NestingSelector() {
              has_explicit_nesting_selector = true;
            }
          }
        );
        if (has_explicit_nesting_selector) break;
      }
      if (!has_explicit_nesting_selector) {
        selectors[0] = {
          ...selectors[0],
          combinator: descendant_combinator
        };
        selectors.unshift(nesting_selector);
      }
    }
    if (context.state.from_render_tag) {
      let element2 = context.state.element;
      while (element2) {
        const selectors_to_check = selectors.slice();
        while (selectors_to_check.length > 0) {
          selectors_to_check.pop();
          if (apply_selector(
            selectors_to_check,
            /** @type {Compiler.Css.Rule} */
            node.metadata.rule,
            element2,
            context.state.stylesheet
          )) {
            mark(inner, element2);
            node.metadata.used = true;
            return;
          }
        }
        element2 = get_element_parent(element2);
      }
    } else if (apply_selector(
      selectors,
      /** @type {Compiler.Css.Rule} */
      node.metadata.rule,
      context.state.element,
      context.state.stylesheet
    )) {
      mark(inner, context.state.element);
      node.metadata.used = true;
    }
  }
};
function truncate(node) {
  const i = node.children.findLastIndex(({ metadata, selectors }) => {
    const first = selectors[0];
    return (
      // not after a :global selector
      !metadata.is_global_like && !(first.type === "PseudoClassSelector" && first.name === "global" && first.args === null) && // not a :global(...) without a :has/is/where/not(...) modifier
      (!metadata.is_global || selectors.some(
        (selector) => selector.type === "PseudoClassSelector" && selector.args !== null && (selector.name === "has" || selector.name === "not" || selector.name === "is" || selector.name === "where")
      ))
    );
  });
  return node.children.slice(0, i + 1);
}
function apply_selector(relative_selectors, rule, element2, stylesheet) {
  const parent_selectors = relative_selectors.slice();
  const relative_selector = parent_selectors.pop();
  if (!relative_selector) return false;
  const possible_match = relative_selector_might_apply_to_node(
    relative_selector,
    rule,
    element2,
    stylesheet
  );
  if (!possible_match) {
    return false;
  }
  if (relative_selector.combinator) {
    return apply_combinator(
      relative_selector.combinator,
      relative_selector,
      parent_selectors,
      rule,
      element2,
      stylesheet
    );
  }
  const parent = parent_selectors[parent_selectors.length - 1];
  if (!parent || is_global2(parent, rule)) {
    mark(relative_selector, element2);
  }
  return true;
}
function apply_combinator(combinator, relative_selector, parent_selectors, rule, element2, stylesheet) {
  const name = combinator.name;
  switch (name) {
    case " ":
    case ">": {
      let parent = (
        /** @type {Compiler.TemplateNode | null} */
        element2.parent
      );
      let parent_matched = false;
      let crossed_component_boundary = false;
      while (parent) {
        if (parent.type === "Component" || parent.type === "SvelteComponent") {
          crossed_component_boundary = true;
        }
        if (parent.type === "SnippetBlock") {
          return true;
        }
        if (parent.type === "RegularElement" || parent.type === "SvelteElement") {
          if (apply_selector(parent_selectors, rule, parent, stylesheet)) {
            if (name === " " || crossed_component_boundary) {
              mark(parent_selectors[parent_selectors.length - 1], parent);
            }
            parent_matched = true;
          }
          if (name === ">") return parent_matched;
        }
        parent = /** @type {Compiler.TemplateNode | null} */
        parent.parent;
      }
      return parent_matched || parent_selectors.every((selector) => is_global2(selector, rule));
    }
    case "+":
    case "~": {
      const siblings = get_possible_element_siblings(element2, name === "+");
      let sibling_matched = false;
      for (const possible_sibling of siblings.keys()) {
        if (possible_sibling.type === "RenderTag" || possible_sibling.type === "SlotElement") {
          if (parent_selectors.length === 1 && parent_selectors[0].metadata.is_global) {
            mark(relative_selector, element2);
            sibling_matched = true;
          }
        } else if (apply_selector(parent_selectors, rule, possible_sibling, stylesheet)) {
          mark(relative_selector, element2);
          sibling_matched = true;
        }
      }
      return sibling_matched || get_element_parent(element2) === null && parent_selectors.every((selector) => is_global2(selector, rule));
    }
    default:
      return true;
  }
}
function mark(relative_selector, element2) {
  relative_selector.metadata.scoped = true;
  element2.metadata.scoped = true;
}
function is_global2(selector, rule) {
  if (selector.metadata.is_global || selector.metadata.is_global_like) {
    return true;
  }
  for (const s of selector.selectors) {
    let selector_list = null;
    let owner = rule;
    if (s.type === "PseudoClassSelector") {
      if ((s.name === "is" || s.name === "where") && s.args) {
        selector_list = s.args;
      }
    }
    if (s.type === "NestingSelector") {
      owner = /** @type {Compiler.Css.Rule} */
      rule.metadata.parent_rule;
      selector_list = owner.prelude;
    }
    const has_global_selectors = selector_list == null ? void 0 : selector_list.children.some((complex_selector) => {
      return complex_selector.children.every(
        (relative_selector) => is_global2(relative_selector, owner)
      );
    });
    if (!has_global_selectors) {
      return false;
    }
  }
  return true;
}
var regex_backslash_and_following_character = /\\(.)/g;
function relative_selector_might_apply_to_node(relative_selector, rule, element2, stylesheet) {
  var _a2, _b2;
  const has_selectors = [];
  const other_selectors = [];
  for (const selector of relative_selector.selectors) {
    if (selector.type === "PseudoClassSelector" && selector.name === "has" && selector.args) {
      has_selectors.push(selector);
    } else {
      other_selectors.push(selector);
    }
  }
  if (has_selectors.length > 0) {
    const child_elements = [];
    const descendant_elements = [];
    walk(
      /** @type {Compiler.SvelteNode} */
      element2.fragment,
      { is_child: true },
      {
        _(node, context) {
          if (node.type === "RegularElement" || node.type === "SvelteElement") {
            descendant_elements.push(node);
            if (context.state.is_child) {
              child_elements.push(node);
              context.state.is_child = false;
              context.next();
              context.state.is_child = true;
            } else {
              context.next();
            }
          } else {
            context.next();
          }
        }
      }
    );
    for (const has_selector of has_selectors) {
      const complex_selectors = (
        /** @type {Compiler.Css.SelectorList} */
        has_selector.args.children
      );
      let matched = false;
      for (const complex_selector of complex_selectors) {
        const selectors = truncate(complex_selector);
        const left_most_combinator = ((_a2 = selectors[0]) == null ? void 0 : _a2.combinator) ?? descendant_combinator;
        if (selectors.length > 0) {
          selectors[0] = {
            ...selectors[0],
            combinator: null
          };
        }
        const descendants = left_most_combinator.name === ">" ? child_elements : descendant_elements;
        let selector_matched = false;
        for (const element3 of descendants) {
          if (selectors.length === 0 || element3.metadata.scoped && selector_matched || apply_selector(selectors, rule, element3, stylesheet)) {
            complex_selector.metadata.used = true;
            selector_matched = matched = true;
          }
        }
      }
      if (!matched) {
        if (relative_selector.metadata.is_global && !relative_selector.metadata.is_global_like) {
          complex_selectors[0].metadata.used = true;
          complex_selectors[0].children.forEach((selector) => {
            selector.metadata.scoped = true;
          });
        }
        return false;
      }
    }
  }
  for (const selector of other_selectors) {
    if (selector.type === "Percentage" || selector.type === "Nth") continue;
    const name = selector.name.replace(regex_backslash_and_following_character, "$1");
    switch (selector.type) {
      case "PseudoClassSelector": {
        if (name === "host" || name === "root") {
          return false;
        }
        if (name === "global" && selector.args !== null && relative_selector.selectors.length === 1) {
          const args = selector.args;
          const complex_selector = args.children[0];
          return apply_selector(complex_selector.children, rule, element2, stylesheet);
        }
        if (name === "global" && selector.args === null) return true;
        if ((name === "is" || name === "where" || name === "not") && selector.args) {
          let matched = false;
          for (const complex_selector of selector.args.children) {
            const relative = truncate(complex_selector);
            if (relative.length === 0 || apply_selector(relative, rule, element2, stylesheet)) {
              complex_selector.metadata.used = true;
              matched = true;
            } else if (complex_selector.children.length > 1 && (name == "is" || name == "where")) {
              complex_selector.metadata.used = true;
              matched = true;
              for (const selector2 of relative) {
                selector2.metadata.scoped = true;
              }
            }
          }
          if (!matched) {
            if (relative_selector.metadata.is_global && !relative_selector.metadata.is_global_like) {
              selector.args.children[0].metadata.used = true;
              selector.args.children[0].children.forEach((selector2) => {
                selector2.metadata.scoped = true;
              });
            }
            return false;
          }
        }
        break;
      }
      case "PseudoElementSelector": {
        break;
      }
      case "AttributeSelector": {
        const whitelisted = whitelist_attribute_selector.get(element2.name.toLowerCase());
        if (!(whitelisted == null ? void 0 : whitelisted.includes(selector.name.toLowerCase())) && !attribute_matches(
          element2,
          selector.name,
          selector.value && unquote(selector.value),
          selector.matcher,
          ((_b2 = selector.flags) == null ? void 0 : _b2.includes("i")) ?? false
        )) {
          return false;
        }
        break;
      }
      case "ClassSelector": {
        if (!attribute_matches(element2, "class", name, "~=", false) && !element2.attributes.some(
          (attribute) => attribute.type === "ClassDirective" && attribute.name === name
        )) {
          return false;
        }
        break;
      }
      case "IdSelector": {
        if (!attribute_matches(element2, "id", name, "=", false)) {
          return false;
        }
        break;
      }
      case "TypeSelector": {
        if (element2.name.toLowerCase() !== name.toLowerCase() && name !== "*" && element2.type !== "SvelteElement") {
          return false;
        }
        break;
      }
      case "NestingSelector": {
        let matched = false;
        const parent = (
          /** @type {Compiler.Css.Rule} */
          rule.metadata.parent_rule
        );
        for (const complex_selector of parent.prelude.children) {
          if (apply_selector(truncate(complex_selector), parent, element2, stylesheet)) {
            complex_selector.metadata.used = true;
            matched = true;
          }
        }
        if (!matched) {
          return false;
        }
        break;
      }
    }
  }
  return true;
}
function test_attribute(operator, expected_value, case_insensitive, value) {
  if (case_insensitive) {
    expected_value = expected_value.toLowerCase();
    value = value.toLowerCase();
  }
  switch (operator) {
    case "=":
      return value === expected_value;
    case "~=":
      return value.split(/\s/).includes(expected_value);
    case "|=":
      return `${value}-`.startsWith(`${expected_value}-`);
    case "^=":
      return value.startsWith(expected_value);
    case "$=":
      return value.endsWith(expected_value);
    case "*=":
      return value.includes(expected_value);
    default:
      throw new Error("this shouldn't happen");
  }
}
function attribute_matches(node, name, expected_value, operator, case_insensitive) {
  for (const attribute of node.attributes) {
    if (attribute.type === "SpreadAttribute") return true;
    if (attribute.type === "BindDirective" && attribute.name === name) return true;
    if (attribute.type !== "Attribute") continue;
    if (attribute.name.toLowerCase() !== name.toLowerCase()) continue;
    if (attribute.value === true) return operator === null;
    if (expected_value === null) return true;
    if (is_text_attribute(attribute)) {
      return test_attribute(operator, expected_value, case_insensitive, attribute.value[0].data);
    }
    const chunks = get_attribute_chunks(attribute.value);
    const possible_values = /* @__PURE__ */ new Set();
    let prev_values = [];
    for (const chunk of chunks) {
      const current_possible_values = get_possible_values(chunk);
      if (!current_possible_values) return true;
      if (prev_values.length > 0) {
        const start_with_space = [];
        const remaining = [];
        current_possible_values.forEach((current_possible_value) => {
          if (regex_starts_with_whitespace.test(current_possible_value)) {
            start_with_space.push(current_possible_value);
          } else {
            remaining.push(current_possible_value);
          }
        });
        if (remaining.length > 0) {
          if (start_with_space.length > 0) {
            prev_values.forEach((prev_value) => possible_values.add(prev_value));
          }
          const combined = [];
          prev_values.forEach((prev_value) => {
            remaining.forEach((value) => {
              combined.push(prev_value + value);
            });
          });
          prev_values = combined;
          start_with_space.forEach((value) => {
            if (regex_ends_with_whitespace.test(value)) {
              possible_values.add(value);
            } else {
              prev_values.push(value);
            }
          });
          continue;
        } else {
          prev_values.forEach((prev_value) => possible_values.add(prev_value));
          prev_values = [];
        }
      }
      current_possible_values.forEach((current_possible_value) => {
        if (regex_ends_with_whitespace.test(current_possible_value)) {
          possible_values.add(current_possible_value);
        } else {
          prev_values.push(current_possible_value);
        }
      });
      if (prev_values.length < current_possible_values.size) {
        prev_values.push(" ");
      }
      if (prev_values.length > 20) {
        return true;
      }
    }
    prev_values.forEach((prev_value) => possible_values.add(prev_value));
    for (const value of possible_values) {
      if (test_attribute(operator, expected_value, case_insensitive, value)) return true;
    }
  }
  return false;
}
function unquote(str) {
  if (str[0] === str[str.length - 1] && str[0] === "'" || str[0] === '"') {
    return str.slice(1, str.length - 1);
  }
  return str;
}
function get_element_parent(node) {
  let parent = node;
  while (
    // @ts-expect-error TODO figure out a more elegant solution
    (parent = parent.parent) && parent.type !== "RegularElement" && parent.type !== "SvelteElement"
  ) ;
  return parent ?? null;
}
function find_previous_sibling(node) {
  var _a2;
  let current_node = node;
  while (
    // @ts-expect-error TODO
    !current_node.prev && // @ts-expect-error TODO
    ((_a2 = current_node.parent) == null ? void 0 : _a2.type) === "SlotElement"
  ) {
    current_node = current_node.parent;
  }
  current_node = current_node.prev;
  while ((current_node == null ? void 0 : current_node.type) === "SlotElement") {
    const slot_children = current_node.fragment.nodes;
    if (slot_children.length > 0) {
      current_node = slot_children.slice(-1)[0];
    } else {
      break;
    }
  }
  return current_node;
}
function get_possible_element_siblings(node, adjacent_only) {
  var _a2;
  const result = /* @__PURE__ */ new Map();
  let prev = node;
  while (prev = find_previous_sibling(prev)) {
    if (prev.type === "RegularElement") {
      if (!prev.attributes.find(
        (attr) => attr.type === "Attribute" && attr.name.toLowerCase() === "slot"
      )) {
        result.set(prev, NODE_DEFINITELY_EXISTS);
      }
      if (adjacent_only) {
        break;
      }
    } else if (prev.type === "EachBlock" || prev.type === "IfBlock" || prev.type === "AwaitBlock") {
      const possible_last_child = get_possible_last_child(prev, adjacent_only);
      add_to_map(possible_last_child, result);
      if (adjacent_only && has_definite_elements(possible_last_child)) {
        return result;
      }
    } else if (prev.type === "SlotElement" || prev.type === "RenderTag" || prev.type === "SvelteElement") {
      result.set(prev, NODE_PROBABLY_EXISTS);
    }
  }
  if (!prev || !adjacent_only) {
    let parent = node;
    while (
      // @ts-expect-error TODO
      (parent = parent == null ? void 0 : parent.parent) && (parent.type === "EachBlock" || parent.type === "IfBlock" || parent.type === "AwaitBlock")
    ) {
      const possible_siblings = get_possible_element_siblings(parent, adjacent_only);
      add_to_map(possible_siblings, result);
      if (parent.type === "EachBlock" && !((_a2 = parent.fallback) == null ? void 0 : _a2.nodes.includes(node))) {
        add_to_map(get_possible_last_child(parent, adjacent_only), result);
      }
      if (adjacent_only && has_definite_elements(possible_siblings)) {
        break;
      }
    }
  }
  return result;
}
function get_possible_last_child(relative_selector, adjacent_only) {
  const result = /* @__PURE__ */ new Map();
  if (relative_selector.type === "EachBlock") {
    const each_result = loop_child(relative_selector.body.nodes, adjacent_only);
    const else_result = relative_selector.fallback ? loop_child(relative_selector.fallback.nodes, adjacent_only) : /* @__PURE__ */ new Map();
    const not_exhaustive = !has_definite_elements(else_result);
    if (not_exhaustive) {
      mark_as_probably(each_result);
      mark_as_probably(else_result);
    }
    add_to_map(each_result, result);
    add_to_map(else_result, result);
  } else if (relative_selector.type === "IfBlock") {
    const if_result = loop_child(relative_selector.consequent.nodes, adjacent_only);
    const else_result = relative_selector.alternate ? loop_child(relative_selector.alternate.nodes, adjacent_only) : /* @__PURE__ */ new Map();
    const not_exhaustive = !has_definite_elements(if_result) || !has_definite_elements(else_result);
    if (not_exhaustive) {
      mark_as_probably(if_result);
      mark_as_probably(else_result);
    }
    add_to_map(if_result, result);
    add_to_map(else_result, result);
  } else if (relative_selector.type === "AwaitBlock") {
    const pending_result = relative_selector.pending ? loop_child(relative_selector.pending.nodes, adjacent_only) : /* @__PURE__ */ new Map();
    const then_result = relative_selector.then ? loop_child(relative_selector.then.nodes, adjacent_only) : /* @__PURE__ */ new Map();
    const catch_result = relative_selector.catch ? loop_child(relative_selector.catch.nodes, adjacent_only) : /* @__PURE__ */ new Map();
    const not_exhaustive = !has_definite_elements(pending_result) || !has_definite_elements(then_result) || !has_definite_elements(catch_result);
    if (not_exhaustive) {
      mark_as_probably(pending_result);
      mark_as_probably(then_result);
      mark_as_probably(catch_result);
    }
    add_to_map(pending_result, result);
    add_to_map(then_result, result);
    add_to_map(catch_result, result);
  }
  return result;
}
function has_definite_elements(result) {
  if (result.size === 0) return false;
  for (const exist of result.values()) {
    if (exist === NODE_DEFINITELY_EXISTS) {
      return true;
    }
  }
  return false;
}
function add_to_map(from, to) {
  from.forEach((exist, element2) => {
    to.set(element2, higher_existence(exist, to.get(element2)));
  });
}
function higher_existence(exist1, exist2) {
  if (exist1 === void 0 || exist2 === void 0) return exist1 || exist2;
  return exist1 > exist2 ? exist1 : exist2;
}
function mark_as_probably(result) {
  for (const key2 of result.keys()) {
    result.set(key2, NODE_PROBABLY_EXISTS);
  }
}
function loop_child(children, adjacent_only) {
  const result = /* @__PURE__ */ new Map();
  for (let i = children.length - 1; i >= 0; i--) {
    const child = children[i];
    if (child.type === "RegularElement") {
      result.set(child, NODE_DEFINITELY_EXISTS);
      if (adjacent_only) {
        break;
      }
    } else if (child.type === "EachBlock" || child.type === "IfBlock" || child.type === "AwaitBlock") {
      const child_result = get_possible_last_child(child, adjacent_only);
      add_to_map(child_result, result);
      if (adjacent_only && has_definite_elements(child_result)) {
        break;
      }
    }
  }
  return result;
}

// node_modules/svelte/src/compiler/phases/2-analyze/css/css-warn.js
function warn_unused(stylesheet) {
  walk(stylesheet, { stylesheet }, visitors3);
}
var visitors3 = {
  Atrule(node, context) {
    if (!is_keyframes_node(node)) {
      context.next();
    }
  },
  PseudoClassSelector(node, context) {
    if (node.name === "is" || node.name === "where") {
      context.next();
    }
  },
  ComplexSelector(node, context) {
    if (!node.metadata.used) {
      const content = context.state.stylesheet.content;
      const text2 = content.styles.substring(node.start - content.start, node.end - content.start);
      css_unused_selector(node, text2);
    }
    context.next();
  },
  Rule(node, context) {
    if (node.metadata.is_global_block) {
      context.visit(node.prelude);
    } else {
      context.next();
    }
  }
};

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/shared/function.js
function visit_function(node, context) {
  node.metadata = {
    hoisted: false,
    hoisted_params: [],
    scope: context.state.scope
  };
  context.next({
    ...context.state,
    function_depth: context.state.function_depth + 1
  });
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/ArrowFunctionExpression.js
function ArrowFunctionExpression(node, context) {
  visit_function(node, context);
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/AssignmentExpression.js
function AssignmentExpression(node, context) {
  validate_assignment(node, node.left, context.state);
  if (context.state.reactive_statement) {
    const id2 = node.left.type === "MemberExpression" ? object2(node.left) : node.left;
    if (id2 !== null) {
      for (const id3 of extract_identifiers(node.left)) {
        const binding = context.state.scope.get(id3.name);
        if (binding) {
          context.state.reactive_statement.assignments.add(binding);
        }
      }
    }
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/shared/fragment.js
function mark_subtree_dynamic(path) {
  let i = path.length;
  while (i--) {
    const node = path[i];
    if (node.type === "Fragment") {
      if (node.metadata.dynamic) return;
      node.metadata.dynamic = true;
    }
  }
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/Attribute.js
function Attribute(node, context) {
  var _a2, _b2;
  context.next();
  if (node.name === "value") {
    const parent = (
      /** @type {SvelteNode} */
      context.path.at(-1)
    );
    if (parent.type === "RegularElement" && parent.name === "option") {
      mark_subtree_dynamic(context.path);
    }
  }
  if (node.value !== true) {
    for (const chunk of get_attribute_chunks(node.value)) {
      if (chunk.type !== "ExpressionTag") continue;
      if (chunk.expression.type === "FunctionExpression" || chunk.expression.type === "ArrowFunctionExpression") {
        continue;
      }
      (_a2 = node.metadata.expression).has_state || (_a2.has_state = chunk.metadata.expression.has_state);
      (_b2 = node.metadata.expression).has_call || (_b2.has_call = chunk.metadata.expression.has_call);
    }
    if (is_event_attribute(node)) {
      const parent = context.path.at(-1);
      if ((parent == null ? void 0 : parent.type) === "RegularElement" || (parent == null ? void 0 : parent.type) === "SvelteElement") {
        context.state.analysis.uses_event_attributes = true;
      }
      const expression = get_attribute_expression(node);
      const delegated_event = get_delegated_event(node.name.slice(2), expression, context);
      if (delegated_event !== null) {
        if (delegated_event.hoisted) {
          delegated_event.function.metadata.hoisted = true;
        }
        node.metadata.delegated = delegated_event;
      }
    }
  }
}
var unhoisted = { hoisted: false };
function get_delegated_event(event_name, handler, context) {
  var _a2, _b2;
  if (!handler || !is_delegated(event_name)) {
    return null;
  }
  const element2 = context.path.at(-1);
  if ((element2 == null ? void 0 : element2.type) !== "RegularElement") {
    return null;
  }
  let target_function = null;
  let binding = null;
  if (element2.metadata.has_spread) {
    return unhoisted;
  }
  if (handler.type === "ArrowFunctionExpression" || handler.type === "FunctionExpression") {
    target_function = handler;
  } else if (handler.type === "Identifier") {
    binding = context.state.scope.get(handler.name);
    if (context.state.analysis.module.scope.references.has(handler.name)) {
      return unhoisted;
    }
    if (binding != null) {
      for (const { path } of binding.references) {
        const parent = path.at(-1);
        if (parent === void 0) return unhoisted;
        const grandparent = path.at(-2);
        let element3 = null;
        let event_name2 = null;
        if (parent.type === "OnDirective") {
          element3 = /** @type {AST.RegularElement} */
          grandparent;
          event_name2 = parent.name;
        } else if (parent.type === "ExpressionTag" && (grandparent == null ? void 0 : grandparent.type) === "Attribute" && is_event_attribute(grandparent)) {
          element3 = /** @type {AST.RegularElement} */
          path.at(-3);
          const attribute = (
            /** @type {AST.Attribute} */
            grandparent
          );
          event_name2 = get_attribute_event_name(attribute.name);
        }
        if (element3 && event_name2) {
          if (element3.type !== "RegularElement" || element3.metadata.has_spread || !is_delegated(event_name2)) {
            return unhoisted;
          }
        } else if (parent.type !== "FunctionDeclaration" && parent.type !== "VariableDeclarator") {
          return unhoisted;
        }
      }
    }
    if (context.state.analysis.exports.find((node) => node.name === handler.name)) {
      return unhoisted;
    }
    if (binding !== null && binding.initial !== null && !binding.updated && !binding.is_called) {
      const binding_type = binding.initial.type;
      if (binding_type === "ArrowFunctionExpression" || binding_type === "FunctionDeclaration" || binding_type === "FunctionExpression") {
        target_function = binding.initial;
      }
    }
  }
  if (target_function == null || target_function.params.length > 1) {
    return unhoisted;
  }
  const visited_references = /* @__PURE__ */ new Set();
  const scope = target_function.metadata.scope;
  for (const [reference] of scope.references) {
    if (reference === "arguments" || reference === "$host") return unhoisted;
    if (((_a2 = scope.get(`$${reference}`)) == null ? void 0 : _a2.kind) === "store_sub") return unhoisted;
    const binding2 = scope.get(reference);
    const local_binding = context.state.scope.get(reference);
    if (local_binding !== null && binding2 !== null && local_binding.node !== binding2.node) {
      return unhoisted;
    }
    if (binding2 !== null && binding2.kind === "store_sub" && visited_references.has(reference.slice(1))) {
      return unhoisted;
    }
    if (binding2 !== null && ((_b2 = binding2.initial) == null ? void 0 : _b2.type) === "EachBlock") return unhoisted;
    if (binding2 !== null && // Bail out if the the binding is a rest param
    (binding2.declaration_kind === "rest_param" || // Bail out if we reference anything from the EachBlock (for now) that mutates in non-runes mode,
    (!context.state.analysis.runes && binding2.kind === "each" || // or any normal not reactive bindings that are mutated.
    binding2.kind === "normal") && binding2.updated)) {
      return unhoisted;
    }
    visited_references.add(reference);
  }
  return { hoisted: true, function: target_function };
}
function get_attribute_event_name(event_name) {
  event_name = event_name.slice(2);
  if (is_capture_event(event_name)) {
    event_name = event_name.slice(0, -7);
  }
  return event_name;
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/AwaitBlock.js
function AwaitBlock(node, context) {
  validate_block_not_empty(node.pending, context);
  validate_block_not_empty(node.then, context);
  validate_block_not_empty(node.catch, context);
  if (context.state.analysis.runes) {
    validate_opening_tag(node, context.state, "#");
    if (node.value) {
      const start = (
        /** @type {number} */
        node.value.start
      );
      const match = context.state.analysis.source.substring(start - 10, start).match(/{(\s*):then\s+$/);
      if (match && match[1] !== "") {
        block_unexpected_character({ start: start - 10, end: start }, ":");
      }
    }
    if (node.error) {
      const start = (
        /** @type {number} */
        node.error.start
      );
      const match = context.state.analysis.source.substring(start - 10, start).match(/{(\s*):catch\s+$/);
      if (match && match[1] !== "") {
        block_unexpected_character({ start: start - 10, end: start }, ":");
      }
    }
  }
  mark_subtree_dynamic(context.path);
  context.next();
}

// node_modules/svelte/src/compiler/phases/bindings.js
var binding_properties = {
  // media
  currentTime: {
    valid_elements: ["audio", "video"],
    omit_in_ssr: true,
    bidirectional: true
  },
  duration: {
    valid_elements: ["audio", "video"],
    event: "durationchange",
    omit_in_ssr: true
  },
  focused: {},
  paused: {
    valid_elements: ["audio", "video"],
    omit_in_ssr: true,
    bidirectional: true
  },
  buffered: {
    valid_elements: ["audio", "video"],
    omit_in_ssr: true
  },
  seekable: {
    valid_elements: ["audio", "video"],
    omit_in_ssr: true
  },
  played: {
    valid_elements: ["audio", "video"],
    omit_in_ssr: true
  },
  volume: {
    valid_elements: ["audio", "video"],
    omit_in_ssr: true,
    bidirectional: true
  },
  muted: {
    valid_elements: ["audio", "video"],
    omit_in_ssr: true,
    bidirectional: true
  },
  playbackRate: {
    valid_elements: ["audio", "video"],
    omit_in_ssr: true,
    bidirectional: true
  },
  seeking: {
    valid_elements: ["audio", "video"],
    omit_in_ssr: true
  },
  ended: {
    valid_elements: ["audio", "video"],
    omit_in_ssr: true
  },
  readyState: {
    valid_elements: ["audio", "video"],
    omit_in_ssr: true
  },
  // video
  videoHeight: {
    valid_elements: ["video"],
    event: "resize",
    omit_in_ssr: true
  },
  videoWidth: {
    valid_elements: ["video"],
    event: "resize",
    omit_in_ssr: true
  },
  // img
  naturalWidth: {
    valid_elements: ["img"],
    event: "load",
    omit_in_ssr: true
  },
  naturalHeight: {
    valid_elements: ["img"],
    event: "load",
    omit_in_ssr: true
  },
  // document
  activeElement: {
    valid_elements: ["svelte:document"],
    omit_in_ssr: true
  },
  fullscreenElement: {
    valid_elements: ["svelte:document"],
    event: "fullscreenchange",
    omit_in_ssr: true
  },
  pointerLockElement: {
    valid_elements: ["svelte:document"],
    event: "pointerlockchange",
    omit_in_ssr: true
  },
  visibilityState: {
    valid_elements: ["svelte:document"],
    event: "visibilitychange",
    omit_in_ssr: true
  },
  // window
  innerWidth: {
    valid_elements: ["svelte:window"],
    omit_in_ssr: true
  },
  innerHeight: {
    valid_elements: ["svelte:window"],
    omit_in_ssr: true
  },
  outerWidth: {
    valid_elements: ["svelte:window"],
    omit_in_ssr: true
  },
  outerHeight: {
    valid_elements: ["svelte:window"],
    omit_in_ssr: true
  },
  scrollX: {
    valid_elements: ["svelte:window"],
    omit_in_ssr: true,
    bidirectional: true
  },
  scrollY: {
    valid_elements: ["svelte:window"],
    omit_in_ssr: true,
    bidirectional: true
  },
  online: {
    valid_elements: ["svelte:window"],
    omit_in_ssr: true
  },
  devicePixelRatio: {
    valid_elements: ["svelte:window"],
    event: "resize",
    omit_in_ssr: true
  },
  // dimensions
  clientWidth: {
    omit_in_ssr: true,
    invalid_elements: ["svelte:window", "svelte:document"]
  },
  clientHeight: {
    omit_in_ssr: true,
    invalid_elements: ["svelte:window", "svelte:document"]
  },
  offsetWidth: {
    omit_in_ssr: true,
    invalid_elements: ["svelte:window", "svelte:document"]
  },
  offsetHeight: {
    omit_in_ssr: true,
    invalid_elements: ["svelte:window", "svelte:document"]
  },
  contentRect: {
    omit_in_ssr: true,
    invalid_elements: ["svelte:window", "svelte:document"]
  },
  contentBoxSize: {
    omit_in_ssr: true,
    invalid_elements: ["svelte:window", "svelte:document"]
  },
  borderBoxSize: {
    omit_in_ssr: true,
    invalid_elements: ["svelte:window", "svelte:document"]
  },
  devicePixelContentBoxSize: {
    omit_in_ssr: true,
    invalid_elements: ["svelte:window", "svelte:document"]
  },
  // checkbox/radio
  indeterminate: {
    event: "change",
    bidirectional: true,
    valid_elements: ["input"],
    omit_in_ssr: true
    // no corresponding attribute
  },
  checked: {
    valid_elements: ["input"],
    bidirectional: true
  },
  group: {
    valid_elements: ["input"],
    bidirectional: true
  },
  // various
  this: {
    omit_in_ssr: true
  },
  innerText: {
    invalid_elements: ["svelte:window", "svelte:document"],
    bidirectional: true
  },
  innerHTML: {
    invalid_elements: ["svelte:window", "svelte:document"],
    bidirectional: true
  },
  textContent: {
    invalid_elements: ["svelte:window", "svelte:document"],
    bidirectional: true
  },
  open: {
    event: "toggle",
    bidirectional: true,
    valid_elements: ["details"]
  },
  value: {
    valid_elements: ["input", "textarea", "select"],
    bidirectional: true
  },
  files: {
    valid_elements: ["input"],
    omit_in_ssr: true,
    bidirectional: true
  }
};

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/BindDirective.js
function BindDirective(node, context) {
  var _a2;
  validate_no_const_assignment(node, node.expression, context.state.scope, true);
  const assignee = node.expression;
  const left = object2(assignee);
  if (left === null) {
    bind_invalid_expression(node);
  }
  const binding = context.state.scope.get(left.name);
  if (assignee.type === "Identifier") {
    if (node.name !== "this" && // bind:this also works for regular variables
    (!binding || binding.kind !== "state" && binding.kind !== "raw_state" && binding.kind !== "prop" && binding.kind !== "bindable_prop" && binding.kind !== "each" && binding.kind !== "store_sub" && !binding.updated)) {
      bind_invalid_value(node.expression);
    }
    if (context.state.analysis.runes && (binding == null ? void 0 : binding.kind) === "each") {
      each_item_invalid_assignment(node);
    }
    if ((binding == null ? void 0 : binding.kind) === "snippet") {
      snippet_parameter_assignment(node);
    }
  }
  if (node.name === "group") {
    if (!binding) {
      throw new Error("Cannot find declaration for bind:group");
    }
    const each_blocks = [];
    const [keypath, expression_ids] = extract_all_identifiers_from_expression(node.expression);
    let ids = expression_ids;
    let i = context.path.length;
    while (i--) {
      const parent2 = context.path[i];
      if (parent2.type === "EachBlock") {
        const references = ids.filter((id2) => parent2.metadata.declarations.has(id2.name));
        if (references.length > 0) {
          parent2.metadata.contains_group_binding = true;
          each_blocks.push(parent2);
          ids = ids.filter((id2) => !references.includes(id2));
          ids.push(...extract_all_identifiers_from_expression(parent2.expression)[1]);
        }
      }
    }
    const bindings = expression_ids.map((id2) => context.state.scope.get(id2.name));
    let group_name;
    outer: for (const [[key2, b], group] of context.state.analysis.binding_groups) {
      if (b.length !== bindings.length || key2 !== keypath) continue;
      for (let i2 = 0; i2 < bindings.length; i2++) {
        if (bindings[i2] !== b[i2]) continue outer;
      }
      group_name = group;
    }
    if (!group_name) {
      group_name = context.state.scope.root.unique("binding_group");
      context.state.analysis.binding_groups.set([keypath, bindings], group_name);
    }
    node.metadata = {
      binding_group_name: group_name,
      parent_each_blocks: each_blocks
    };
  }
  if ((binding == null ? void 0 : binding.kind) === "each" && ((_a2 = binding.metadata) == null ? void 0 : _a2.inside_rest)) {
    bind_invalid_each_rest(binding.node, binding.node.name);
  }
  const parent = context.path.at(-1);
  if ((parent == null ? void 0 : parent.type) === "RegularElement" || (parent == null ? void 0 : parent.type) === "SvelteElement" || (parent == null ? void 0 : parent.type) === "SvelteWindow" || (parent == null ? void 0 : parent.type) === "SvelteDocument" || (parent == null ? void 0 : parent.type) === "SvelteBody") {
    if (node.name in binding_properties) {
      const property = binding_properties[node.name];
      if (property.valid_elements && !property.valid_elements.includes(parent.name)) {
        bind_invalid_target(
          node,
          node.name,
          property.valid_elements.map((valid_element) => `<${valid_element}>`).join(", ")
        );
      }
      if (property.invalid_elements && property.invalid_elements.includes(parent.name)) {
        const valid_bindings = Object.entries(binding_properties).filter(([_, binding_property]) => {
          var _a3, _b2;
          return ((_a3 = binding_property.valid_elements) == null ? void 0 : _a3.includes(parent.name)) || !binding_property.valid_elements && !((_b2 = binding_property.invalid_elements) == null ? void 0 : _b2.includes(parent.name));
        }).map(([property_name]) => property_name).sort();
        bind_invalid_name(
          node,
          node.name,
          `Possible bindings for <${parent.name}> are ${valid_bindings.join(", ")}`
        );
      }
      if (parent.name === "input" && node.name !== "this") {
        const type = (
          /** @type {AST.Attribute | undefined} */
          parent.attributes.find((a) => a.type === "Attribute" && a.name === "type")
        );
        if (type && !is_text_attribute(type)) {
          if (node.name !== "value" || type.value === true) {
            attribute_invalid_type(type);
          }
        } else {
          if (node.name === "checked" && (type == null ? void 0 : type.value[0].data) !== "checkbox") {
            bind_invalid_target(node, node.name, '<input type="checkbox">');
          }
          if (node.name === "files" && (type == null ? void 0 : type.value[0].data) !== "file") {
            bind_invalid_target(node, node.name, '<input type="file">');
          }
        }
      }
      if (parent.name === "select" && node.name !== "this") {
        const multiple = parent.attributes.find(
          (a) => a.type === "Attribute" && a.name === "multiple" && !is_text_attribute(a) && a.value !== true
        );
        if (multiple) {
          attribute_invalid_multiple(multiple);
        }
      }
      if (node.name === "offsetWidth" && is_svg(parent.name)) {
        bind_invalid_target(
          node,
          node.name,
          `non-<svg> elements. Use 'clientWidth' for <svg> instead`
        );
      }
      if (is_content_editable_binding(node.name)) {
        const contenteditable = (
          /** @type {AST.Attribute} */
          parent.attributes.find((a) => a.type === "Attribute" && a.name === "contenteditable")
        );
        if (!contenteditable) {
          attribute_contenteditable_missing(node);
        } else if (!is_text_attribute(contenteditable) && contenteditable.value !== true) {
          attribute_contenteditable_dynamic(contenteditable);
        }
      }
    } else {
      const match = fuzzymatch(node.name, Object.keys(binding_properties));
      if (match) {
        const property = binding_properties[match];
        if (!property.valid_elements || property.valid_elements.includes(parent.name)) {
          bind_invalid_name(node, node.name, `Did you mean '${match}'?`);
        }
      }
      bind_invalid_name(node, node.name);
    }
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/CallExpression.js
function CallExpression(node, context) {
  var _a2, _b2;
  const parent = (
    /** @type {SvelteNode} */
    get_parent(context.path, -1)
  );
  const rune = get_rune(node, context.state.scope);
  switch (rune) {
    case null:
      if (!is_safe_identifier(node.callee, context.state.scope)) {
        context.state.analysis.needs_context = true;
      }
      break;
    case "$bindable":
      if (node.arguments.length > 1) {
        rune_invalid_arguments_length(node, "$bindable", "zero or one arguments");
      }
      if (parent.type !== "AssignmentPattern" || ((_a2 = context.path.at(-3)) == null ? void 0 : _a2.type) !== "ObjectPattern" || ((_b2 = context.path.at(-4)) == null ? void 0 : _b2.type) !== "VariableDeclarator" || get_rune(
        /** @type {VariableDeclarator} */
        context.path.at(-4).init,
        context.state.scope
      ) !== "$props") {
        bindable_invalid_location(node);
      }
      break;
    case "$host":
      if (node.arguments.length > 0) {
        rune_invalid_arguments(node, "$host");
      } else if (context.state.ast_type === "module" || !context.state.analysis.custom_element) {
        host_invalid_placement(node);
      }
      break;
    case "$props":
      if (context.state.has_props_rune) {
        props_duplicate(node);
      }
      context.state.has_props_rune = true;
      if (parent.type !== "VariableDeclarator" || context.state.ast_type !== "instance" || context.state.scope !== context.state.analysis.instance.scope) {
        props_invalid_placement(node);
      }
      if (node.arguments.length > 0) {
        rune_invalid_arguments(node, rune);
      }
      break;
    case "$state":
    case "$state.raw":
    case "$derived":
    case "$derived.by":
      if (parent.type !== "VariableDeclarator" && !(parent.type === "PropertyDefinition" && !parent.static && !parent.computed)) {
        state_invalid_placement(node, rune);
      }
      if ((rune === "$derived" || rune === "$derived.by") && node.arguments.length !== 1) {
        rune_invalid_arguments_length(node, rune, "exactly one argument");
      } else if (rune === "$state" && node.arguments.length > 1) {
        rune_invalid_arguments_length(node, rune, "zero or one arguments");
      }
      break;
    case "$effect":
    case "$effect.pre":
      if (parent.type !== "ExpressionStatement") {
        effect_invalid_placement(node);
      }
      if (node.arguments.length !== 1) {
        rune_invalid_arguments_length(node, rune, "exactly one argument");
      }
      context.state.analysis.needs_context = true;
      break;
    case "$effect.tracking":
      if (node.arguments.length !== 0) {
        rune_invalid_arguments(node, rune);
      }
      break;
    case "$effect.root":
      if (node.arguments.length !== 1) {
        rune_invalid_arguments_length(node, rune, "exactly one argument");
      }
      break;
    case "$inspect":
      if (node.arguments.length < 1) {
        rune_invalid_arguments_length(node, rune, "one or more arguments");
      }
      break;
    case "$inspect().with":
      if (node.arguments.length !== 1) {
        rune_invalid_arguments_length(node, rune, "exactly one argument");
      }
      break;
    case "$state.snapshot":
      if (node.arguments.length !== 1) {
        rune_invalid_arguments_length(node, rune, "exactly one argument");
      }
      break;
  }
  if (context.state.render_tag) {
    const arg_idx = unwrap_optional(context.state.render_tag.expression).arguments.findIndex(
      (arg) => arg === node || context.path.includes(arg)
    );
    if (arg_idx !== -1) {
      context.state.render_tag.metadata.args_with_call_expression.add(arg_idx);
    }
  }
  if (node.callee.type === "Identifier") {
    const binding = context.state.scope.get(node.callee.name);
    if (binding !== null) {
      binding.is_called = true;
    }
  }
  if (rune === "$inspect" || rune === "$derived") {
    context.next({ ...context.state, function_depth: context.state.function_depth + 1 });
  } else {
    context.next();
  }
  if (context.state.expression) {
    if (!is_pure(node.callee, context) || context.state.expression.dependencies.size > 0) {
      context.state.expression.has_call = true;
      context.state.expression.has_state = true;
    }
  }
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/ClassBody.js
function ClassBody(node, context) {
  var _a2;
  const private_derived_state = [];
  for (const definition of node.body) {
    if (definition.type === "PropertyDefinition" && definition.key.type === "PrivateIdentifier" && ((_a2 = definition.value) == null ? void 0 : _a2.type) === "CallExpression") {
      const rune = get_rune(definition.value, context.state.scope);
      if (rune === "$derived" || rune === "$derived.by") {
        private_derived_state.push(definition.key.name);
      }
    }
  }
  context.next({ ...context.state, private_derived_state });
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/ClassDeclaration.js
function ClassDeclaration(node, context) {
  if (context.state.analysis.runes && node.id !== null) {
    validate_identifier_name(context.state.scope.get(node.id.name));
  }
  const allowed_depth = context.state.ast_type === "module" ? 0 : 1;
  if (context.state.scope.function_depth > allowed_depth) {
    perf_avoid_nested_class(node);
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/ClassDirective.js
function ClassDirective(node, context) {
  mark_subtree_dynamic(context.path);
  context.next({ ...context.state, expression: node.metadata.expression });
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/shared/attribute.js
function validate_attribute_name(attribute) {
  if (attribute.name.includes(":") && !attribute.name.startsWith("xmlns:") && !attribute.name.startsWith("xlink:") && !attribute.name.startsWith("xml:")) {
    attribute_illegal_colon(attribute);
  }
}
function validate_attribute(attribute, parent) {
  var _a2;
  if (Array.isArray(attribute.value) && attribute.value.length === 1 && attribute.value[0].type === "ExpressionTag" && (parent.type === "Component" || parent.type === "SvelteComponent" || parent.type === "SvelteSelf" || parent.type === "RegularElement" && is_custom_element_node(parent))) {
    attribute_quoted(attribute);
  }
  if (attribute.value === true || !Array.isArray(attribute.value) || attribute.value.length === 1) {
    return;
  }
  const is_quoted = ((_a2 = attribute.value.at(-1)) == null ? void 0 : _a2.end) !== attribute.end;
  if (!is_quoted) {
    attribute_unquoted_sequence(attribute);
  }
}
function validate_slot_attribute(context, attribute, is_component = false) {
  const parent = context.path.at(-2);
  let owner = void 0;
  if ((parent == null ? void 0 : parent.type) === "SnippetBlock") {
    if (!is_text_attribute(attribute)) {
      slot_attribute_invalid(attribute);
    }
    return;
  }
  let i = context.path.length;
  while (i--) {
    const ancestor = context.path[i];
    if (!owner && (ancestor.type === "Component" || ancestor.type === "SvelteComponent" || ancestor.type === "SvelteSelf" || ancestor.type === "SvelteElement" || ancestor.type === "RegularElement" && is_custom_element_node(ancestor))) {
      owner = ancestor;
    }
  }
  if (owner) {
    if (!is_text_attribute(attribute)) {
      slot_attribute_invalid(attribute);
    }
    if (owner.type === "Component" || owner.type === "SvelteComponent" || owner.type === "SvelteSelf") {
      if (owner !== parent) {
        slot_attribute_invalid_placement(attribute);
      }
      const name = attribute.value[0].data;
      if (context.state.component_slots.has(name)) {
        slot_attribute_duplicate(attribute, name, owner.name);
      }
      context.state.component_slots.add(name);
      if (name === "default") {
        for (const node of owner.fragment.nodes) {
          if (node.type === "Text" && regex_only_whitespaces.test(node.data)) {
            continue;
          }
          if (node.type === "RegularElement" || node.type === "SvelteFragment") {
            if (node.attributes.some((a) => a.type === "Attribute" && a.name === "slot")) {
              continue;
            }
          }
          slot_default_duplicate(node);
        }
      }
    }
  } else if (!is_component) {
    slot_attribute_invalid_placement(attribute);
  }
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/shared/component.js
function visit_component(node, context) {
  mark_subtree_dynamic(context.path);
  for (const attribute of node.attributes) {
    if (attribute.type !== "Attribute" && attribute.type !== "SpreadAttribute" && attribute.type !== "LetDirective" && attribute.type !== "OnDirective" && attribute.type !== "BindDirective") {
      component_invalid_directive(attribute);
    }
    if (attribute.type === "OnDirective" && (attribute.modifiers.length > 1 || attribute.modifiers.some((m) => m !== "once"))) {
      event_handler_invalid_component_modifier(attribute);
    }
    if (attribute.type === "Attribute") {
      if (context.state.analysis.runes) {
        validate_attribute(attribute, node);
        if (is_expression_attribute(attribute)) {
          const expression = get_attribute_expression(attribute);
          if (expression.type === "SequenceExpression") {
            let i = (
              /** @type {number} */
              expression.start
            );
            while (--i > 0) {
              const char = context.state.analysis.source[i];
              if (char === "(") break;
              if (char === "{") attribute_invalid_sequence_expression(expression);
            }
          }
        }
      }
      validate_attribute_name(attribute);
      if (attribute.name === "slot") {
        validate_slot_attribute(context, attribute, true);
      }
    }
    if (attribute.type === "BindDirective" && attribute.name !== "this") {
      context.state.analysis.uses_component_bindings = true;
    }
  }
  const default_state = determine_slot(node) ? context.state : { ...context.state, scope: node.metadata.scopes.default };
  for (const attribute of node.attributes) {
    context.visit(attribute, attribute.type === "LetDirective" ? default_state : context.state);
  }
  let comments = [];
  const nodes = { default: [] };
  for (const child of node.fragment.nodes) {
    if (child.type === "Comment") {
      comments.push(child);
      continue;
    }
    const slot_name = determine_slot(child) ?? "default";
    (nodes[slot_name] ?? (nodes[slot_name] = [])).push(...comments, child);
    if (slot_name !== "default") comments = [];
  }
  const component_slots = /* @__PURE__ */ new Set();
  for (const slot_name in nodes) {
    const state = {
      ...context.state,
      scope: node.metadata.scopes[slot_name],
      parent_element: null,
      component_slots
    };
    context.visit({ ...node.fragment, nodes: nodes[slot_name] }, state);
  }
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/Component.js
function Component(node, context) {
  const binding = context.state.scope.get(
    node.name.includes(".") ? node.name.slice(0, node.name.indexOf(".")) : node.name
  );
  node.metadata.dynamic = context.state.analysis.runes && // Svelte 4 required you to use svelte:component to switch components
  binding !== null && (binding.kind !== "normal" || node.name.includes("."));
  visit_component(node, context);
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/ConstTag.js
function ConstTag(node, context) {
  if (context.state.analysis.runes) {
    validate_opening_tag(node, context.state, "@");
  }
  const parent = context.path.at(-1);
  const grand_parent = context.path.at(-2);
  if ((parent == null ? void 0 : parent.type) !== "Fragment" || (grand_parent == null ? void 0 : grand_parent.type) !== "IfBlock" && (grand_parent == null ? void 0 : grand_parent.type) !== "SvelteFragment" && (grand_parent == null ? void 0 : grand_parent.type) !== "Component" && (grand_parent == null ? void 0 : grand_parent.type) !== "SvelteComponent" && (grand_parent == null ? void 0 : grand_parent.type) !== "EachBlock" && (grand_parent == null ? void 0 : grand_parent.type) !== "AwaitBlock" && (grand_parent == null ? void 0 : grand_parent.type) !== "SnippetBlock" && ((grand_parent == null ? void 0 : grand_parent.type) !== "RegularElement" && (grand_parent == null ? void 0 : grand_parent.type) !== "SvelteElement" || !grand_parent.attributes.some((a) => a.type === "Attribute" && a.name === "slot"))) {
    const_tag_invalid_placement(node);
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/DebugTag.js
function DebugTag(node, context) {
  if (context.state.analysis.runes) {
    validate_opening_tag(node, context.state, "@");
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/EachBlock.js
function EachBlock(node, context) {
  validate_opening_tag(node, context.state, "#");
  validate_block_not_empty(node.body, context);
  validate_block_not_empty(node.fallback, context);
  const id2 = node.context;
  if (id2.type === "Identifier" && (id2.name === "$state" || id2.name === "$derived")) {
    state_invalid_placement(node, id2.name);
  }
  if (node.key) {
    node.metadata.keyed = node.key.type !== "Identifier" || !node.index || node.key.name !== node.index;
  }
  context.visit(node.expression, {
    ...context.state,
    expression: node.metadata.expression,
    scope: (
      /** @type {Scope} */
      context.state.scope.parent
    )
  });
  context.visit(node.body);
  if (node.key) context.visit(node.key);
  if (node.fallback) context.visit(node.fallback);
  mark_subtree_dynamic(context.path);
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/ExportDefaultDeclaration.js
function ExportDefaultDeclaration(node, context) {
  if (context.state.ast_type === "instance") {
    module_illegal_default_export(node);
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/ExportNamedDeclaration.js
function ExportNamedDeclaration(node, context) {
  var _a2;
  context.next();
  if (((_a2 = node.declaration) == null ? void 0 : _a2.type) === "VariableDeclaration") {
    if (context.state.analysis.runes && context.state.ast_type === "instance" && node.declaration.kind === "let") {
      legacy_export_invalid(node);
    }
    for (const declarator2 of node.declaration.declarations) {
      for (const id2 of extract_identifiers(declarator2.id)) {
        const binding = context.state.scope.get(id2.name);
        if (!binding) continue;
        if (binding.kind === "derived") {
          derived_invalid_export(node);
        }
        if ((binding.kind === "state" || binding.kind === "raw_state") && binding.reassigned) {
          state_invalid_export(node);
        }
      }
    }
  }
  if (context.state.analysis.runes) {
    if (node.declaration && context.state.ast_type === "instance") {
      if (node.declaration.type === "FunctionDeclaration" || node.declaration.type === "ClassDeclaration") {
        context.state.analysis.exports.push({
          name: (
            /** @type {Identifier} */
            node.declaration.id.name
          ),
          alias: null
        });
      } else if (node.declaration.kind === "const") {
        for (const declarator2 of node.declaration.declarations) {
          for (const node2 of extract_identifiers(declarator2.id)) {
            context.state.analysis.exports.push({ name: node2.name, alias: null });
          }
        }
      }
    }
    if (!context.state.ast_type || context.state.ast_type === "module") {
      for (const specified of node.specifiers) {
        const binding = context.state.scope.get(specified.local.name);
        if (!binding) continue;
        if (binding.kind === "derived") {
          derived_invalid_export(node);
        }
        if ((binding.kind === "state" || binding.kind === "raw_state") && binding.reassigned) {
          state_invalid_export(node);
        }
      }
    }
  }
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/ExportSpecifier.js
function ExportSpecifier(node, context) {
  if (context.state.ast_type === "instance") {
    if (context.state.analysis.runes) {
      context.state.analysis.exports.push({
        name: node.local.name,
        alias: node.exported.name
      });
      const binding = context.state.scope.get(node.local.name);
      if (binding) binding.reassigned = binding.updated = true;
    }
  } else {
    validate_export(node, context.state.scope, node.local.name);
  }
}
function validate_export(node, scope, name) {
  const binding = scope.get(name);
  if (!binding) return;
  if (binding.kind === "derived") {
    derived_invalid_export(node);
  }
  if ((binding.kind === "state" || binding.kind === "raw_state") && binding.reassigned) {
    state_invalid_export(node);
  }
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/ExpressionStatement.js
function ExpressionStatement(node, context) {
  if (node.expression.type === "NewExpression" && node.expression.callee.type === "Identifier" && node.expression.arguments.length === 1 && node.expression.arguments[0].type === "ObjectExpression" && node.expression.arguments[0].properties.some(
    (p) => p.type === "Property" && p.key.type === "Identifier" && p.key.name === "target"
  )) {
    const binding = context.state.scope.get(node.expression.callee.name);
    if ((binding == null ? void 0 : binding.kind) === "normal" && binding.declaration_kind === "import") {
      const declaration2 = (
        /** @type {ImportDeclaration} */
        binding.initial
      );
      if (
        /** @type {string} */
        declaration2.source.value.endsWith(".svelte") && declaration2.specifiers.find(
          (s) => s.local.name === binding.node.name && s.type === "ImportDefaultSpecifier"
        )
      ) {
        legacy_component_creation(node.expression);
      }
    }
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/ExpressionTag.js
function ExpressionTag(node, context) {
  if (node.parent && context.state.parent_element) {
    if (!is_tag_valid_with_parent("#text", context.state.parent_element)) {
      node_invalid_placement(node, "`{expression}`", context.state.parent_element);
    }
  }
  mark_subtree_dynamic(context.path);
  context.next({ ...context.state, expression: node.metadata.expression });
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/FunctionDeclaration.js
function FunctionDeclaration(node, context) {
  if (context.state.analysis.runes && node.id !== null) {
    validate_identifier_name(context.state.scope.get(node.id.name));
  }
  visit_function(node, context);
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/FunctionExpression.js
function FunctionExpression(node, context) {
  visit_function(node, context);
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/HtmlTag.js
function HtmlTag(node, context) {
  if (context.state.analysis.runes) {
    validate_opening_tag(node, context.state, "@");
  }
  mark_subtree_dynamic(context.path);
  context.next();
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/shared/declarations.js
function get_value(node) {
  return call("$.get", node);
}
function add_state_transformers(context) {
  for (const [name, binding] of context.state.scope.declarations) {
    if (is_state_source(binding, context.state.analysis) || binding.kind === "derived" || binding.kind === "legacy_reactive") {
      context.state.transform[name] = {
        read: binding.declaration_kind === "var" ? (node) => call("$.safe_get", node) : get_value,
        assign: (node, value) => {
          var _a2;
          let call2 = call("$.set", node, value);
          if (((_a2 = context.state.scope.get(`$${node.name}`)) == null ? void 0 : _a2.kind) === "store_sub") {
            call2 = call("$.store_unsub", call2, literal(`$${node.name}`), id("$$stores"));
          }
          return call2;
        },
        mutate: (node, mutation) => {
          if (context.state.analysis.runes) {
            return mutation;
          }
          return call("$.mutate", node, mutation);
        },
        update: (node) => {
          return call(
            node.prefix ? "$.update_pre" : "$.update",
            node.argument,
            node.operator === "--" && literal(-1)
          );
        }
      };
    }
  }
}

// node_modules/svelte/src/compiler/phases/3-transform/client/utils.js
function is_state_source(binding, analysis) {
  return (binding.kind === "state" || binding.kind === "raw_state") && (!analysis.immutable || binding.reassigned || analysis.accessors);
}
function build_getter(node, state) {
  if (Object.hasOwn(state.transform, node.name)) {
    const binding = state.scope.get(node.name);
    if (node !== (binding == null ? void 0 : binding.node)) {
      return state.transform[node.name].read(node);
    }
  }
  return node;
}
function build_proxy_reassignment(value, previous) {
  return dev ? call("$.proxy", value, null_instane, previous) : call("$.proxy", value);
}
function get_hoisted_params(node, context) {
  var _a2;
  const scope = context.state.scope;
  const params = [];
  function push_unique(id2) {
    if (!params.find((param) => param.name === id2.name)) {
      params.push(id2);
    }
  }
  for (const [reference] of scope.references) {
    let binding = scope.get(reference);
    if (binding !== null && !scope.declarations.has(reference) && binding.initial !== node) {
      if (binding.kind === "store_sub") {
        push_unique(id(binding.node.name));
        binding = /** @type {Binding} */
        scope.get(binding.node.name.slice(1));
      }
      let expression = (_a2 = context.state.transform[reference]) == null ? void 0 : _a2.read(id(binding.node.name));
      if (
        // If it's a destructured derived binding, then we can extract the derived signal reference and use that.
        // TODO this code is bad, we need to kill it
        expression != null && typeof expression !== "function" && expression.type === "MemberExpression" && expression.object.type === "CallExpression" && expression.object.callee.type === "Identifier" && expression.object.callee.name === "$.get" && expression.object.arguments[0].type === "Identifier"
      ) {
        push_unique(id(expression.object.arguments[0].name));
      } else if (
        // If we are referencing a simple $$props value, then we need to reference the object property instead
        (binding.kind === "prop" || binding.kind === "bindable_prop") && !is_prop_source(binding, context.state)
      ) {
        push_unique(id("$$props"));
      } else if (
        // imports don't need to be hoisted
        binding.declaration_kind !== "import"
      ) {
        push_unique(id(binding.node.name));
        if (binding.kind === "rest_prop" && context.state.analysis.runes) {
          push_unique(id("$$props"));
        }
      }
    }
  }
  return params;
}
function build_hoisted_params(node, context) {
  const hoisted_params = get_hoisted_params(node, context);
  node.metadata.hoisted_params = hoisted_params;
  const params = [];
  if (node.params.length === 0) {
    if (hoisted_params.length > 0) {
      params.push(id(context.state.scope.generate("_")));
    }
  } else {
    for (const param of node.params) {
      params.push(
        /** @type {Pattern} */
        context.visit(param)
      );
    }
  }
  params.push(...hoisted_params);
  return params;
}
function get_prop_source(binding, state, name, initial) {
  const args = [id("$$props"), literal(name)];
  let flags = 0;
  if (binding.kind === "bindable_prop") {
    flags |= PROPS_IS_BINDABLE;
  }
  if (state.analysis.immutable) {
    flags |= PROPS_IS_IMMUTABLE;
  }
  if (state.analysis.runes) {
    flags |= PROPS_IS_RUNES;
  }
  if (state.analysis.accessors || (state.analysis.immutable ? binding.reassigned || state.analysis.runes && binding.mutated : binding.updated)) {
    flags |= PROPS_IS_UPDATED;
  }
  let arg;
  if (initial) {
    if (is_simple_expression(initial)) {
      arg = initial;
    } else {
      if (initial.type === "CallExpression" && initial.callee.type === "Identifier" && initial.arguments.length === 0) {
        arg = initial.callee;
      } else {
        arg = thunk(initial);
      }
      flags |= PROPS_IS_LAZY_INITIAL;
    }
  }
  if (flags || arg) {
    args.push(literal(flags));
    if (arg) args.push(arg);
  }
  return call("$.prop", ...args);
}
function is_prop_source(binding, state) {
  return (binding.kind === "prop" || binding.kind === "bindable_prop") && (!state.analysis.runes || state.analysis.accessors || binding.reassigned || binding.initial || // Until legacy mode is gone, we also need to use the prop source when only mutated is true,
  // because the parent could be a legacy component which needs coarse-grained reactivity
  binding.updated);
}
function should_proxy(node, scope) {
  if (!node || node.type === "Literal" || node.type === "TemplateLiteral" || node.type === "ArrowFunctionExpression" || node.type === "FunctionExpression" || node.type === "UnaryExpression" || node.type === "BinaryExpression" || node.type === "Identifier" && node.name === "undefined") {
    return false;
  }
  if (node.type === "Identifier" && scope !== null) {
    const binding = scope.get(node.name);
    if (binding !== null && !binding.reassigned && binding.initial !== null && binding.initial.type !== "FunctionDeclaration" && binding.initial.type !== "ClassDeclaration" && binding.initial.type !== "ImportDeclaration" && binding.initial.type !== "EachBlock") {
      return should_proxy(binding.initial, null);
    }
  }
  return true;
}
function create_derived_block_argument(node, context) {
  if (node.type === "Identifier") {
    context.state.transform[node.name] = { read: get_value };
    return { id: node, declarations: null };
  }
  const pattern = (
    /** @type {Pattern} */
    context.visit(node)
  );
  const identifiers = extract_identifiers(node);
  const id2 = id("$$source");
  const value = id("$$value");
  const block2 = block([
    var_builder(pattern, call("$.get", id2)),
    return_builder(object(identifiers.map((identifier) => prop("init", identifier, identifier))))
  ]);
  const declarations = [var_builder(value, create_derived(context.state, thunk(block2)))];
  for (const id3 of identifiers) {
    context.state.transform[id3.name] = { read: get_value };
    declarations.push(
      var_builder(id3, create_derived(context.state, thunk(member(call("$.get", value), id3))))
    );
  }
  return { id: id2, declarations };
}
function create_derived(state, arg) {
  return call(state.analysis.runes ? "$.derived" : "$.derived_safe_equal", arg);
}
function can_inline_variable(binding) {
  var _a2;
  return !!binding && // in a `<script module>` block
  !binding.scope.parent && // to prevent the need for escaping
  ((_a2 = binding.initial) == null ? void 0 : _a2.type) === "Literal";
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/Identifier.js
function Identifier(node, context) {
  var _a2, _b2;
  let i = context.path.length;
  let parent = (
    /** @type {Expression} */
    context.path[--i]
  );
  if (!is_reference(node, parent)) {
    return;
  }
  mark_subtree_dynamic(context.path);
  if (node.name === "arguments" && !context.path.some((n) => n.type === "FunctionDeclaration" || n.type === "FunctionExpression")) {
    invalid_arguments_usage(node);
  }
  if (node.name === "$$slots") {
    context.state.analysis.uses_slots = true;
  }
  if (context.state.analysis.runes) {
    if (is_rune(node.name) && context.state.scope.get(node.name) === null && context.state.scope.get(node.name.slice(1)) === null) {
      let current = node;
      let name = node.name;
      while (parent.type === "MemberExpression") {
        if (parent.computed) rune_invalid_computed_property(parent);
        name += `.${/** @type {Identifier} */
        parent.property.name}`;
        current = parent;
        parent = /** @type {Expression} */
        context.path[--i];
        if (!is_rune(name)) {
          if (name === "$effect.active") {
            rune_renamed(parent, "$effect.active", "$effect.tracking");
          }
          if (name === "$state.frozen") {
            rune_renamed(parent, "$state.frozen", "$state.raw");
          }
          if (name === "$state.is") {
            rune_removed(parent, "$state.is");
          }
          rune_invalid_name(parent, name);
        }
      }
      if (parent.type !== "CallExpression") {
        rune_missing_parentheses(current);
      }
    }
  }
  let binding = context.state.scope.get(node.name);
  if (!context.state.analysis.runes) {
    if (node.name === "$$props") {
      context.state.analysis.uses_props = true;
    }
    if (node.name === "$$restProps") {
      context.state.analysis.uses_rest_props = true;
    }
  }
  if (binding) {
    if (context.state.expression) {
      context.state.expression.dependencies.add(binding);
      (_a2 = context.state.expression).has_state || (_a2.has_state = binding.kind !== "normal");
    }
    if (context.state.analysis.runes && node !== binding.node && context.state.function_depth === binding.scope.function_depth && // If we have $state that can be proxied or frozen and isn't re-assigned, then that means
    // it's likely not using a primitive value and thus this warning isn't that helpful.
    (binding.kind === "state" && (binding.reassigned || ((_b2 = binding.initial) == null ? void 0 : _b2.type) === "CallExpression" && binding.initial.arguments.length === 1 && binding.initial.arguments[0].type !== "SpreadElement" && !should_proxy(binding.initial.arguments[0], context.state.scope)) || binding.kind === "raw_state" || binding.kind === "derived") && // We're only concerned with reads here
    (parent.type !== "AssignmentExpression" || parent.left !== node) && parent.type !== "UpdateExpression") {
      state_referenced_locally(node);
    }
    if (context.state.reactive_statement && binding.scope === context.state.analysis.module.scope && binding.reassigned) {
      reactive_declaration_module_script_dependency(node);
    }
  }
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/IfBlock.js
function IfBlock(node, context) {
  validate_block_not_empty(node.consequent, context);
  validate_block_not_empty(node.alternate, context);
  if (context.state.analysis.runes) {
    validate_opening_tag(node, context.state, node.elseif ? ":" : "#");
  }
  mark_subtree_dynamic(context.path);
  context.next();
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/ImportDeclaration.js
function ImportDeclaration(node, context) {
  if (context.state.analysis.runes) {
    const source2 = (
      /** @type {string} */
      node.source.value
    );
    if (source2.startsWith("svelte/internal")) {
      import_svelte_internal_forbidden(node);
    }
    if (source2 === "svelte") {
      for (const specifier of node.specifiers) {
        if (specifier.type === "ImportSpecifier") {
          if (specifier.imported.name === "beforeUpdate" || specifier.imported.name === "afterUpdate") {
            runes_mode_invalid_import(specifier, specifier.imported.name);
          }
        }
      }
    }
  }
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/KeyBlock.js
function KeyBlock(node, context) {
  validate_block_not_empty(node.fragment, context);
  if (context.state.analysis.runes) {
    validate_opening_tag(node, context.state, "#");
  }
  mark_subtree_dynamic(context.path);
  context.next();
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/LabeledStatement.js
function LabeledStatement(node, context) {
  if (node.label.name === "$") {
    const parent = (
      /** @type {SvelteNode} */
      context.path.at(-1)
    );
    const is_reactive_statement = context.state.ast_type === "instance" && parent.type === "Program";
    if (is_reactive_statement) {
      if (context.state.analysis.runes) {
        legacy_reactive_statement_invalid(node);
      }
      const reactive_statement = {
        assignments: /* @__PURE__ */ new Set(),
        dependencies: []
      };
      context.next({
        ...context.state,
        reactive_statement,
        function_depth: context.state.scope.function_depth + 1
      });
      for (const [name, nodes] of context.state.scope.references) {
        const binding = context.state.scope.get(name);
        if (binding === null) continue;
        for (const { node: node2, path } of nodes) {
          let left = node2;
          let i = path.length - 1;
          let parent2 = (
            /** @type {Expression} */
            path.at(i)
          );
          while (parent2.type === "MemberExpression") {
            left = parent2;
            parent2 = /** @type {Expression} */
            path.at(--i);
          }
          if (parent2.type === "AssignmentExpression" && parent2.operator === "=" && parent2.left === left) {
            continue;
          }
          reactive_statement.dependencies.push(binding);
          break;
        }
      }
      context.state.reactive_statements.set(node, reactive_statement);
      if (node.body.type === "ExpressionStatement" && node.body.expression.type === "AssignmentExpression") {
        let ids = extract_identifiers(node.body.expression.left);
        if (node.body.expression.left.type === "MemberExpression") {
          const id2 = object2(node.body.expression.left);
          if (id2 !== null) {
            ids = [id2];
          }
        }
        for (const id2 of ids) {
          const binding = context.state.scope.get(id2.name);
          if ((binding == null ? void 0 : binding.kind) === "legacy_reactive") {
            binding.legacy_dependencies = Array.from(reactive_statement.dependencies);
          }
        }
      }
    } else if (!context.state.analysis.runes) {
      reactive_declaration_invalid_placement(node);
    }
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/LetDirective.js
function LetDirective(node, context) {
  const parent = context.path.at(-1);
  if (parent === void 0 || parent.type !== "Component" && parent.type !== "RegularElement" && parent.type !== "SlotElement" && parent.type !== "SvelteElement" && parent.type !== "SvelteComponent" && parent.type !== "SvelteSelf" && parent.type !== "SvelteFragment") {
    let_directive_invalid_placement(node);
  }
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/MemberExpression.js
function MemberExpression(node, context) {
  if (node.object.type === "Identifier" && node.property.type === "Identifier") {
    const binding = context.state.scope.get(node.object.name);
    if ((binding == null ? void 0 : binding.kind) === "rest_prop" && node.property.name.startsWith("$$")) {
      props_illegal_name(node.property);
    }
  }
  if (context.state.expression && !is_pure(node, context)) {
    context.state.expression.has_state = true;
  }
  if (!is_safe_identifier(node, context.state.scope)) {
    context.state.analysis.needs_context = true;
  }
  if (context.state.reactive_statement) {
    const left = object2(node);
    if (left !== null) {
      const binding = context.state.scope.get(left.name);
      if (binding && binding.kind === "normal") {
        const parent = (
          /** @type {Node} */
          context.path.at(-1)
        );
        if (binding.scope === context.state.analysis.module.scope || binding.declaration_kind === "import" || binding.initial && binding.initial.type !== "ArrayExpression" && binding.initial.type !== "ObjectExpression" && binding.scope.function_depth <= 1) {
          if (parent.type !== "MemberExpression" && parent.type !== "CallExpression") {
            reactive_declaration_non_reactive_property(node);
          }
        }
      }
    }
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/NewExpression.js
function NewExpression(node, context) {
  if (node.callee.type === "ClassExpression" && context.state.scope.function_depth > 0) {
    perf_avoid_inline_class(node);
  }
  context.state.analysis.needs_context = true;
  context.next();
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/OnDirective.js
function OnDirective(node, context) {
  var _a2, _b2;
  if (context.state.analysis.runes) {
    const parent_type = (_a2 = context.path.at(-1)) == null ? void 0 : _a2.type;
    if (parent_type === "RegularElement" || parent_type === "SvelteElement") {
      event_directive_deprecated(node, node.name);
    }
  }
  const parent = context.path.at(-1);
  if ((parent == null ? void 0 : parent.type) === "SvelteElement" || (parent == null ? void 0 : parent.type) === "RegularElement") {
    (_b2 = context.state.analysis).event_directive_node ?? (_b2.event_directive_node = node);
  }
  mark_subtree_dynamic(context.path);
  context.next({ ...context.state, expression: node.metadata.expression });
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/shared/a11y.js
var import_aria_query = __toESM(require_lib(), 1);
var import_axobject_query = __toESM(require_lib2(), 1);
var aria_roles = import_aria_query.roles.keys();
var abstract_roles = aria_roles.filter((role) => {
  var _a2;
  return (_a2 = import_aria_query.roles.get(role)) == null ? void 0 : _a2.abstract;
});
var non_abstract_roles = aria_roles.filter((name) => !abstract_roles.includes(name));
var non_interactive_roles = non_abstract_roles.filter((name) => {
  const role = import_aria_query.roles.get(name);
  return (
    // 'toolbar' does not descend from widget, but it does support
    // aria-activedescendant, thus in practice we treat it as a widget.
    // focusable tabpanel elements are recommended if any panels in a set contain content where the first element in the panel is not focusable.
    // 'generic' is meant to have no semantic meaning.
    // 'cell' is treated as CellRole by the AXObject which is interactive, so we treat 'cell' it as interactive as well.
    !["toolbar", "tabpanel", "generic", "cell"].includes(name) && !(role == null ? void 0 : role.superClass.some((classes) => classes.includes("widget")))
  );
}).concat(
  // The `progressbar` is descended from `widget`, but in practice, its
  // value is always `readonly`, so we treat it as a non-interactive role.
  "progressbar"
);
var interactive_roles = non_abstract_roles.filter(
  (name) => !non_interactive_roles.includes(name) && // 'generic' is meant to have no semantic meaning.
  name !== "generic"
);
function is_non_interactive_roles(role) {
  return non_interactive_roles.includes(role);
}
function is_interactive_roles(role) {
  return interactive_roles.includes(role);
}
function is_abstract_role(role) {
  return abstract_roles.includes(role);
}
var presentation_roles = ["presentation", "none"];
function is_presentation_role(role) {
  return presentation_roles.includes(role);
}
function is_hidden_from_screen_reader(tag_name, attribute_map) {
  if (tag_name === "input") {
    const type = get_static_value2(attribute_map.get("type"));
    if (type === "hidden") {
      return true;
    }
  }
  const aria_hidden = attribute_map.get("aria-hidden");
  if (!aria_hidden) return false;
  const aria_hidden_value = get_static_value2(aria_hidden);
  if (aria_hidden_value === null) return true;
  return aria_hidden_value === true || aria_hidden_value === "true";
}
function has_disabled_attribute(attribute_map) {
  const disabled_attr_value = get_static_value2(attribute_map.get("disabled"));
  if (disabled_attr_value) {
    return true;
  }
  const aria_disabled_attr = attribute_map.get("aria-disabled");
  if (aria_disabled_attr) {
    const aria_disabled_attr_value = get_static_value2(aria_disabled_attr);
    if (aria_disabled_attr_value === "true") {
      return true;
    }
  }
  return false;
}
var non_interactive_element_role_schemas = [];
import_aria_query.elementRoles.entries().forEach(([schema, roles]) => {
  if ([...roles].every((role) => role !== "generic" && non_interactive_roles.includes(role))) {
    non_interactive_element_role_schemas.push(schema);
  }
});
var interactive_element_role_schemas = [];
import_aria_query.elementRoles.entries().forEach(([schema, roles]) => {
  if ([...roles].every((role) => interactive_roles.includes(role))) {
    interactive_element_role_schemas.push(schema);
  }
});
var interactive_ax_objects = [...import_axobject_query.AXObjects.keys()].filter(
  (name) => import_axobject_query.AXObjects.get(name).type === "widget"
);
var non_interactive_ax_objects = [...import_axobject_query.AXObjects.keys()].filter(
  (name) => ["windows", "structure"].includes(import_axobject_query.AXObjects.get(name).type)
);
var interactive_element_ax_object_schemas = [];
import_axobject_query.elementAXObjects.entries().forEach(
  /**
   * @param {any} _
   */
  ([schema, ax_object]) => {
    if ([...ax_object].every((role) => interactive_ax_objects.includes(role))) {
      interactive_element_ax_object_schemas.push(schema);
    }
  }
);
var non_interactive_element_ax_object_schemas = [];
import_axobject_query.elementAXObjects.entries().forEach(
  /**
   * @param {any} _
   */
  ([schema, ax_object]) => {
    if ([...ax_object].every((role) => non_interactive_ax_objects.includes(role))) {
      non_interactive_element_ax_object_schemas.push(schema);
    }
  }
);
function match_schema(schema, tag_name, attribute_map) {
  if (schema.name !== tag_name) return false;
  if (!schema.attributes) return true;
  return schema.attributes.every((schema_attribute) => {
    const attribute = attribute_map.get(schema_attribute.name);
    if (!attribute) return false;
    if (schema_attribute.value && schema_attribute.value !== get_static_text_value(attribute)) {
      return false;
    }
    return true;
  });
}
var ElementInteractivity = (
  /** @type {const} */
  {
    Interactive: "interactive",
    NonInteractive: "non-interactive",
    Static: "static"
  }
);
function element_interactivity(tag_name, attribute_map) {
  if (interactive_element_role_schemas.some((schema) => match_schema(schema, tag_name, attribute_map))) {
    return ElementInteractivity.Interactive;
  }
  if (tag_name !== "header" && non_interactive_element_role_schemas.some(
    (schema) => match_schema(schema, tag_name, attribute_map)
  )) {
    return ElementInteractivity.NonInteractive;
  }
  if (interactive_element_ax_object_schemas.some(
    (schema) => match_schema(schema, tag_name, attribute_map)
  )) {
    return ElementInteractivity.Interactive;
  }
  if (non_interactive_element_ax_object_schemas.some(
    (schema) => match_schema(schema, tag_name, attribute_map)
  )) {
    return ElementInteractivity.NonInteractive;
  }
  return ElementInteractivity.Static;
}
function is_interactive_element(tag_name, attribute_map) {
  return element_interactivity(tag_name, attribute_map) === ElementInteractivity.Interactive;
}
function is_non_interactive_element(tag_name, attribute_map) {
  return element_interactivity(tag_name, attribute_map) === ElementInteractivity.NonInteractive;
}
function is_static_element(tag_name, attribute_map) {
  return element_interactivity(tag_name, attribute_map) === ElementInteractivity.Static;
}
function is_semantic_role_element(role, tag_name, attribute_map) {
  for (const [schema, ax_object] of import_axobject_query.elementAXObjects.entries()) {
    if (schema.name === tag_name && (!schema.attributes || schema.attributes.every(
      /** @param {any} attr */
      (attr) => attribute_map.has(attr.name) && get_static_value2(attribute_map.get(attr.name)) === attr.value
    ))) {
      for (const name of ax_object) {
        const roles = import_axobject_query.AXObjectRoles.get(name);
        if (roles) {
          for (const { name: name2 } of roles) {
            if (name2 === role) {
              return true;
            }
          }
        }
      }
    }
  }
  return false;
}
var address_type_tokens = ["shipping", "billing"];
var autofill_field_name_tokens = [
  "",
  "on",
  "off",
  "name",
  "honorific-prefix",
  "given-name",
  "additional-name",
  "family-name",
  "honorific-suffix",
  "nickname",
  "username",
  "new-password",
  "current-password",
  "one-time-code",
  "organization-title",
  "organization",
  "street-address",
  "address-line1",
  "address-line2",
  "address-line3",
  "address-level4",
  "address-level3",
  "address-level2",
  "address-level1",
  "country",
  "country-name",
  "postal-code",
  "cc-name",
  "cc-given-name",
  "cc-additional-name",
  "cc-family-name",
  "cc-number",
  "cc-exp",
  "cc-exp-month",
  "cc-exp-year",
  "cc-csc",
  "cc-type",
  "transaction-currency",
  "transaction-amount",
  "language",
  "bday",
  "bday-day",
  "bday-month",
  "bday-year",
  "sex",
  "url",
  "photo"
];
var contact_type_tokens = ["home", "work", "mobile", "fax", "pager"];
var autofill_contact_field_name_tokens = [
  "tel",
  "tel-country-code",
  "tel-national",
  "tel-area-code",
  "tel-local",
  "tel-local-prefix",
  "tel-local-suffix",
  "tel-extension",
  "email",
  "impp"
];
function is_valid_autocomplete(autocomplete) {
  if (autocomplete === true) {
    return false;
  } else if (!autocomplete) {
    return true;
  }
  const tokens = autocomplete.trim().toLowerCase().split(regex_whitespaces);
  if (typeof tokens[0] === "string" && tokens[0].startsWith("section-")) {
    tokens.shift();
  }
  if (address_type_tokens.includes(tokens[0])) {
    tokens.shift();
  }
  if (autofill_field_name_tokens.includes(tokens[0])) {
    tokens.shift();
  } else {
    if (contact_type_tokens.includes(tokens[0])) {
      tokens.shift();
    }
    if (autofill_contact_field_name_tokens.includes(tokens[0])) {
      tokens.shift();
    } else {
      return false;
    }
  }
  if (tokens[0] === "webauthn") {
    tokens.shift();
  }
  return tokens.length === 0;
}
var aria_attributes = "activedescendant atomic autocomplete busy checked colcount colindex colspan controls current describedby description details disabled dropeffect errormessage expanded flowto grabbed haspopup hidden invalid keyshortcuts label labelledby level live modal multiline multiselectable orientation owns placeholder posinset pressed readonly relevant required roledescription rowcount rowindex rowspan selected setsize sort valuemax valuemin valuenow valuetext".split(
  " "
);
var a11y_required_attributes = {
  a: ["href"],
  area: ["alt", "aria-label", "aria-labelledby"],
  // html-has-lang
  html: ["lang"],
  // iframe-has-title
  iframe: ["title"],
  img: ["alt"],
  object: ["title", "aria-label", "aria-labelledby"]
};
var a11y_distracting_elements2 = ["blink", "marquee"];
var a11y_required_content = [
  // heading-has-content
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6"
];
var a11y_labelable = [
  "button",
  "input",
  "keygen",
  "meter",
  "output",
  "progress",
  "select",
  "textarea"
];
var a11y_interactive_handlers = [
  // Keyboard events
  "keypress",
  "keydown",
  "keyup",
  // Click events
  "click",
  "contextmenu",
  "dblclick",
  "drag",
  "dragend",
  "dragenter",
  "dragexit",
  "dragleave",
  "dragover",
  "dragstart",
  "drop",
  "mousedown",
  "mouseenter",
  "mouseleave",
  "mousemove",
  "mouseout",
  "mouseover",
  "mouseup"
];
var a11y_recommended_interactive_handlers = [
  "click",
  "mousedown",
  "mouseup",
  "keypress",
  "keydown",
  "keyup"
];
var a11y_nested_implicit_semantics = /* @__PURE__ */ new Map([
  ["header", "banner"],
  ["footer", "contentinfo"]
]);
var a11y_implicit_semantics = /* @__PURE__ */ new Map([
  ["a", "link"],
  ["area", "link"],
  ["article", "article"],
  ["aside", "complementary"],
  ["body", "document"],
  ["button", "button"],
  ["datalist", "listbox"],
  ["dd", "definition"],
  ["dfn", "term"],
  ["dialog", "dialog"],
  ["details", "group"],
  ["dt", "term"],
  ["fieldset", "group"],
  ["figure", "figure"],
  ["form", "form"],
  ["h1", "heading"],
  ["h2", "heading"],
  ["h3", "heading"],
  ["h4", "heading"],
  ["h5", "heading"],
  ["h6", "heading"],
  ["hr", "separator"],
  ["img", "img"],
  ["li", "listitem"],
  ["link", "link"],
  ["main", "main"],
  ["menu", "list"],
  ["meter", "progressbar"],
  ["nav", "navigation"],
  ["ol", "list"],
  ["option", "option"],
  ["optgroup", "group"],
  ["output", "status"],
  ["progress", "progressbar"],
  ["section", "region"],
  ["summary", "button"],
  ["table", "table"],
  ["tbody", "rowgroup"],
  ["textarea", "textbox"],
  ["tfoot", "rowgroup"],
  ["thead", "rowgroup"],
  ["tr", "row"],
  ["ul", "list"]
]);
var menuitem_type_to_implicit_role = /* @__PURE__ */ new Map([
  ["command", "menuitem"],
  ["checkbox", "menuitemcheckbox"],
  ["radio", "menuitemradio"]
]);
var input_type_to_implicit_role = /* @__PURE__ */ new Map([
  ["button", "button"],
  ["image", "button"],
  ["reset", "button"],
  ["submit", "button"],
  ["checkbox", "checkbox"],
  ["radio", "radio"],
  ["range", "slider"],
  ["number", "spinbutton"],
  ["email", "textbox"],
  ["search", "searchbox"],
  ["tel", "textbox"],
  ["text", "textbox"],
  ["url", "textbox"]
]);
var a11y_non_interactive_element_to_interactive_role_exceptions = {
  ul: ["listbox", "menu", "menubar", "radiogroup", "tablist", "tree", "treegrid"],
  ol: ["listbox", "menu", "menubar", "radiogroup", "tablist", "tree", "treegrid"],
  li: ["menuitem", "option", "row", "tab", "treeitem"],
  table: ["grid"],
  td: ["gridcell"],
  fieldset: ["radiogroup", "presentation"]
};
var combobox_if_list = ["email", "search", "tel", "text", "url"];
function input_implicit_role(attribute_map) {
  const type_attribute = attribute_map.get("type");
  if (!type_attribute) return;
  const type = get_static_text_value(type_attribute);
  if (!type) return;
  const list_attribute_exists = attribute_map.has("list");
  if (list_attribute_exists && combobox_if_list.includes(type)) {
    return "combobox";
  }
  return input_type_to_implicit_role.get(type);
}
function menuitem_implicit_role(attribute_map) {
  const type_attribute = attribute_map.get("type");
  if (!type_attribute) return;
  const type = get_static_text_value(type_attribute);
  if (!type) return;
  return menuitem_type_to_implicit_role.get(type);
}
function get_implicit_role(name, attribute_map) {
  if (name === "menuitem") {
    return menuitem_implicit_role(attribute_map);
  } else if (name === "input") {
    return input_implicit_role(attribute_map);
  } else {
    return a11y_implicit_semantics.get(name);
  }
}
var invisible_elements = ["meta", "html", "script", "style"];
function is_parent(parent, elements) {
  while (parent) {
    if (parent.type === "SvelteElement") return true;
    if (parent.type === "RegularElement") {
      return elements.includes(parent.name);
    }
    parent = /** @type {TemplateNode} */
    parent.parent;
  }
  return false;
}
function validate_aria_attribute_value(attribute, name, schema, value) {
  const type = schema.type;
  if (value === null) return;
  if (value === true) value = "";
  if (type === "boolean" && value !== "true" && value !== "false") {
    a11y_incorrect_aria_attribute_type_boolean(attribute, name);
  } else if (type === "integer" && (value === "" || !Number.isInteger(+value))) {
    a11y_incorrect_aria_attribute_type_integer(attribute, name);
  } else if (type === "number" && (value === "" || isNaN(+value))) {
    a11y_incorrect_aria_attribute_type(attribute, name, "number");
  } else if ((type === "string" || type === "id") && value === "") {
    a11y_incorrect_aria_attribute_type(attribute, name, "non-empty string");
  } else if (type === "idlist" && value === "") {
    a11y_incorrect_aria_attribute_type_idlist(attribute, name);
  } else if (type === "token") {
    const values = (schema.values ?? []).map((value2) => value2.toString());
    if (!values.includes(value.toLowerCase())) {
      a11y_incorrect_aria_attribute_type_token(
        attribute,
        name,
        list(values.map((v) => `"${v}"`))
      );
    }
  } else if (type === "tokenlist") {
    const values = (schema.values ?? []).map((value2) => value2.toString());
    if (value.toLowerCase().split(regex_whitespaces).some((value2) => !values.includes(value2))) {
      a11y_incorrect_aria_attribute_type_tokenlist(
        attribute,
        name,
        list(values.map((v) => `"${v}"`))
      );
    }
  } else if (type === "tristate" && value !== "true" && value !== "false" && value !== "mixed") {
    a11y_incorrect_aria_attribute_type_tristate(attribute, name);
  }
}
function warn_missing_attribute(node, attributes, name = node.name) {
  const article = regex_starts_with_vowel.test(attributes[0]) || attributes[0] === "href" ? "an" : "a";
  const sequence2 = attributes.length > 1 ? attributes.slice(0, -1).join(", ") + ` or ${attributes[attributes.length - 1]}` : attributes[0];
  a11y_missing_attribute(node, name, article, sequence2);
}
function get_static_value2(attribute) {
  if (!attribute) return null;
  if (attribute.value === true) return true;
  if (is_text_attribute(attribute)) return attribute.value[0].data;
  return null;
}
function get_static_text_value(attribute) {
  const value = get_static_value2(attribute);
  if (value === true) return null;
  return value;
}
function check_element(node, state) {
  var _a2;
  const attribute_map = /* @__PURE__ */ new Map();
  const handlers = /* @__PURE__ */ new Set();
  const attributes = [];
  const is_dynamic_element = node.type === "SvelteElement";
  let has_spread = false;
  let has_contenteditable_attr = false;
  let has_contenteditable_binding = false;
  for (const attribute of node.attributes) {
    if (attribute.type === "SpreadAttribute") {
      has_spread = true;
    } else if (attribute.type === "OnDirective") {
      handlers.add(attribute.name);
    } else if (attribute.type === "Attribute") {
      if (is_event_attribute(attribute)) {
        handlers.add(attribute.name.slice(2));
      } else {
        attributes.push(attribute);
        attribute_map.set(attribute.name, attribute);
        if (attribute.name === "contenteditable") {
          has_contenteditable_attr = true;
        }
      }
    } else if (attribute.type === "BindDirective" && is_content_editable_binding(attribute.name)) {
      has_contenteditable_binding = true;
    }
  }
  for (const attribute of node.attributes) {
    if (attribute.type !== "Attribute") continue;
    const name = attribute.name.toLowerCase();
    if (name.startsWith("aria-")) {
      if (invisible_elements.includes(node.name)) {
        a11y_aria_attributes(attribute, node.name);
      }
      const type = name.slice(5);
      if (!aria_attributes.includes(type)) {
        const match = fuzzymatch(type, aria_attributes);
        a11y_unknown_aria_attribute(attribute, type, match);
      }
      if (name === "aria-hidden" && regex_heading_tags.test(node.name)) {
        a11y_hidden(attribute, node.name);
      }
      let value = get_static_value2(attribute);
      const schema = import_aria_query.aria.get(
        /** @type {ARIAProperty} */
        name
      );
      if (schema !== void 0) {
        validate_aria_attribute_value(
          attribute,
          /** @type {ARIAProperty} */
          name,
          schema,
          value
        );
      }
      if (name === "aria-activedescendant" && !is_dynamic_element && !is_interactive_element(node.name, attribute_map) && !attribute_map.has("tabindex")) {
        a11y_aria_activedescendant_has_tabindex(attribute);
      }
    }
    if (name === "role") {
      if (invisible_elements.includes(node.name)) {
        a11y_misplaced_role(attribute, node.name);
      }
      const value = get_static_value2(attribute);
      if (typeof value === "string") {
        for (const c_r of value.split(regex_whitespaces)) {
          const current_role = (
            /** @type {ARIARoleDefinitionKey} current_role */
            c_r
          );
          if (current_role && is_abstract_role(current_role)) {
            a11y_no_abstract_role(attribute, current_role);
          } else if (current_role && !aria_roles.includes(current_role)) {
            const match = fuzzymatch(current_role, aria_roles);
            a11y_unknown_role(attribute, current_role, match);
          }
          if (current_role === get_implicit_role(node.name, attribute_map) && // <ul role="list"> is ok because CSS list-style:none removes the semantics and this is a way to bring them back
          !["ul", "ol", "li"].includes(node.name) && // <a role="link" /> is ok because without href the a tag doesn't have a role of link
          !(node.name === "a" && !attribute_map.has("href"))) {
            a11y_no_redundant_roles(attribute, current_role);
          }
          const is_parent_section_or_article = is_parent(node.parent, ["section", "article"]);
          if (!is_parent_section_or_article) {
            const has_nested_redundant_role = current_role === a11y_nested_implicit_semantics.get(node.name);
            if (has_nested_redundant_role) {
              a11y_no_redundant_roles(attribute, current_role);
            }
          }
          if (!is_dynamic_element && !is_semantic_role_element(current_role, node.name, attribute_map)) {
            const role2 = import_aria_query.roles.get(current_role);
            if (role2) {
              const required_role_props = Object.keys(role2.requiredProps);
              const has_missing_props = required_role_props.some(
                (prop2) => !attributes.find((a) => a.name === prop2)
              );
              if (has_missing_props) {
                a11y_role_has_required_aria_props(
                  attribute,
                  current_role,
                  list(
                    required_role_props.map((v) => `"${v}"`),
                    "and"
                  )
                );
              }
            }
          }
          if (!has_disabled_attribute(attribute_map) && !is_hidden_from_screen_reader(node.name, attribute_map) && !is_presentation_role(current_role) && is_interactive_roles(current_role) && is_static_element(node.name, attribute_map) && !attribute_map.get("tabindex")) {
            const has_interactive_handlers = [...handlers].some(
              (handler) => a11y_interactive_handlers.includes(handler)
            );
            if (has_interactive_handlers) {
              a11y_interactive_supports_focus(node, current_role);
            }
          }
          if (is_interactive_element(node.name, attribute_map) && (is_non_interactive_roles(current_role) || is_presentation_role(current_role))) {
            a11y_no_interactive_element_to_noninteractive_role(node, node.name, current_role);
          }
          if (is_non_interactive_element(node.name, attribute_map) && is_interactive_roles(current_role) && !((_a2 = a11y_non_interactive_element_to_interactive_role_exceptions[node.name]) == null ? void 0 : _a2.includes(
            current_role
          ))) {
            a11y_no_noninteractive_element_to_interactive_role(node, node.name, current_role);
          }
        }
      }
    }
    if (name === "accesskey") {
      a11y_accesskey(attribute);
    }
    if (name === "autofocus") {
      a11y_autofocus(attribute);
    }
    if (name === "scope" && !is_dynamic_element && node.name !== "th") {
      a11y_misplaced_scope(attribute);
    }
    if (name === "tabindex") {
      const value = get_static_value2(attribute);
      if (!isNaN(value) && +value > 0) {
        a11y_positive_tabindex(attribute);
      }
    }
  }
  const role = attribute_map.get("role");
  const role_static_value = (
    /** @type {ARIARoleDefinitionKey} */
    get_static_text_value(role)
  );
  if (handlers.has("click")) {
    const is_non_presentation_role = role_static_value !== null && !is_presentation_role(role_static_value);
    if (!is_dynamic_element && !is_hidden_from_screen_reader(node.name, attribute_map) && (!role || is_non_presentation_role) && !is_interactive_element(node.name, attribute_map) && !has_spread) {
      const has_key_event = handlers.has("keydown") || handlers.has("keyup") || handlers.has("keypress");
      if (!has_key_event) {
        a11y_click_events_have_key_events(node);
      }
    }
  }
  const role_value = (
    /** @type {ARIARoleDefinitionKey} */
    role ? role_static_value : get_implicit_role(node.name, attribute_map)
  );
  if (!is_dynamic_element && !is_interactive_element(node.name, attribute_map) && !is_interactive_roles(role_static_value)) {
    const tab_index = attribute_map.get("tabindex");
    const tab_index_value = get_static_text_value(tab_index);
    if (tab_index && (tab_index_value === null || Number(tab_index_value) >= 0)) {
      a11y_no_noninteractive_tabindex(node);
    }
  }
  if (typeof role_value === "string" && import_aria_query.roles.has(role_value)) {
    const { props } = (
      /** @type {ARIARoleDefinition} */
      import_aria_query.roles.get(role_value)
    );
    const invalid_aria_props = import_aria_query.aria.keys().filter((attribute) => !(attribute in props));
    const is_implicit = role_value && role === void 0;
    for (const attr of attributes) {
      if (invalid_aria_props.includes(
        /** @type {ARIAProperty} */
        attr.name
      )) {
        if (is_implicit) {
          a11y_role_supports_aria_props_implicit(attr, attr.name, role_value, node.name);
        } else {
          a11y_role_supports_aria_props(attr, attr.name, role_value);
        }
      }
    }
  }
  if (!has_contenteditable_attr && !is_hidden_from_screen_reader(node.name, attribute_map) && !is_presentation_role(role_static_value) && (!is_interactive_element(node.name, attribute_map) && is_non_interactive_roles(role_static_value) || is_non_interactive_element(node.name, attribute_map) && !role)) {
    const has_interactive_handlers = [...handlers].some(
      (handler) => a11y_recommended_interactive_handlers.includes(handler)
    );
    if (has_interactive_handlers) {
      a11y_no_noninteractive_element_interactions(node, node.name);
    }
  }
  if ((!role || role_static_value !== null) && !is_hidden_from_screen_reader(node.name, attribute_map) && !is_presentation_role(role_static_value) && !is_interactive_element(node.name, attribute_map) && !is_interactive_roles(role_static_value) && !is_non_interactive_element(node.name, attribute_map) && !is_non_interactive_roles(role_static_value) && !is_abstract_role(role_static_value)) {
    const interactive_handlers = [...handlers].filter(
      (handler) => a11y_interactive_handlers.includes(handler)
    );
    if (interactive_handlers.length > 0) {
      a11y_no_static_element_interactions(node, node.name, list(interactive_handlers));
    }
  }
  if (handlers.has("mouseover") && !handlers.has("focus")) {
    a11y_mouse_events_have_key_events(node, "mouseover", "focus");
  }
  if (handlers.has("mouseout") && !handlers.has("blur")) {
    a11y_mouse_events_have_key_events(node, "mouseout", "blur");
  }
  const is_labelled = attribute_map.has("aria-label") || attribute_map.has("aria-labelledby");
  if (node.name === "a" || node.name === "button") {
    const is_hidden = get_static_value2(attribute_map.get("aria-hidden")) === "true";
    if (!is_hidden && !is_labelled && !has_content(node)) {
      a11y_consider_explicit_label(node);
    }
  }
  if (node.name === "a") {
    const href = attribute_map.get("href") || attribute_map.get("xlink:href");
    if (href) {
      const href_value = get_static_text_value(href);
      if (href_value !== null) {
        if (href_value === "" || href_value === "#" || /^\W*javascript:/i.test(href_value)) {
          a11y_invalid_attribute(href, href_value, href.name);
        }
      }
    } else if (!has_spread) {
      const id_attribute = get_static_value2(attribute_map.get("id"));
      const name_attribute = get_static_value2(attribute_map.get("name"));
      const aria_disabled_attribute = get_static_value2(attribute_map.get("aria-disabled"));
      if (!id_attribute && !name_attribute && aria_disabled_attribute !== "true") {
        warn_missing_attribute(node, ["href"]);
      }
    }
  } else if (!has_spread) {
    const required_attributes = a11y_required_attributes[node.name];
    if (required_attributes) {
      const has_attribute = required_attributes.some((name) => attribute_map.has(name));
      if (!has_attribute) {
        warn_missing_attribute(node, required_attributes);
      }
    }
  }
  if (node.name === "input") {
    const type = attribute_map.get("type");
    const type_value = get_static_text_value(type);
    if (type_value === "image" && !has_spread) {
      const required_attributes = ["alt", "aria-label", "aria-labelledby"];
      const has_attribute = required_attributes.some((name) => attribute_map.has(name));
      if (!has_attribute) {
        warn_missing_attribute(node, required_attributes, 'input type="image"');
      }
    }
    const autocomplete = attribute_map.get("autocomplete");
    if (type && autocomplete) {
      const autocomplete_value = get_static_value2(autocomplete);
      if (!is_valid_autocomplete(autocomplete_value)) {
        a11y_autocomplete_valid(
          autocomplete,
          /** @type {string} */
          autocomplete_value,
          type_value ?? "..."
        );
      }
    }
  }
  if (node.name === "img") {
    const alt_attribute = get_static_text_value(attribute_map.get("alt"));
    const aria_hidden = get_static_value2(attribute_map.get("aria-hidden"));
    if (alt_attribute && !aria_hidden) {
      if (/\b(image|picture|photo)\b/i.test(alt_attribute)) {
        a11y_img_redundant_alt(node);
      }
    }
  }
  if (node.name === "label") {
    const has_input_child = (node2) => {
      let has = false;
      walk(
        node2,
        {},
        {
          _(node3, { next: next2 }) {
            if (node3.type === "SvelteElement" || node3.type === "SlotElement" || node3.type === "Component" || node3.type === "RenderTag" || node3.type === "RegularElement" && (a11y_labelable.includes(node3.name) || node3.name === "slot")) {
              has = true;
            } else {
              next2();
            }
          }
        }
      );
      return has;
    };
    if (!attribute_map.has("for") && !has_input_child(node)) {
      a11y_label_has_associated_control(node);
    }
  }
  if (node.name === "video") {
    const aria_hidden_attribute = attribute_map.get("aria-hidden");
    const aria_hidden_exist = aria_hidden_attribute && get_static_value2(aria_hidden_attribute);
    if (attribute_map.has("muted") || aria_hidden_exist === "true") {
      return;
    }
    let has_caption = false;
    const track = (
      /** @type {AST.RegularElement | undefined} */
      node.fragment.nodes.find((i) => i.type === "RegularElement" && i.name === "track")
    );
    if (track) {
      has_caption = track.attributes.some(
        (a) => a.type === "SpreadAttribute" || a.type === "Attribute" && a.name === "kind" && get_static_value2(a) === "captions"
      );
    }
    if (!has_caption) {
      a11y_media_has_caption(node);
    }
  }
  if (node.name === "figcaption") {
    if (!is_parent(node.parent, ["figure"])) {
      a11y_figcaption_parent(node);
    }
  }
  if (node.name === "figure") {
    const children = node.fragment.nodes.filter((node2) => {
      if (node2.type === "Comment") return false;
      if (node2.type === "Text") return regex_not_whitespace.test(node2.data);
      return true;
    });
    const index = children.findIndex(
      (child) => child.type === "RegularElement" && child.name === "figcaption"
    );
    if (index !== -1 && index !== 0 && index !== children.length - 1) {
      a11y_figcaption_index(children[index]);
    }
  }
  if (a11y_distracting_elements2.includes(node.name)) {
    a11y_distracting_elements(node, node.name);
  }
  if (!is_labelled && !has_contenteditable_binding && a11y_required_content.includes(node.name) && !has_content(node)) {
    a11y_missing_content(node, node.name);
  }
}
function has_content(element2) {
  for (const node of element2.fragment.nodes) {
    if (node.type === "Text") {
      if (node.data.trim() === "") {
        continue;
      }
    }
    if (node.type === "RegularElement" || node.type === "SvelteElement") {
      if (node.name === "img" && node.attributes.some((node2) => node2.type === "Attribute" && node2.name === "alt")) {
        return true;
      }
      if (!has_content(node)) {
        continue;
      }
    }
    return true;
  }
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/shared/element.js
var EVENT_MODIFIERS = [
  "preventDefault",
  "stopPropagation",
  "stopImmediatePropagation",
  "capture",
  "once",
  "passive",
  "nonpassive",
  "self",
  "trusted"
];
function validate_element(node, context) {
  let has_animate_directive = false;
  let in_transition = null;
  let out_transition = null;
  for (const attribute of node.attributes) {
    if (attribute.type === "Attribute") {
      const is_expression = is_expression_attribute(attribute);
      if (context.state.analysis.runes) {
        validate_attribute(attribute, node);
        if (is_expression) {
          const expression = get_attribute_expression(attribute);
          if (expression.type === "SequenceExpression") {
            let i = (
              /** @type {number} */
              expression.start
            );
            while (--i > 0) {
              const char = context.state.analysis.source[i];
              if (char === "(") break;
              if (char === "{") attribute_invalid_sequence_expression(expression);
            }
          }
        }
      }
      if (regex_illegal_attribute_character.test(attribute.name)) {
        attribute_invalid_name(attribute, attribute.name);
      }
      if (attribute.name.startsWith("on") && attribute.name.length > 2) {
        if (!is_expression) {
          attribute_invalid_event_handler(attribute);
        }
        const value = get_attribute_expression(attribute);
        if (value.type === "Identifier" && value.name === attribute.name && !context.state.scope.get(value.name)) {
          attribute_global_event_reference(attribute, attribute.name);
        }
      }
      if (attribute.name === "slot") {
        validate_slot_attribute(context, attribute);
      }
      if (attribute.name === "is") {
        attribute_avoid_is(attribute);
      }
      const correct_name = react_attributes.get(attribute.name);
      if (correct_name) {
        attribute_invalid_property_name(attribute, attribute.name, correct_name);
      }
      validate_attribute_name(attribute);
    } else if (attribute.type === "AnimateDirective") {
      const parent = context.path.at(-2);
      if ((parent == null ? void 0 : parent.type) !== "EachBlock") {
        animation_invalid_placement(attribute);
      } else if (!parent.key) {
        animation_missing_key(attribute);
      } else if (parent.body.nodes.filter(
        (n) => n.type !== "Comment" && n.type !== "ConstTag" && (n.type !== "Text" || n.data.trim() !== "")
      ).length > 1) {
        animation_invalid_placement(attribute);
      }
      if (has_animate_directive) {
        animation_duplicate(attribute);
      } else {
        has_animate_directive = true;
      }
    } else if (attribute.type === "TransitionDirective") {
      const existing = (
        /** @type {AST.TransitionDirective | null} */
        attribute.intro && in_transition || attribute.outro && out_transition
      );
      if (existing) {
        const a = existing.intro ? existing.outro ? "transition" : "in" : "out";
        const b = attribute.intro ? attribute.outro ? "transition" : "in" : "out";
        if (a === b) {
          transition_duplicate(attribute, a);
        } else {
          transition_conflict(attribute, a, b);
        }
      }
      if (attribute.intro) in_transition = attribute;
      if (attribute.outro) out_transition = attribute;
    } else if (attribute.type === "OnDirective") {
      let has_passive_modifier = false;
      let conflicting_passive_modifier = "";
      for (const modifier of attribute.modifiers) {
        if (!EVENT_MODIFIERS.includes(modifier)) {
          const list3 = `${EVENT_MODIFIERS.slice(0, -1).join(", ")} or ${EVENT_MODIFIERS.at(-1)}`;
          event_handler_invalid_modifier(attribute, list3);
        }
        if (modifier === "passive") {
          has_passive_modifier = true;
        } else if (modifier === "nonpassive" || modifier === "preventDefault") {
          conflicting_passive_modifier = modifier;
        }
        if (has_passive_modifier && conflicting_passive_modifier) {
          event_handler_invalid_modifier_combination(
            attribute,
            "passive",
            conflicting_passive_modifier
          );
        }
      }
    }
  }
}
var react_attributes = /* @__PURE__ */ new Map([
  ["className", "class"],
  ["htmlFor", "for"]
]);

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/RegularElement.js
function RegularElement(node, context) {
  var _a2;
  validate_element(node, context);
  check_element(node, context.state);
  node.metadata.path = [...context.path];
  context.state.analysis.elements.push(node);
  if (node.name === "textarea" && node.fragment.nodes.length > 0) {
    for (const attribute of node.attributes) {
      if (attribute.type === "Attribute" && attribute.name === "value") {
        textarea_invalid_content(node);
      }
    }
    if (node.fragment.nodes.length > 1 || node.fragment.nodes[0].type !== "Text") {
      const first = node.fragment.nodes[0];
      if (first.type === "Text") {
        first.data = first.data.replace(regex_starts_with_newline, "");
        first.raw = first.raw.replace(regex_starts_with_newline, "");
      }
      node.attributes.push(
        create_attribute(
          "value",
          /** @type {AST.Text} */
          node.fragment.nodes.at(0).start,
          /** @type {AST.Text} */
          node.fragment.nodes.at(-1).end,
          // @ts-ignore
          node.fragment.nodes
        )
      );
      node.fragment.nodes = [];
    }
  }
  if (node.name === "option" && ((_a2 = node.fragment.nodes) == null ? void 0 : _a2.length) === 1 && node.fragment.nodes[0].type === "ExpressionTag" && !node.attributes.some(
    (attribute) => attribute.type === "Attribute" && attribute.name === "value"
  )) {
    const child = node.fragment.nodes[0];
    node.attributes.push(create_attribute("value", child.start, child.end, [child]));
  }
  if (node.attributes.some(
    (attribute) => attribute.type === "Attribute" && (attribute.name === "autofocus" || attribute.name === "muted")
  )) {
    mark_subtree_dynamic(context.path);
  }
  const binding = context.state.scope.get(node.name);
  if (binding !== null && binding.declaration_kind === "import" && binding.references.length === 0) {
    component_name_lowercase(node, node.name);
  }
  node.metadata.has_spread = node.attributes.some(
    (attribute) => attribute.type === "SpreadAttribute"
  );
  node.metadata.svg = is_svg(node.name);
  node.metadata.mathml = is_mathml(node.name);
  if (is_custom_element_node(node) && node.attributes.length > 0) {
    mark_subtree_dynamic(context.path);
  }
  if (context.state.parent_element) {
    let past_parent = false;
    let only_warn = false;
    const ancestors = [context.state.parent_element];
    for (let i = context.path.length - 1; i >= 0; i--) {
      const ancestor = context.path[i];
      if (ancestor.type === "IfBlock" || ancestor.type === "EachBlock" || ancestor.type === "AwaitBlock" || ancestor.type === "KeyBlock") {
        only_warn = true;
      }
      if (!past_parent) {
        if (ancestor.type === "RegularElement" && ancestor.name === context.state.parent_element) {
          if (!is_tag_valid_with_parent(node.name, context.state.parent_element)) {
            if (only_warn) {
              node_invalid_placement_ssr(
                node,
                `\`<${node.name}>\``,
                context.state.parent_element
              );
            } else {
              node_invalid_placement(node, `\`<${node.name}>\``, context.state.parent_element);
            }
          }
          past_parent = true;
        }
      } else if (ancestor.type === "RegularElement") {
        ancestors.push(ancestor.name);
        if (!is_tag_valid_with_ancestor(node.name, ancestors)) {
          if (only_warn) {
            node_invalid_placement_ssr(node, `\`<${node.name}>\``, ancestor.name);
          } else {
            node_invalid_placement(node, `\`<${node.name}>\``, ancestor.name);
          }
        }
      } else if (ancestor.type === "Component" || ancestor.type === "SvelteComponent" || ancestor.type === "SvelteElement" || ancestor.type === "SvelteSelf" || ancestor.type === "SnippetBlock") {
        break;
      }
    }
  }
  const node_name = node.name.replace(/[a-zA-Z-]*:/g, "");
  if (context.state.analysis.source[node.end - 2] === "/" && !is_void(node_name) && !is_svg(node_name)) {
    element_invalid_self_closing_tag(node, node.name);
  }
  context.next({ ...context.state, parent_element: node.name });
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/RenderTag.js
function RenderTag(node, context) {
  var _a2;
  validate_opening_tag(node, context.state, "@");
  context.state.analysis.elements.push(node);
  const callee = unwrap_optional(node.expression).callee;
  node.metadata.dynamic = callee.type !== "Identifier" || ((_a2 = context.state.scope.get(callee.name)) == null ? void 0 : _a2.kind) !== "normal";
  context.state.analysis.uses_render_tags = true;
  const raw_args = unwrap_optional(node.expression).arguments;
  for (const arg of raw_args) {
    if (arg.type === "SpreadElement") {
      render_tag_invalid_spread_argument(arg);
    }
  }
  if (callee.type === "MemberExpression" && callee.property.type === "Identifier" && ["bind", "apply", "call"].includes(callee.property.name)) {
    render_tag_invalid_call_expression(node);
  }
  mark_subtree_dynamic(context.path);
  context.next({ ...context.state, render_tag: node });
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/SlotElement.js
function SlotElement(node, context) {
  if (context.state.analysis.runes && !context.state.analysis.custom_element) {
    slot_element_deprecated(node);
  }
  mark_subtree_dynamic(context.path);
  let name = "default";
  for (const attribute of node.attributes) {
    if (attribute.type === "Attribute") {
      if (attribute.name === "name") {
        if (!is_text_attribute(attribute)) {
          slot_element_invalid_name(attribute);
        }
        name = attribute.value[0].data;
        if (name === "default") {
          slot_element_invalid_name_default(attribute);
        }
      }
    } else if (attribute.type !== "SpreadAttribute" && attribute.type !== "LetDirective") {
      slot_element_invalid_attribute(attribute);
    }
  }
  context.state.analysis.slot_names.set(name, node);
  context.next();
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/SnippetBlock.js
function SnippetBlock(node, context) {
  validate_block_not_empty(node.body, context);
  if (context.state.analysis.runes) {
    validate_opening_tag(node, context.state, "#");
  }
  for (const arg of node.parameters) {
    if (arg.type === "RestElement") {
      snippet_invalid_rest_parameter(arg);
    }
  }
  context.next({ ...context.state, parent_element: null });
  const { path } = context;
  const parent = path.at(-2);
  if (!parent) return;
  if (parent.type === "Component" && parent.attributes.some(
    (attribute) => (attribute.type === "Attribute" || attribute.type === "BindDirective") && attribute.name === node.expression.name
  )) {
    snippet_shadowing_prop(node, node.expression.name);
  }
  if (node.expression.name !== "children") return;
  if (parent.type === "Component" || parent.type === "SvelteComponent" || parent.type === "SvelteSelf") {
    if (parent.fragment.nodes.some(
      (node2) => node2.type !== "SnippetBlock" && (node2.type !== "Text" || node2.data.trim()) && node2.type !== "Comment"
    )) {
      snippet_conflict(node);
    }
  }
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/SpreadAttribute.js
function SpreadAttribute(node, context) {
  mark_subtree_dynamic(context.path);
  context.next({ ...context.state, expression: node.metadata.expression });
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/StyleDirective.js
function StyleDirective(node, context) {
  var _a2, _b2;
  if (node.modifiers.length > 1 || node.modifiers.length && node.modifiers[0] !== "important") {
    style_directive_invalid_modifier(node);
  }
  mark_subtree_dynamic(context.path);
  if (node.value === true) {
    let binding = context.state.scope.get(node.name);
    if (binding) {
      if (binding.kind !== "normal") {
        node.metadata.expression.has_state = true;
      }
    }
  } else {
    context.next();
    for (const chunk of get_attribute_chunks(node.value)) {
      if (chunk.type !== "ExpressionTag") continue;
      (_a2 = node.metadata.expression).has_state || (_a2.has_state = chunk.metadata.expression.has_state);
      (_b2 = node.metadata.expression).has_call || (_b2.has_call = chunk.metadata.expression.has_call);
    }
  }
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/SvelteBody.js
function SvelteBody(node, context) {
  disallow_children(node);
  for (const attribute of node.attributes) {
    if (attribute.type === "SpreadAttribute" || attribute.type === "Attribute" && !is_event_attribute(attribute)) {
      svelte_body_illegal_attribute(attribute);
    }
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/SvelteComponent.js
function SvelteComponent(node, context) {
  if (context.state.analysis.runes) {
    svelte_component_deprecated(node);
  }
  context.visit(node.expression);
  visit_component(node, context);
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/SvelteDocument.js
function SvelteDocument(node, context) {
  disallow_children(node);
  context.next();
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/SvelteElement.js
function SvelteElement(node, context) {
  validate_element(node, context);
  check_element(node, context.state);
  context.state.analysis.elements.push(node);
  const xmlns = (
    /** @type {AST.Attribute & { value: [AST.Text] } | undefined} */
    node.attributes.find(
      (a) => a.type === "Attribute" && a.name === "xmlns" && is_text_attribute(a)
    )
  );
  if (xmlns) {
    node.metadata.svg = xmlns.value[0].data === NAMESPACE_SVG;
    node.metadata.mathml = xmlns.value[0].data === NAMESPACE_MATHML;
  } else {
    let i = context.path.length;
    while (i--) {
      const ancestor = context.path[i];
      if (ancestor.type === "Component" || ancestor.type === "SvelteComponent" || ancestor.type === "SvelteFragment" || ancestor.type === "SnippetBlock") {
        node.metadata.svg = context.state.options.namespace === "svg";
        node.metadata.mathml = context.state.options.namespace === "mathml";
        break;
      }
      if (ancestor.type === "SvelteElement" || ancestor.type === "RegularElement") {
        node.metadata.svg = ancestor.type === "RegularElement" && ancestor.name === "foreignObject" ? false : ancestor.metadata.svg;
        node.metadata.mathml = ancestor.type === "RegularElement" && ancestor.name === "foreignObject" ? false : ancestor.metadata.mathml;
        break;
      }
    }
  }
  mark_subtree_dynamic(context.path);
  context.next({ ...context.state, parent_element: null });
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/SvelteFragment.js
function SvelteFragment(node, context) {
  const parent = context.path.at(-2);
  if ((parent == null ? void 0 : parent.type) !== "Component" && (parent == null ? void 0 : parent.type) !== "SvelteComponent") {
    svelte_fragment_invalid_placement(node);
  }
  for (const attribute of node.attributes) {
    if (attribute.type === "Attribute") {
      if (attribute.name === "slot") {
        validate_slot_attribute(context, attribute);
      }
    } else if (attribute.type !== "LetDirective") {
      svelte_fragment_invalid_attribute(attribute);
    }
  }
  context.next({ ...context.state, parent_element: null });
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/SvelteHead.js
function SvelteHead(node, context) {
  for (const attribute of node.attributes) {
    svelte_head_illegal_attribute(attribute);
  }
  mark_subtree_dynamic(context.path);
  context.next();
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/SvelteSelf.js
function SvelteSelf(node, context) {
  const valid = context.path.some(
    (node2) => node2.type === "IfBlock" || node2.type === "EachBlock" || node2.type === "Component" || node2.type === "SnippetBlock"
  );
  if (!valid) {
    svelte_self_invalid_placement(node);
  }
  if (context.state.analysis.runes) {
    const name = filename === "(unknown)" ? "Self" : context.state.analysis.name;
    const basename = filename === "(unknown)" ? "Self.svelte" : (
      /** @type {string} */
      filename.split(/[/\\]/).pop()
    );
    svelte_self_deprecated(node, name, basename);
  }
  visit_component(node, context);
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/SvelteWindow.js
function SvelteWindow(node, context) {
  disallow_children(node);
  context.next();
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/TaggedTemplateExpression.js
function TaggedTemplateExpression(node, context) {
  if (context.state.expression && !is_pure(node.tag, context)) {
    context.state.expression.has_call = true;
    context.state.expression.has_state = true;
  }
  if (node.tag.type === "Identifier") {
    const binding = context.state.scope.get(node.tag.name);
    if (binding !== null) {
      binding.is_called = true;
    }
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/Text.js
function Text(node, context) {
  if (node.parent && context.state.parent_element && regex_not_whitespace.test(node.data)) {
    if (!is_tag_valid_with_parent("#text", context.state.parent_element)) {
      node_invalid_placement(node, "Text node", context.state.parent_element);
    }
  }
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/TitleElement.js
function TitleElement(node, context) {
  for (const attribute of node.attributes) {
    title_illegal_attribute(attribute);
  }
  for (const child of node.fragment.nodes) {
    if (child.type !== "Text" && child.type !== "ExpressionTag") {
      title_invalid_content(child);
    }
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/TransitionDirective.js
function TransitionDirective(node, context) {
  mark_subtree_dynamic(context.path);
  context.next();
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/UpdateExpression.js
function UpdateExpression(node, context) {
  validate_assignment(node, node.argument, context.state);
  if (context.state.reactive_statement) {
    const id2 = node.argument.type === "MemberExpression" ? object2(node.argument) : node.argument;
    if ((id2 == null ? void 0 : id2.type) === "Identifier") {
      const binding = context.state.scope.get(id2.name);
      if (binding) {
        context.state.reactive_statement.assignments.add(binding);
      }
    }
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/UseDirective.js
function UseDirective(node, context) {
  mark_subtree_dynamic(context.path);
  context.next();
}

// node_modules/svelte/src/compiler/utils/assert.js
function equal(actual, expected) {
  if (actual !== expected) throw new Error("Assertion failed");
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/VariableDeclarator.js
function VariableDeclarator(node, context) {
  var _a2, _b2;
  ensure_no_module_import_conflict(node, context.state);
  if (context.state.analysis.runes) {
    const init2 = node.init;
    const rune = get_rune(init2, context.state.scope);
    const paths = extract_paths(node.id);
    for (const path of paths) {
      validate_identifier_name(context.state.scope.get(
        /** @type {Identifier} */
        path.node.name
      ));
    }
    if (rune === "$state" || rune === "$state.raw" || rune === "$derived" || rune === "$derived.by" || rune === "$props") {
      for (const path of paths) {
        const binding = (
          /** @type {Binding} */
          context.state.scope.get(path.node.name)
        );
        binding.kind = rune === "$state" ? "state" : rune === "$state.raw" ? "raw_state" : rune === "$derived" || rune === "$derived.by" ? "derived" : path.is_rest ? "rest_prop" : "prop";
      }
    }
    if (rune === "$props") {
      if (node.id.type !== "ObjectPattern" && node.id.type !== "Identifier") {
        props_invalid_identifier(node);
      }
      context.state.analysis.needs_props = true;
      if (node.id.type === "Identifier") {
        const binding = (
          /** @type {Binding} */
          context.state.scope.get(node.id.name)
        );
        binding.initial = null;
        binding.kind = "rest_prop";
      } else {
        equal(node.id.type, "ObjectPattern");
        for (const property of node.id.properties) {
          if (property.type !== "Property") continue;
          if (property.computed) {
            props_invalid_pattern(property);
          }
          if (property.key.type === "Identifier" && property.key.name.startsWith("$$")) {
            props_illegal_name(property);
          }
          const value = property.value.type === "AssignmentPattern" ? property.value.left : property.value;
          if (value.type !== "Identifier") {
            props_invalid_pattern(property);
          }
          const alias = property.key.type === "Identifier" ? property.key.name : String(
            /** @type {Literal} */
            property.key.value
          );
          let initial = property.value.type === "AssignmentPattern" ? property.value.right : null;
          const binding = (
            /** @type {Binding} */
            context.state.scope.get(value.name)
          );
          binding.prop_alias = alias;
          if ((initial == null ? void 0 : initial.type) === "CallExpression" && initial.callee.type === "Identifier" && initial.callee.name === "$bindable") {
            binding.initial = /** @type {Expression | null} */
            initial.arguments[0] ?? null;
            binding.kind = "bindable_prop";
          } else {
            binding.initial = initial;
          }
        }
      }
    }
  } else {
    if (((_a2 = node.init) == null ? void 0 : _a2.type) === "CallExpression") {
      const callee = node.init.callee;
      if (callee.type === "Identifier" && (callee.name === "$state" || callee.name === "$derived" || callee.name === "$props") && ((_b2 = context.state.scope.get(callee.name)) == null ? void 0 : _b2.kind) !== "store_sub") {
        rune_invalid_usage(node.init, callee.name);
      }
    }
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/2-analyze/index.js
var visitors4 = {
  _(node, { state, next: next2, path }) {
    const parent = path.at(-1);
    const ignores = [];
    if ((parent == null ? void 0 : parent.type) === "Fragment" && node.type !== "Comment" && node.type !== "Text") {
      const idx = parent.nodes.indexOf(
        /** @type {any} */
        node
      );
      for (let i = idx - 1; i >= 0; i--) {
        const prev = parent.nodes[i];
        if (prev.type === "Comment") {
          ignores.push(
            ...extract_svelte_ignore(
              prev.start + 4,
              prev.data,
              state.analysis.runes
            )
          );
        } else if (prev.type !== "Text") {
          break;
        }
      }
    } else {
      const comments = (
        /** @type {any} */
        node.leadingComments
      );
      if (comments) {
        for (const comment of comments) {
          ignores.push(
            ...extract_svelte_ignore(
              comment.start + 2,
              comment.value,
              state.analysis.runes
            )
          );
        }
      }
    }
    if (ignores.length > 0) {
      push_ignore(ignores);
    }
    ignore_map.set(node, structuredClone(ignore_stack));
    const scope = state.scopes.get(node);
    next2(scope !== void 0 && scope !== state.scope ? { ...state, scope } : state);
    if (ignores.length > 0) {
      pop_ignore();
    }
  },
  ArrowFunctionExpression,
  AssignmentExpression,
  Attribute,
  AwaitBlock,
  BindDirective,
  CallExpression,
  ClassBody,
  ClassDeclaration,
  ClassDirective,
  Component,
  ConstTag,
  DebugTag,
  EachBlock,
  ExportDefaultDeclaration,
  ExportNamedDeclaration,
  ExportSpecifier,
  ExpressionStatement,
  ExpressionTag,
  FunctionDeclaration,
  FunctionExpression,
  HtmlTag,
  Identifier,
  IfBlock,
  ImportDeclaration,
  KeyBlock,
  LabeledStatement,
  LetDirective,
  MemberExpression,
  NewExpression,
  OnDirective,
  RegularElement,
  RenderTag,
  SlotElement,
  SnippetBlock,
  SpreadAttribute,
  StyleDirective,
  SvelteBody,
  SvelteComponent,
  SvelteDocument,
  SvelteElement,
  SvelteFragment,
  SvelteHead,
  SvelteSelf,
  SvelteWindow,
  TaggedTemplateExpression,
  Text,
  TransitionDirective,
  TitleElement,
  UpdateExpression,
  UseDirective,
  VariableDeclarator
};
function js(script, root, allow_reactive_declarations, parent) {
  const ast = (script == null ? void 0 : script.content) ?? {
    type: "Program",
    sourceType: "module",
    start: -1,
    end: -1,
    body: []
  };
  const { scope, scopes } = create_scopes(ast, root, allow_reactive_declarations, parent);
  return { ast, scope, scopes };
}
function get_component_name(filename2) {
  const parts = filename2.split(/[/\\]/);
  const basename = (
    /** @type {string} */
    parts.pop()
  );
  const last_dir = (
    /** @type {string} */
    parts.at(-1)
  );
  let name = basename.replace(".svelte", "");
  if (name === "index" && last_dir && last_dir !== "src") {
    name = last_dir;
  }
  return name[0].toUpperCase() + name.slice(1);
}
var RESERVED = ["$$props", "$$restProps", "$$slots"];
function analyze_module(ast, options) {
  const { scope, scopes } = create_scopes(ast, new ScopeRoot(), false, null);
  for (const [name, references] of scope.references) {
    if (name[0] !== "$" || RESERVED.includes(name)) continue;
    if (name === "$" || name[1] === "$") {
      global_reference_invalid(references[0].node, name);
    }
    const binding = scope.get(name.slice(1));
    if (binding !== null && !is_rune(name)) {
      store_invalid_subscription_module(references[0].node);
    }
  }
  walk(
    /** @type {Node} */
    ast,
    {
      scope,
      scopes,
      // @ts-expect-error TODO
      analysis: { runes: true }
    },
    visitors4
  );
  return {
    module: { ast, scope, scopes },
    name: options.filename,
    accessors: false,
    runes: true,
    immutable: true
  };
}
function analyze_component(root, source2, options) {
  var _a2, _b2, _c;
  const scope_root = new ScopeRoot();
  const module = js(root.module, scope_root, false, null);
  const instance = js(root.instance, scope_root, true, module.scope);
  const { scope, scopes } = create_scopes(root.fragment, scope_root, false, instance.scope);
  const template3 = { ast: root.fragment, scope, scopes };
  for (const [name, references] of module.scope.references) {
    if (name[0] !== "$" || RESERVED.includes(name)) continue;
    if (name === "$" || name[1] === "$") {
      global_reference_invalid(references[0].node, name);
    }
    const store_name = name.slice(1);
    const declaration2 = instance.scope.get(store_name);
    if (options.runes === false || !is_rune(name) || declaration2 !== null && // const state = $state(0) is valid
    (get_rune(declaration2.initial, instance.scope) === null || // rune-line names received as props are valid too (but we have to protect against $props as store)
    store_name !== "props" && get_rune(declaration2.initial, instance.scope) === "$props") && // allow `import { derived } from 'svelte/store'` in the same file as `const x = $derived(..)` because one is not a subscription to the other
    !(name === "$derived" && ((_a2 = declaration2.initial) == null ? void 0 : _a2.type) === "ImportDeclaration" && declaration2.initial.source.value === "svelte/store")) {
      let is_nested_store_subscription_node = void 0;
      search: for (const reference of references) {
        for (let i = reference.path.length - 1; i >= 0; i--) {
          const scope2 = scopes.get(reference.path[i]) || module.scopes.get(reference.path[i]) || instance.scopes.get(reference.path[i]);
          if (scope2) {
            const owner = scope2 == null ? void 0 : scope2.owner(store_name);
            if (!!owner && owner !== module.scope && owner !== instance.scope) {
              is_nested_store_subscription_node = reference.node;
              break search;
            }
            break;
          }
        }
      }
      if (is_nested_store_subscription_node) {
        store_invalid_scoped_subscription(is_nested_store_subscription_node);
      }
      if (options.runes !== false) {
        if (declaration2 === null && /[a-z]/.test(store_name[0])) {
          global_reference_invalid(references[0].node, name);
        } else if (declaration2 !== null && is_rune(name)) {
          for (const { node, path } of references) {
            if (((_b2 = path.at(-1)) == null ? void 0 : _b2.type) === "CallExpression") {
              store_rune_conflict(node, store_name);
            }
          }
        }
      }
      if (module.ast) {
        for (const { node, path } of references) {
          if (
            /** @type {number} */
            node.start > /** @type {number} */
            module.ast.start && /** @type {number} */
            node.end < /** @type {number} */
            module.ast.end && // const state = $state(0) is valid
            get_rune(
              /** @type {Node} */
              path.at(-1),
              module.scope
            ) === null
          ) {
            store_invalid_subscription(node);
          }
        }
      }
      const binding = instance.scope.declare(id(name), "store_sub", "synthetic");
      binding.references = references;
      instance.scope.references.set(name, references);
      module.scope.references.delete(name);
    }
  }
  const component_name = get_component_name(options.filename);
  const runes = options.runes ?? Array.from(module.scope.references.keys()).some(is_rune);
  if (runes && root.module) {
    const context = root.module.attributes.find((attribute) => attribute.name === "context");
    if (context) {
      script_context_deprecated(context);
    }
  }
  const analysis = {
    name: module.scope.generate(options.name ?? component_name),
    root: scope_root,
    module,
    instance,
    template: template3,
    elements: [],
    runes,
    immutable: runes || options.immutable,
    exports: [],
    uses_props: false,
    uses_rest_props: false,
    uses_slots: false,
    uses_component_bindings: false,
    uses_render_tags: false,
    needs_context: false,
    needs_props: false,
    event_directive_node: null,
    uses_event_attributes: false,
    custom_element: options.customElementOptions ?? options.customElement,
    inject_styles: options.css === "injected" || options.customElement,
    accessors: options.customElement ? true : (runes ? false : !!options.accessors) || // because $set method needs accessors
    ((_c = options.compatibility) == null ? void 0 : _c.componentApi) === 4,
    reactive_statements: /* @__PURE__ */ new Map(),
    binding_groups: /* @__PURE__ */ new Map(),
    slot_names: /* @__PURE__ */ new Map(),
    top_level_snippets: [],
    css: {
      ast: root.css,
      hash: root.css ? options.cssHash({
        css: root.css.content.styles,
        filename: options.filename,
        name: component_name,
        hash
      }) : "",
      keyframes: []
    },
    source: source2
  };
  if (!runes) {
    for (const node of instance.ast.body) {
      if (node.type !== "ExportNamedDeclaration") continue;
      analysis.needs_props = true;
      if (node.declaration) {
        if (node.declaration.type === "FunctionDeclaration" || node.declaration.type === "ClassDeclaration") {
          analysis.exports.push({
            name: (
              /** @type {import('estree').Identifier} */
              node.declaration.id.name
            ),
            alias: null
          });
        } else if (node.declaration.type === "VariableDeclaration") {
          if (node.declaration.kind === "const") {
            for (const declarator2 of node.declaration.declarations) {
              for (const node2 of extract_identifiers(declarator2.id)) {
                analysis.exports.push({ name: node2.name, alias: null });
              }
            }
          } else {
            for (const declarator2 of node.declaration.declarations) {
              for (const id2 of extract_identifiers(declarator2.id)) {
                const binding = (
                  /** @type {Binding} */
                  instance.scope.get(id2.name)
                );
                binding.kind = "bindable_prop";
              }
            }
          }
        }
      } else {
        for (const specifier of node.specifiers) {
          const binding = instance.scope.get(specifier.local.name);
          if (binding && (binding.declaration_kind === "var" || binding.declaration_kind === "let")) {
            binding.kind = "bindable_prop";
            if (specifier.exported.name !== specifier.local.name) {
              binding.prop_alias = specifier.exported.name;
            }
          } else {
            analysis.exports.push({ name: specifier.local.name, alias: specifier.exported.name });
          }
        }
      }
    }
    for (const binding of instance.scope.declarations.values()) {
      if (binding.kind !== "normal") continue;
      for (const { node, path } of binding.references) {
        if (node === binding.node) continue;
        if (binding.updated) {
          if (path[path.length - 1].type === "StyleDirective" || path.some((node2) => node2.type === "Fragment") || path[1].type === "LabeledStatement" && path[1].label.name === "$") {
            binding.kind = "state";
          }
        }
      }
    }
    walk(
      /** @type {SvelteNode} */
      template3.ast,
      null,
      {
        EachBlock(node) {
          const scope2 = (
            /** @type {Scope} */
            template3.scopes.get(node)
          );
          for (const binding of scope2.declarations.values()) {
            if (binding.updated) {
              const state = { scope: (
                /** @type {Scope} */
                scope2.parent
              ), scopes: template3.scopes };
              walk(node.expression, state, {
                // @ts-expect-error
                _: set_scope,
                Identifier(node2, context) {
                  const parent = (
                    /** @type {Expression} */
                    context.path.at(-1)
                  );
                  if (is_reference(node2, parent)) {
                    const binding2 = context.state.scope.get(node2.name);
                    if (binding2 && binding2.kind === "normal" && binding2.declaration_kind !== "import") {
                      binding2.kind = "state";
                      binding2.mutated = binding2.updated = true;
                    }
                  }
                }
              });
              break;
            }
          }
        }
      }
    );
  }
  if (root.options) {
    for (const attribute of root.options.attributes) {
      if (attribute.name === "accessors" && analysis.runes) {
        options_deprecated_accessors(attribute);
      }
      if (attribute.name === "customElement" && !options.customElement) {
        options_missing_custom_element(attribute);
      }
      if (attribute.name === "immutable" && analysis.runes) {
        options_deprecated_immutable(attribute);
      }
    }
  }
  if (analysis.runes) {
    const props_refs = module.scope.references.get("$$props");
    if (props_refs) {
      legacy_props_invalid(props_refs[0].node);
    }
    const rest_props_refs = module.scope.references.get("$$restProps");
    if (rest_props_refs) {
      legacy_rest_props_invalid(rest_props_refs[0].node);
    }
    for (const { ast, scope: scope2, scopes: scopes2 } of [module, instance, template3]) {
      const state = {
        scope: scope2,
        scopes: scopes2,
        analysis,
        options,
        ast_type: ast === instance.ast ? "instance" : ast === template3.ast ? "template" : "module",
        parent_element: null,
        has_props_rune: false,
        component_slots: /* @__PURE__ */ new Set(),
        expression: null,
        render_tag: null,
        private_derived_state: [],
        function_depth: scope2.function_depth,
        instance_scope: instance.scope,
        reactive_statement: null,
        reactive_statements: /* @__PURE__ */ new Map()
      };
      walk(
        /** @type {SvelteNode} */
        ast,
        state,
        visitors4
      );
    }
    for (const scope2 of [module.scope, instance.scope]) {
      outer: for (const [name, binding] of scope2.declarations) {
        if (binding.kind === "normal" && binding.reassigned) {
          inner: for (const { path } of binding.references) {
            if (path[0].type !== "Fragment") continue;
            for (let i = 1; i < path.length; i += 1) {
              const type = path[i].type;
              if (type === "FunctionDeclaration" || type === "FunctionExpression" || type === "ArrowFunctionExpression") {
                continue inner;
              }
              if (type === "BindDirective" && /** @type {AST.BindDirective} */
              path[i].name === "this") {
                for (let j = i - 1; j >= 0; j -= 1) {
                  const type2 = path[j].type;
                  if (type2 === "IfBlock" || type2 === "EachBlock" || type2 === "AwaitBlock" || type2 === "KeyBlock") {
                    non_reactive_update(binding.node, name);
                    continue outer;
                  }
                }
                continue inner;
              }
            }
            non_reactive_update(binding.node, name);
            continue outer;
          }
        }
      }
    }
  } else {
    instance.scope.declare(id("$$props"), "rest_prop", "synthetic");
    instance.scope.declare(id("$$restProps"), "rest_prop", "synthetic");
    for (const { ast, scope: scope2, scopes: scopes2 } of [module, instance, template3]) {
      const state = {
        scope: scope2,
        scopes: scopes2,
        analysis,
        options,
        parent_element: null,
        has_props_rune: false,
        ast_type: ast === instance.ast ? "instance" : ast === template3.ast ? "template" : "module",
        instance_scope: instance.scope,
        reactive_statement: null,
        reactive_statements: analysis.reactive_statements,
        component_slots: /* @__PURE__ */ new Set(),
        expression: null,
        render_tag: null,
        private_derived_state: [],
        function_depth: scope2.function_depth
      };
      walk(
        /** @type {SvelteNode} */
        ast,
        state,
        visitors4
      );
    }
    for (const [name, binding] of instance.scope.declarations) {
      if ((binding.kind === "prop" || binding.kind === "bindable_prop") && binding.node.name !== "$$props") {
        const references = binding.references.filter(
          (r) => {
            var _a3;
            return r.node !== binding.node && ((_a3 = r.path.at(-1)) == null ? void 0 : _a3.type) !== "ExportSpecifier";
          }
        );
        if (!references.length && !instance.scope.declarations.has(`$${name}`)) {
          export_let_unused(binding.node, name);
        }
      }
    }
    analysis.reactive_statements = order_reactive_statements(analysis.reactive_statements);
  }
  if (analysis.event_directive_node && analysis.uses_event_attributes) {
    mixed_event_handler_syntaxes(
      analysis.event_directive_node,
      analysis.event_directive_node.name
    );
  }
  if (analysis.uses_render_tags && (analysis.uses_slots || !analysis.custom_element && analysis.slot_names.size > 0)) {
    const pos = analysis.slot_names.values().next().value ?? analysis.source.indexOf("$$slot");
    slot_snippet_conflict(pos);
  }
  if (analysis.css.ast) {
    analyze_css(analysis.css.ast, analysis);
    for (const element2 of analysis.elements) {
      prune(analysis.css.ast, element2);
    }
    const { comment } = analysis.css.ast.content;
    const should_ignore_unused = comment && extract_svelte_ignore(comment.start, comment.data, analysis.runes).includes(
      "css_unused_selector"
    );
    if (!should_ignore_unused) {
      warn_unused(analysis.css.ast);
    }
    outer: for (const element2 of analysis.elements) {
      if (element2.type === "RenderTag") continue;
      if (element2.metadata.scoped) {
        if (element2.type === "SvelteElement" && options.generate === "client") continue;
        let class_attribute = void 0;
        for (const attribute of element2.attributes) {
          if (attribute.type === "SpreadAttribute") {
            continue outer;
          }
          if (attribute.type !== "Attribute") continue;
          if (attribute.name.toLowerCase() !== "class") continue;
          class_attribute = attribute;
        }
        if (class_attribute && class_attribute.value !== true) {
          if (is_text_attribute(class_attribute)) {
            class_attribute.value[0].data += ` ${analysis.css.hash}`;
          } else {
            const css_text = {
              type: "Text",
              data: ` ${analysis.css.hash}`,
              raw: ` ${analysis.css.hash}`,
              start: -1,
              end: -1,
              parent: null
            };
            if (Array.isArray(class_attribute.value)) {
              class_attribute.value.push(css_text);
            } else {
              class_attribute.value = [class_attribute.value, css_text];
            }
          }
        } else {
          element2.attributes.push(
            create_attribute("class", -1, -1, [
              {
                type: "Text",
                data: analysis.css.hash,
                raw: analysis.css.hash,
                parent: null,
                start: -1,
                end: -1
              }
            ])
          );
          if (is_custom_element_node(element2) && element2.attributes.length === 1) {
            mark_subtree_dynamic(element2.metadata.path);
          }
        }
      }
    }
  }
  return analysis;
}
function order_reactive_statements(unsorted_reactive_declarations) {
  const lookup = /* @__PURE__ */ new Map();
  for (const [node, declaration2] of unsorted_reactive_declarations) {
    for (const binding of declaration2.assignments) {
      const statements = lookup.get(binding.node.name) ?? [];
      statements.push([node, declaration2]);
      lookup.set(binding.node.name, statements);
    }
  }
  const edges = [];
  for (const [, { assignments, dependencies }] of unsorted_reactive_declarations) {
    for (const assignment2 of assignments) {
      for (const dependency of dependencies) {
        if (!assignments.has(dependency)) {
          edges.push([assignment2.node.name, dependency.node.name]);
        }
      }
    }
  }
  const cycle = check_graph_for_cycles(edges);
  if (cycle == null ? void 0 : cycle.length) {
    const declaration2 = (
      /** @type {Tuple[]} */
      lookup.get(cycle[0])[0]
    );
    reactive_declaration_cycle(declaration2[0], cycle.join(" → "));
  }
  const reactive_declarations = /* @__PURE__ */ new Map();
  const add_declaration = (node, declaration2) => {
    if ([...reactive_declarations.values()].includes(declaration2)) return;
    for (const binding of declaration2.dependencies) {
      if (declaration2.assignments.has(binding)) continue;
      for (const [node2, earlier] of lookup.get(binding.node.name) ?? []) {
        add_declaration(node2, earlier);
      }
    }
    reactive_declarations.set(node, declaration2);
  };
  for (const [node, declaration2] of unsorted_reactive_declarations) {
    add_declaration(node, declaration2);
  }
  return reactive_declarations;
}

// node_modules/svelte/src/compiler/utils/mapped_code.js
var import_remapping = __toESM(require_remapping_umd(), 1);

// node_modules/svelte/src/compiler/utils/push_array.js
function push_array(array2, items) {
  for (let i = 0; i < items.length; i++) {
    array2.push(items[i]);
  }
}

// node_modules/svelte/src/compiler/utils/mapped_code.js
function last_line_length(s) {
  return s.length - s.lastIndexOf("\n") - 1;
}
function sourcemap_add_offset(map, offset, source_index) {
  if (map.mappings.length == 0) return;
  for (let line = 0; line < map.mappings.length; line++) {
    const segment_list = map.mappings[line];
    for (let segment = 0; segment < segment_list.length; segment++) {
      const seg = segment_list[segment];
      if (seg[1] === source_index) {
        if (seg[2] === 0) {
          seg[3] += offset.column;
        }
        seg[2] += offset.line;
      }
    }
  }
}
function merge_tables(this_table, other_table) {
  const new_table = this_table.slice();
  const idx_map = [];
  other_table = other_table || [];
  let val_changed = false;
  for (const [other_idx, other_val] of other_table.entries()) {
    const this_idx = this_table.indexOf(other_val);
    if (this_idx >= 0) {
      idx_map[other_idx] = this_idx;
    } else {
      const new_idx = new_table.length;
      new_table[new_idx] = other_val;
      idx_map[other_idx] = new_idx;
      val_changed = true;
    }
  }
  let idx_changed = val_changed;
  if (val_changed) {
    if (idx_map.find((val, idx) => val != idx) === void 0) {
      idx_changed = false;
    }
  }
  return [new_table, idx_map, val_changed, idx_changed];
}
var regex_line_token = /([^\w\s]|\s+)/g;
var MappedCode = class _MappedCode {
  /**
   * @param {string} string
   * @param {DecodedSourceMap | null} map
   */
  constructor(string2 = "", map = null) {
    /**
     * @type {string}
     */
    __publicField(this, "string");
    /**
     * @type {DecodedSourceMap}
     */
    __publicField(this, "map");
    this.string = string2;
    if (map) {
      this.map = map;
    } else {
      this.map = {
        version: 3,
        mappings: [],
        sources: [],
        names: []
      };
    }
  }
  /**
   * concat in-place (mutable), return this (chainable)
   * will also mutate the `other` object
   * @param {MappedCode} other
   * @returns {MappedCode}
   */
  concat(other) {
    if (other.string == "") return this;
    if (this.string == "") {
      this.string = other.string;
      this.map = other.map;
      return this;
    }
    const column_offset = last_line_length(this.string);
    this.string += other.string;
    const m1 = this.map;
    const m2 = other.map;
    if (m2.mappings.length == 0) return this;
    const [sources, new_source_idx, sources_changed, sources_idx_changed] = merge_tables(
      m1.sources,
      m2.sources
    );
    const [names, new_name_idx, names_changed, names_idx_changed] = merge_tables(
      m1.names,
      m2.names
    );
    if (sources_changed) m1.sources = sources;
    if (names_changed) m1.names = names;
    if (sources_idx_changed && names_idx_changed) {
      for (let line = 0; line < m2.mappings.length; line++) {
        const segment_list = m2.mappings[line];
        for (let segment = 0; segment < segment_list.length; segment++) {
          const seg = segment_list[segment];
          if (seg[1] >= 0) seg[1] = new_source_idx[seg[1]];
          if (seg[4] >= 0) seg[4] = new_name_idx[seg[4]];
        }
      }
    } else if (sources_idx_changed) {
      for (let line = 0; line < m2.mappings.length; line++) {
        const segment_list = m2.mappings[line];
        for (let segment = 0; segment < segment_list.length; segment++) {
          const seg = segment_list[segment];
          if (seg[1] >= 0) seg[1] = new_source_idx[seg[1]];
        }
      }
    } else if (names_idx_changed) {
      for (let line = 0; line < m2.mappings.length; line++) {
        const segment_list = m2.mappings[line];
        for (let segment = 0; segment < segment_list.length; segment++) {
          const seg = segment_list[segment];
          if (seg[4] >= 0) seg[4] = new_name_idx[seg[4]];
        }
      }
    }
    if (m2.mappings.length > 0 && column_offset > 0) {
      const first_line = m2.mappings[0];
      for (let i = 0; i < first_line.length; i++) {
        first_line[i][0] += column_offset;
      }
    }
    push_array(
      m1.mappings[m1.mappings.length - 1],
      /** @type {SourceMapSegment[]} */
      m2.mappings.shift()
    );
    push_array(m1.mappings, m2.mappings);
    return this;
  }
  /**
   * @static
   * @param {string} string
   * @param {DecodedSourceMap} [map]
   * @returns {MappedCode}
   */
  static from_processed(string2, map) {
    const line_count = string2.split("\n").length;
    if (map) {
      const missing_lines = line_count - map.mappings.length;
      for (let i = 0; i < missing_lines; i++) {
        map.mappings.push([]);
      }
      return new _MappedCode(string2, map);
    }
    if (string2 == "") return new _MappedCode();
    map = { version: 3, names: [], sources: [], mappings: [] };
    for (let i = 0; i < line_count; i++) map.mappings.push([]);
    return new _MappedCode(string2, map);
  }
  /**
   * @static
   * @param {Source} opts
   * @returns {MappedCode}
   */
  static from_source({ source: source2, file_basename, get_location }) {
    let offset = get_location(0);
    if (!offset) offset = { line: 0, column: 0 };
    const map = { version: 3, names: [], sources: [file_basename], mappings: [] };
    if (source2 == "") return new _MappedCode(source2, map);
    const line_list = source2.split("\n");
    for (let line = 0; line < line_list.length; line++) {
      map.mappings.push([]);
      const token_list = line_list[line].split(regex_line_token);
      for (let token = 0, column = 0; token < token_list.length; token++) {
        if (token_list[token] == "") continue;
        map.mappings[line].push([column, 0, offset.line + line, column]);
        column += token_list[token].length;
      }
    }
    const segment_list = map.mappings[0];
    for (let segment = 0; segment < segment_list.length; segment++) {
      segment_list[segment][3] += offset.column;
    }
    return new _MappedCode(source2, map);
  }
};
var b64enc = typeof window !== "undefined" && typeof btoa === "function" ? (
  /** @param {string} str */
  (str) => btoa(unescape(encodeURIComponent(str)))
) : (
  /** @param {string} str */
  (str) => Buffer.from(str).toString("base64")
);
var b64dec = typeof window !== "undefined" && typeof atob === "function" ? atob : (
  /** @param {any} a */
  (a) => Buffer.from(a, "base64").toString()
);
function combine_sourcemaps(filename2, sourcemap_list) {
  if (sourcemap_list.length == 0) return null;
  let map_idx = 1;
  const map = sourcemap_list.slice(0, -1).find((m) => m.sources.length !== 1) === void 0 ? (0, import_remapping.default)(
    // use array interface
    // only the oldest sourcemap can have multiple sources
    sourcemap_list,
    () => null,
    true
    // skip optional field `sourcesContent`
  ) : (0, import_remapping.default)(
    // use loader interface
    sourcemap_list[0],
    // last map
    (sourcefile) => {
      if (sourcefile === filename2 && sourcemap_list[map_idx]) {
        return sourcemap_list[map_idx++];
      } else {
        return null;
      }
    },
    true
  );
  if (!map.file) delete map.file;
  if (!map.sources.length) map.sources = [filename2];
  return map;
}
function apply_preprocessor_sourcemap(filename2, svelte_map, preprocessor_map_input) {
  if (!svelte_map || !preprocessor_map_input) return svelte_map;
  const preprocessor_map = typeof preprocessor_map_input === "string" ? JSON.parse(preprocessor_map_input) : preprocessor_map_input;
  const result_map = combine_sourcemaps(filename2, [svelte_map, preprocessor_map]);
  Object.defineProperties(result_map, {
    toString: {
      enumerable: false,
      value: function toString() {
        return JSON.stringify(this);
      }
    },
    toUrl: {
      enumerable: false,
      value: function toUrl() {
        return "data:application/json;charset=utf-8;base64," + b64enc(this.toString());
      }
    }
  });
  return (
    /** @type {any} */
    result_map
  );
}
var regex_data_uri = /data:(?:application|text)\/json;(?:charset[:=]\S+?;)?base64,(\S*)/;
function parse_attached_sourcemap(processed, tag_name) {
  const r_in = "[#@]\\s*sourceMappingURL\\s*=\\s*(\\S*)";
  const regex = tag_name == "script" ? new RegExp("(?://" + r_in + ")|(?:/\\*" + r_in + "\\s*\\*/)$") : new RegExp("/\\*" + r_in + "\\s*\\*/$");
  function log_warning(message) {
    const code_start = processed.code.length < 100 ? processed.code : processed.code.slice(0, 100) + " [...]";
    console.warn(`warning: ${message}. processed.code = ${JSON.stringify(code_start)}`);
  }
  processed.code = processed.code.replace(regex, (_, match1, match2) => {
    const map_url = tag_name == "script" ? match1 || match2 : match1;
    const map_data = (map_url.match(regex_data_uri) || [])[1];
    if (map_data) {
      if (processed.map) {
        log_warning(
          "Not implemented. Found sourcemap in both processed.code and processed.map. Please update your preprocessor to return only one sourcemap."
        );
        return "";
      }
      processed.map = b64dec(map_data);
      return "";
    }
    if (!processed.map) {
      log_warning(
        `Found sourcemap path ${JSON.stringify(
          map_url
        )} in processed.code, but no sourcemap data. Please update your preprocessor to return sourcemap data directly.`
      );
    }
    return "";
  });
}
function merge_with_preprocessor_map(result, options, source_name) {
  if (options.sourcemap) {
    const file_basename = get_basename(options.filename);
    result.map.sources = [file_basename];
    result.map = apply_preprocessor_sourcemap(
      file_basename,
      result.map,
      /** @type {any} */
      options.sourcemap
    );
    if (file_basename !== source_name) {
      result.map.sources = result.map.sources.map(
        /** @param {string} source */
        (source2) => get_relative_path(source_name, source2)
      );
    }
  }
}
function get_relative_path(from, to) {
  const from_parts = from.split(/[/\\]/);
  const to_parts = to.split(/[/\\]/);
  from_parts.pop();
  while (from_parts[0] === to_parts[0]) {
    from_parts.shift();
    to_parts.shift();
  }
  if (from_parts.length) {
    let i = from_parts.length;
    while (i--) from_parts[i] = "..";
  }
  return from_parts.concat(to_parts).join("/");
}
function get_basename(filename2) {
  return (
    /** @type {string} */
    filename2.split(/[/\\]/).pop()
  );
}
function get_source_name(filename2, output_filename, fallback) {
  return output_filename ? get_relative_path(output_filename, filename2) : get_basename(filename2);
}

// node_modules/svelte/src/compiler/phases/3-transform/css/index.js
function render_stylesheet(source2, analysis, options) {
  const code = new MagicString(source2);
  const state = {
    code,
    hash: analysis.css.hash,
    minify: analysis.inject_styles && !options.dev,
    selector: `.${analysis.css.hash}`,
    keyframes: analysis.css.keyframes,
    specificity: {
      bumped: false
    }
  };
  const ast = (
    /** @type {Css.StyleSheet} */
    analysis.css.ast
  );
  walk(
    /** @type {Css.Node} */
    ast,
    state,
    visitors5
  );
  code.remove(0, ast.content.start);
  code.remove(
    /** @type {number} */
    ast.content.end,
    source2.length
  );
  if (state.minify) {
    remove_preceding_whitespace(ast.content.end, state);
  }
  const css = {
    code: code.toString(),
    map: code.generateMap({
      // include source content; makes it easier/more robust looking up the source map code
      includeContent: true,
      // generateMap takes care of calculating source relative to file
      source: options.filename,
      file: options.cssOutputFilename || options.filename
    })
  };
  merge_with_preprocessor_map(css, options, css.map.sources[0]);
  if (dev && options.css === "injected" && css.code) {
    css.code += `
/*# sourceMappingURL=${css.map.toUrl()} */`;
  }
  return css;
}
var visitors5 = {
  _: (node, context) => {
    context.state.code.addSourcemapLocation(node.start);
    context.state.code.addSourcemapLocation(node.end);
    context.next();
  },
  Atrule(node, { state, next: next2 }) {
    if (is_keyframes_node(node)) {
      let start = node.start + node.name.length + 1;
      while (state.code.original[start] === " ") start += 1;
      let end = start;
      while (state.code.original[end] !== "{" && state.code.original[end] !== " ") end += 1;
      if (node.prelude.startsWith("-global-")) {
        state.code.remove(start, start + 8);
      } else {
        state.code.prependRight(start, `${state.hash}-`);
      }
      return;
    }
    next2();
  },
  Declaration(node, { state }) {
    const property = node.property && remove_css_prefix(node.property.toLowerCase());
    if (property === "animation" || property === "animation-name") {
      let index = node.start + node.property.length + 1;
      let name = "";
      while (index < state.code.original.length) {
        const character = state.code.original[index];
        if (regex_css_name_boundary.test(character)) {
          if (state.keyframes.includes(name)) {
            state.code.prependRight(index - name.length, `${state.hash}-`);
          }
          if (character === ";" || character === "}") {
            break;
          }
          name = "";
        } else {
          name += character;
        }
        index++;
      }
    } else if (state.minify) {
      remove_preceding_whitespace(node.start, state);
      if (!node.property.startsWith("--")) {
        let start = node.start + node.property.length + 1;
        let end = start;
        while (/\s/.test(state.code.original[end])) end++;
        if (end > start) state.code.remove(start, end);
      }
    }
  },
  Rule(node, { state, next: next2, visit }) {
    if (state.minify) {
      remove_preceding_whitespace(node.start, state);
      remove_preceding_whitespace(node.block.end - 1, state);
    }
    if (!dev && is_empty(node)) {
      if (state.minify) {
        state.code.remove(node.start, node.end);
      } else {
        state.code.prependRight(node.start, "/* (empty) ");
        state.code.appendLeft(node.end, "*/");
        escape_comment_close(node, state.code);
      }
      return;
    }
    if (!is_used(node)) {
      if (state.minify) {
        state.code.remove(node.start, node.end);
      } else {
        state.code.prependRight(node.start, "/* (unused) ");
        state.code.appendLeft(node.end, "*/");
        escape_comment_close(node, state.code);
      }
      return;
    }
    if (node.metadata.is_global_block) {
      const selector = node.prelude.children[0];
      if (selector.children.length === 1 && selector.children[0].selectors.length === 1) {
        if (state.minify) {
          state.code.remove(node.start, node.block.start + 1);
          state.code.remove(node.block.end - 1, node.end);
        } else {
          state.code.prependRight(node.start, "/* ");
          state.code.appendLeft(node.block.start + 1, "*/");
          state.code.prependRight(node.block.end - 1, "/*");
          state.code.appendLeft(node.block.end, "*/");
        }
        return;
      }
      visit(node.prelude);
      return;
    }
    next2();
  },
  SelectorList(node, { state, next: next2, path }) {
    if (!path.find((n) => n.type === "ComplexSelector" && !n.metadata.used)) {
      const children = node.children;
      let pruning = false;
      let prune_start = children[0].start;
      let last = prune_start;
      for (let i = 0; i < children.length; i += 1) {
        const selector = children[i];
        if (selector.metadata.used === pruning) {
          if (pruning) {
            let i2 = selector.start;
            while (state.code.original[i2] !== ",") i2--;
            if (state.minify) {
              state.code.remove(prune_start, i2 + 1);
            } else {
              state.code.overwrite(i2, i2 + 1, "*/");
            }
          } else {
            if (i === 0) {
              if (state.minify) {
                prune_start = selector.start;
              } else {
                state.code.prependRight(selector.start, "/* (unused) ");
              }
            } else {
              const separator = i !== children.length - 1 ? "," : "";
              if (state.minify) {
                prune_start = last;
                if (separator) {
                  while (state.code.original[prune_start - 1] !== ",") prune_start++;
                  state.code.update(last, prune_start, separator);
                }
              } else {
                state.code.overwrite(last, selector.start, `${separator} /* (unused) `);
              }
            }
          }
          pruning = !pruning;
        }
        last = selector.end;
      }
      if (pruning) {
        if (state.minify) {
          state.code.remove(prune_start, last);
        } else {
          state.code.appendLeft(last, "*/");
        }
      }
    }
    let specificity = state.specificity;
    let parent = path.at(-1);
    if ((parent == null ? void 0 : parent.type) === "Rule") {
      specificity = { bumped: false };
      let rule = parent.metadata.parent_rule;
      while (rule) {
        if (rule.metadata.has_local_selectors) {
          specificity = { bumped: true };
          break;
        }
        rule = rule.metadata.parent_rule;
      }
    }
    next2({ ...state, specificity });
  },
  ComplexSelector(node, context) {
    var _a2;
    const before_bumped = context.state.specificity.bumped;
    function remove_global_pseudo_class(selector, combinator) {
      if (selector.args === null) {
        let start = selector.start;
        if ((combinator == null ? void 0 : combinator.name) === " ") {
          while (/\s/.test(context.state.code.original[start - 1])) start--;
        }
        context.state.code.remove(start, selector.start + ":global".length);
      } else {
        context.state.code.remove(selector.start, selector.start + ":global(".length).remove(selector.end - 1, selector.end);
      }
    }
    for (const relative_selector of node.children) {
      if (relative_selector.metadata.is_global) {
        const global = (
          /** @type {Css.PseudoClassSelector} */
          relative_selector.selectors[0]
        );
        remove_global_pseudo_class(global, relative_selector.combinator);
        if (((_a2 = node.metadata.rule) == null ? void 0 : _a2.metadata.parent_rule) && global.args === null && relative_selector.combinator === null) {
          context.state.code.prependRight(global.start, "&");
        }
        continue;
      }
      if (relative_selector.metadata.scoped) {
        if (relative_selector.selectors.length === 1) {
          const selector = relative_selector.selectors[0];
          if (selector.type === "PseudoClassSelector" && (selector.name === "is" || selector.name === "where")) {
            continue;
          }
        }
        for (const selector of relative_selector.selectors) {
          if (selector.type === "PseudoClassSelector" && selector.name === "global") {
            remove_global_pseudo_class(selector, null);
          }
        }
        if (relative_selector.selectors.some((s) => s.type === "NestingSelector")) {
          continue;
        }
        let modifier = context.state.selector;
        if (context.state.specificity.bumped) modifier = `:where(${modifier})`;
        context.state.specificity.bumped = true;
        let i = relative_selector.selectors.length;
        while (i--) {
          const selector = relative_selector.selectors[i];
          if (selector.type === "PseudoElementSelector" || selector.type === "PseudoClassSelector") {
            if (selector.name !== "root" && selector.name !== "host") {
              if (i === 0) context.state.code.prependRight(selector.start, modifier);
            }
            continue;
          }
          if (selector.type === "TypeSelector" && selector.name === "*") {
            context.state.code.update(selector.start, selector.end, modifier);
          } else {
            context.state.code.appendLeft(selector.end, modifier);
          }
          break;
        }
      }
    }
    context.next();
    context.state.specificity.bumped = before_bumped;
  },
  PseudoClassSelector(node, context) {
    if (node.name === "is" || node.name === "where" || node.name === "has" || node.name === "not") {
      context.next();
    }
  }
};
function remove_preceding_whitespace(end, state) {
  let start = end;
  while (/\s/.test(state.code.original[start - 1])) start--;
  if (start < end) state.code.remove(start, end);
}
function is_empty(rule) {
  if (rule.metadata.is_global_block) {
    return rule.block.children.length === 0;
  }
  for (const child of rule.block.children) {
    if (child.type === "Declaration") {
      return false;
    }
    if (child.type === "Rule") {
      if (is_used(child) && !is_empty(child)) return false;
    }
    if (child.type === "Atrule") {
      if (child.block === null || child.block.children.length > 0) return false;
    }
  }
  return true;
}
function is_used(rule) {
  return rule.prelude.children.some((selector) => selector.metadata.used);
}
function escape_comment_close(node, code) {
  let escaped = false;
  let in_comment = false;
  for (let i = node.start; i < node.end; i++) {
    if (escaped) {
      escaped = false;
    } else {
      const char = code.original[i];
      if (in_comment) {
        if (char === "*" && code.original[i + 1] === "/") {
          code.prependRight(++i, "\\");
          in_comment = false;
        }
      } else if (char === "\\") {
        escaped = true;
      } else if (char === "/" && code.original[++i] === "*") {
        in_comment = true;
      }
    }
  }
}

// node_modules/svelte/src/compiler/phases/3-transform/shared/assignments.js
function visit_assignment_expression(node, context, build_assignment3) {
  if (node.left.type === "ArrayPattern" || node.left.type === "ObjectPattern" || node.left.type === "RestElement") {
    const value = (
      /** @type {Expression} */
      context.visit(node.right)
    );
    const should_cache = value.type !== "Identifier";
    const rhs = should_cache ? id("$$value") : value;
    let changed = false;
    const assignments = extract_paths(node.left).map((path) => {
      var _a2;
      const value2 = (_a2 = path.expression) == null ? void 0 : _a2.call(path, rhs);
      let assignment2 = build_assignment3("=", path.node, value2, context);
      if (assignment2 !== null) changed = true;
      return assignment2 ?? assignment(
        "=",
        /** @type {Pattern} */
        context.visit(path.node),
        /** @type {Expression} */
        context.visit(value2)
      );
    });
    if (!changed) {
      return null;
    }
    const is_standalone = (
      /** @type {Node} */
      context.path.at(-1).type.endsWith("Statement")
    );
    const sequence2 = sequence(assignments);
    if (!is_standalone) {
      sequence2.expressions.push(rhs);
    }
    if (should_cache) {
      const iife = arrow([rhs], sequence2);
      const iife_is_async = is_expression_async(value) || assignments.some((assignment2) => is_expression_async(assignment2));
      return iife_is_async ? await_builder(call(async(iife), value)) : call(iife, value);
    }
    return sequence2;
  }
  if (node.left.type !== "Identifier" && node.left.type !== "MemberExpression") {
    throw new Error(`Unexpected assignment type ${node.left.type}`);
  }
  return build_assignment3(node.operator, node.left, node.right, context);
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/AssignmentExpression.js
function AssignmentExpression2(node, context) {
  return visit_assignment_expression(node, context, build_assignment) ?? context.next();
}
function build_assignment(operator, left, right, context) {
  let object4 = left;
  while (object4.type === "MemberExpression") {
    object4 = object4.object;
  }
  if (object4.type !== "Identifier" || !is_store_name(object4.name)) {
    return null;
  }
  const name = object4.name.slice(1);
  if (!context.state.scope.get(name)) {
    return null;
  }
  if (object4 === left) {
    let value = (
      /** @type {Expression} */
      context.visit(build_assignment_value(operator, left, right))
    );
    return call("$.store_set", id(name), value);
  }
  return call(
    "$.store_mutate",
    assignment("??=", id("$$store_subs"), object([])),
    literal(object4.name),
    id(name),
    assignment(
      operator,
      /** @type {Pattern} */
      context.visit(left),
      /** @type {Expression} */
      context.visit(right)
    )
  );
}
function is_store_name(name) {
  return name[0] === "$" && /[A-Za-z_]/.test(name[1]);
}

// node_modules/svelte/src/escaping.js
var ATTR_REGEX = /[&"<]/g;
var CONTENT_REGEX = /[&<]/g;
function escape_html(value, is_attr) {
  const str = String(value ?? "");
  const pattern = is_attr ? ATTR_REGEX : CONTENT_REGEX;
  pattern.lastIndex = 0;
  let escaped = "";
  let last = 0;
  while (pattern.test(str)) {
    const i = pattern.lastIndex - 1;
    const ch = str[i];
    escaped += str.substring(last, i) + (ch === "&" ? "&amp;" : ch === '"' ? "&quot;" : "&lt;");
    last = i + 1;
  }
  return escaped + str.substring(last);
}

// node_modules/svelte/src/internal/server/hydration.js
var BLOCK_OPEN = `<!--${HYDRATION_START}-->`;
var BLOCK_OPEN_ELSE = `<!--${HYDRATION_START_ELSE}-->`;
var BLOCK_CLOSE = `<!--${HYDRATION_END}-->`;
var EMPTY_COMMENT = `<!---->`;

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/shared/utils.js
var block_open = literal(BLOCK_OPEN);
var block_close = literal(BLOCK_CLOSE);
var empty_comment = literal(EMPTY_COMMENT);
function process_children(nodes, { visit, state }) {
  let sequence2 = [];
  function flush() {
    let quasi2 = quasi("", false);
    const quasis = [quasi2];
    const expressions = [];
    for (let i = 0; i < sequence2.length; i++) {
      const node = sequence2[i];
      if (node.type === "Text" || node.type === "Comment") {
        quasi2.value.cooked += node.type === "Comment" ? `<!--${node.data}-->` : escape_html(node.data);
      } else if (node.type === "ExpressionTag" && node.expression.type === "Literal") {
        if (node.expression.value != null) {
          quasi2.value.cooked += escape_html(node.expression.value + "");
        }
      } else {
        expressions.push(call(
          "$.escape",
          /** @type {Expression} */
          visit(node.expression)
        ));
        quasi2 = quasi("", i + 1 === sequence2.length);
        quasis.push(quasi2);
      }
    }
    for (const quasi3 of quasis) {
      quasi3.value.raw = sanitize_template_string(
        /** @type {string} */
        quasi3.value.cooked
      );
    }
    state.template.push(template(quasis, expressions));
  }
  for (let i = 0; i < nodes.length; i += 1) {
    const node = nodes[i];
    if (node.type === "Text" || node.type === "Comment" || node.type === "ExpressionTag") {
      sequence2.push(node);
    } else {
      if (sequence2.length > 0) {
        flush();
        sequence2 = [];
      }
      visit(node, { ...state });
    }
  }
  if (sequence2.length > 0) {
    flush();
  }
}
function is_statement(node) {
  return node.type.endsWith("Statement") || node.type.endsWith("Declaration");
}
function build_template(template3, out = id("$$payload.out"), operator = "+=") {
  let strings = [];
  let expressions = [];
  const statements = [];
  const flush = () => {
    statements.push(
      stmt(
        assignment(
          operator,
          out,
          template(
            strings.map((cooked, i) => quasi(cooked, i === strings.length - 1)),
            expressions
          )
        )
      )
    );
    strings = [];
    expressions = [];
  };
  for (let i = 0; i < template3.length; i++) {
    const node = template3[i];
    if (is_statement(node)) {
      if (strings.length !== 0) {
        flush();
      }
      statements.push(node);
    } else {
      if (strings.length === 0) {
        strings.push("");
      }
      if (node.type === "Literal") {
        strings[strings.length - 1] += node.value;
      } else if (node.type === "TemplateLiteral") {
        strings[strings.length - 1] += node.quasis[0].value.cooked;
        strings.push(...node.quasis.slice(1).map((q) => (
          /** @type {string} */
          q.value.cooked
        )));
        expressions.push(...node.expressions);
      } else {
        expressions.push(node);
        strings.push("");
      }
    }
  }
  if (strings.length !== 0) {
    flush();
  }
  return statements;
}
function build_attribute_value(value, context, trim_whitespace = false, is_component = false) {
  if (value === true) {
    return true_instance;
  }
  if (!Array.isArray(value) || value.length === 1) {
    const chunk = Array.isArray(value) ? value[0] : value;
    if (chunk.type === "Text") {
      const data = trim_whitespace ? chunk.data.replace(regex_whitespaces_strict, " ").trim() : chunk.data;
      return literal(is_component ? data : escape_html(data, true));
    }
    return (
      /** @type {Expression} */
      context.visit(chunk.expression)
    );
  }
  let quasi2 = quasi("", false);
  const quasis = [quasi2];
  const expressions = [];
  for (let i = 0; i < value.length; i++) {
    const node = value[i];
    if (node.type === "Text") {
      quasi2.value.raw += trim_whitespace ? node.data.replace(regex_whitespaces_strict, " ") : node.data;
    } else {
      expressions.push(
        call(
          "$.stringify",
          /** @type {Expression} */
          context.visit(node.expression)
        )
      );
      quasi2 = quasi("", i + 1 === value.length);
      quasis.push(quasi2);
    }
  }
  return template(quasis, expressions);
}
function build_getter2(node, state) {
  const binding = state.scope.get(node.name);
  if (binding === null || node === binding.node) {
    return node;
  }
  if (binding.kind === "store_sub") {
    const store_id = id(node.name.slice(1));
    return call(
      "$.store_get",
      assignment("??=", id("$$store_subs"), object([])),
      literal(node.name),
      build_getter2(store_id, state)
    );
  }
  return node;
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/AwaitBlock.js
function AwaitBlock2(node, context) {
  context.state.template.push(
    empty_comment,
    stmt(
      call(
        "$.await",
        /** @type {Expression} */
        context.visit(node.expression),
        thunk(
          node.pending ? (
            /** @type {BlockStatement} */
            context.visit(node.pending)
          ) : block([])
        ),
        arrow(
          node.value ? [
            /** @type {Pattern} */
            context.visit(node.value)
          ] : [],
          node.then ? (
            /** @type {BlockStatement} */
            context.visit(node.then)
          ) : block([])
        ),
        arrow(
          node.error ? [
            /** @type {Pattern} */
            context.visit(node.error)
          ] : [],
          node.catch ? (
            /** @type {BlockStatement} */
            context.visit(node.catch)
          ) : block([])
        )
      )
    ),
    empty_comment
  );
}

// node_modules/svelte/src/compiler/phases/3-transform/utils.js
function is_hoisted_function(node) {
  var _a2;
  if (node.type === "ArrowFunctionExpression" || node.type === "FunctionExpression" || node.type === "FunctionDeclaration") {
    return ((_a2 = node.metadata) == null ? void 0 : _a2.hoisted) === true;
  }
  return false;
}
function sort_const_tags(nodes, state) {
  const other = [];
  const tags = /* @__PURE__ */ new Map();
  for (const node of nodes) {
    if (node.type === "ConstTag") {
      const declaration2 = node.declaration.declarations[0];
      const bindings = extract_identifiers(declaration2.id).map((id2) => {
        return (
          /** @type {Binding} */
          state.scope.get(id2.name)
        );
      });
      const deps = /* @__PURE__ */ new Set();
      walk(declaration2.init, state, {
        // @ts-expect-error don't know, don't care
        _: set_scope,
        Identifier(node2, context) {
          const parent = (
            /** @type {Expression} */
            context.path.at(-1)
          );
          if (is_reference(node2, parent)) {
            const binding = context.state.scope.get(node2.name);
            if (binding) deps.add(binding);
          }
        }
      });
      for (const binding of bindings) {
        tags.set(binding, { node, deps });
      }
    } else {
      other.push(node);
    }
  }
  if (tags.size === 0) {
    return nodes;
  }
  const edges = [];
  for (const [id2, tag2] of tags) {
    for (const dep of tag2.deps) {
      if (tags.has(dep)) {
        edges.push([id2, dep]);
      }
    }
  }
  const cycle = check_graph_for_cycles(edges);
  if (cycle == null ? void 0 : cycle.length) {
    const tag2 = (
      /** @type {Tag} */
      tags.get(cycle[0])
    );
    const_tag_cycle(tag2.node, cycle.map((binding) => binding.node.name).join(" → "));
  }
  const sorted = [];
  function add(tag2) {
    if (sorted.includes(tag2.node)) {
      return;
    }
    for (const dep of tag2.deps) {
      const dep_tag = tags.get(dep);
      if (dep_tag) add(dep_tag);
    }
    sorted.push(tag2.node);
  }
  for (const tag2 of tags.values()) {
    add(tag2);
  }
  return [...sorted, ...other];
}
function clean_nodes(parent, nodes, path, namespace = "html", state, preserve_whitespace, preserve_comments) {
  if (!state.analysis.runes) {
    nodes = sort_const_tags(nodes, state);
  }
  const hoisted = [];
  const regular = [];
  for (const node of nodes) {
    if (node.type === "Comment" && !preserve_comments) {
      continue;
    }
    if (node.type === "ConstTag" || node.type === "DebugTag" || node.type === "SvelteBody" || node.type === "SvelteWindow" || node.type === "SvelteDocument" || node.type === "SvelteHead" || node.type === "TitleElement" || node.type === "SnippetBlock") {
      hoisted.push(node);
    } else {
      regular.push(node);
    }
  }
  let trimmed = regular;
  if (!preserve_whitespace) {
    trimmed = [];
    let first2, last;
    while ((first2 = regular[0]) && first2.type === "Text" && !regex_not_whitespace.test(first2.data)) {
      regular.shift();
    }
    if ((first2 == null ? void 0 : first2.type) === "Text") {
      first2.raw = first2.raw.replace(regex_starts_with_whitespaces, "");
      first2.data = first2.data.replace(regex_starts_with_whitespaces, "");
    }
    while ((last = regular.at(-1)) && last.type === "Text" && !regex_not_whitespace.test(last.data)) {
      regular.pop();
    }
    if ((last == null ? void 0 : last.type) === "Text") {
      last.raw = last.raw.replace(regex_ends_with_whitespaces, "");
      last.data = last.data.replace(regex_ends_with_whitespaces, "");
    }
    const can_remove_entirely = namespace === "svg" && (parent.type !== "RegularElement" || parent.name !== "text") && !path.some((n) => n.type === "RegularElement" && n.name === "text") || parent.type === "RegularElement" && // TODO others?
    (parent.name === "select" || parent.name === "tr" || parent.name === "table" || parent.name === "tbody" || parent.name === "thead" || parent.name === "tfoot" || parent.name === "colgroup" || parent.name === "datalist");
    for (let i = 0; i < regular.length; i++) {
      const prev = regular[i - 1];
      const node = regular[i];
      const next2 = regular[i + 1];
      if (node.type === "Text") {
        if ((prev == null ? void 0 : prev.type) !== "ExpressionTag") {
          const prev_is_text_ending_with_whitespace = (prev == null ? void 0 : prev.type) === "Text" && regex_ends_with_whitespaces.test(prev.data);
          node.data = node.data.replace(
            regex_starts_with_whitespaces,
            prev_is_text_ending_with_whitespace ? "" : " "
          );
          node.raw = node.raw.replace(
            regex_starts_with_whitespaces,
            prev_is_text_ending_with_whitespace ? "" : " "
          );
        }
        if ((next2 == null ? void 0 : next2.type) !== "ExpressionTag") {
          node.data = node.data.replace(regex_ends_with_whitespaces, " ");
          node.raw = node.raw.replace(regex_ends_with_whitespaces, " ");
        }
        if (node.data && (node.data !== " " || !can_remove_entirely)) {
          trimmed.push(node);
        }
      } else {
        trimmed.push(node);
      }
    }
  }
  var first = trimmed[0];
  if (trimmed.length === 1 && first.type === "RegularElement" && first.name === "script") {
    trimmed.push({
      type: "Comment",
      data: "",
      parent: first.parent,
      start: -1,
      end: -1
    });
  }
  return {
    hoisted,
    trimmed,
    /**
     * In a case like `{#if x}<Foo />{/if}`, we don't need to wrap the child in
     * comments — we can just use the parent block's anchor for the component.
     * TODO extend this optimisation to other cases
     */
    is_standalone: trimmed.length === 1 && (first.type === "RenderTag" && !first.metadata.dynamic || first.type === "Component" && !state.options.hmr && !first.metadata.dynamic && !first.attributes.some(
      (attribute) => attribute.type === "Attribute" && attribute.name.startsWith("--")
    )),
    /** if a component/snippet/each block starts with text, we need to add an anchor comment so that its text node doesn't get fused with its surroundings */
    is_text_first: (parent.type === "Fragment" || parent.type === "SnippetBlock" || parent.type === "EachBlock" || parent.type === "SvelteComponent" || parent.type === "Component" || parent.type === "SvelteSelf") && first && ((first == null ? void 0 : first.type) === "Text" || (first == null ? void 0 : first.type) === "ExpressionTag")
  };
}
function infer_namespace(namespace, parent, nodes) {
  if (parent.type === "RegularElement" && parent.name === "foreignObject") {
    return "html";
  }
  if (parent.type === "RegularElement" || parent.type === "SvelteElement") {
    if (parent.metadata.svg) {
      return "svg";
    }
    return parent.metadata.mathml ? "mathml" : "html";
  }
  if (parent.type === "Fragment" || parent.type === "Root" || parent.type === "Component" || parent.type === "SvelteComponent" || parent.type === "SvelteFragment" || parent.type === "SnippetBlock" || parent.type === "SlotElement") {
    const new_namespace = check_nodes_for_namespace(nodes, "keep");
    if (new_namespace !== "keep" && new_namespace !== "maybe_html") {
      return new_namespace;
    }
  }
  return namespace;
}
function check_nodes_for_namespace(nodes, namespace) {
  const RegularElement4 = (node, { stop }) => {
    if (!node.metadata.svg && !node.metadata.mathml) {
      namespace = "html";
      stop();
    } else if (namespace === "keep") {
      namespace = node.metadata.svg ? "svg" : "mathml";
    }
  };
  for (const node of nodes) {
    walk(
      node,
      {},
      {
        _(node2, { next: next2 }) {
          if (node2.type === "EachBlock" || node2.type === "IfBlock" || node2.type === "AwaitBlock" || node2.type === "Fragment" || node2.type === "KeyBlock" || node2.type === "RegularElement" || node2.type === "SvelteElement" || node2.type === "Text") {
            next2();
          }
        },
        SvelteElement: RegularElement4,
        RegularElement: RegularElement4,
        Text(node2) {
          if (node2.data.trim() !== "") {
            namespace = "maybe_html";
          }
        }
      }
    );
    if (namespace === "html") return namespace;
  }
  return namespace;
}
function determine_namespace_for_children(node, namespace) {
  if (node.name === "foreignObject") {
    return "html";
  }
  if (node.metadata.svg) {
    return "svg";
  }
  return node.metadata.mathml ? "mathml" : "html";
}
function transform_inspect_rune(node, context) {
  const { state, visit } = context;
  const as_fn = state.options.generate === "client";
  if (!dev) return empty;
  if (node.callee.type === "MemberExpression") {
    const raw_inspect_args = (
      /** @type {CallExpression} */
      node.callee.object.arguments
    );
    const inspect_args = (
      /** @type {Array<Expression>} */
      raw_inspect_args.map((arg) => visit(arg))
    );
    const with_arg = (
      /** @type {Expression} */
      visit(node.arguments[0])
    );
    return call(
      "$.inspect",
      as_fn ? thunk(array(inspect_args)) : array(inspect_args),
      with_arg
    );
  } else {
    const arg = node.arguments.map((arg2) => (
      /** @type {Expression} */
      visit(arg2)
    ));
    return call("$.inspect", as_fn ? thunk(array(arg)) : array(arg));
  }
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/CallExpression.js
function CallExpression2(node, context) {
  const rune = get_rune(node, context.state.scope);
  if (rune === "$host") {
    return id("undefined");
  }
  if (rune === "$effect.tracking") {
    return literal(false);
  }
  if (rune === "$effect.root") {
    return arrow([], block([]));
  }
  if (rune === "$state.snapshot") {
    return call(
      "$.snapshot",
      /** @type {Expression} */
      context.visit(node.arguments[0]),
      is_ignored(node, "state_snapshot_uncloneable") && true_instance
    );
  }
  if (rune === "$inspect" || rune === "$inspect().with") {
    return transform_inspect_rune(node, context);
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/ClassBody.js
function ClassBody2(node, context) {
  var _a2, _b2;
  if (!context.state.analysis.runes) {
    context.next();
    return;
  }
  const public_derived = /* @__PURE__ */ new Map();
  const private_derived = /* @__PURE__ */ new Map();
  const private_ids = [];
  for (const definition of node.body) {
    if (definition.type === "PropertyDefinition" && (definition.key.type === "Identifier" || definition.key.type === "PrivateIdentifier")) {
      const { type, name } = definition.key;
      const is_private = type === "PrivateIdentifier";
      if (is_private) private_ids.push(name);
      if (((_a2 = definition.value) == null ? void 0 : _a2.type) === "CallExpression") {
        const rune = get_rune(definition.value, context.state.scope);
        if (rune === "$derived" || rune === "$derived.by") {
          const field = {
            kind: rune === "$derived.by" ? "derived_by" : "derived",
            // @ts-expect-error this is set in the next pass
            id: is_private ? definition.key : null
          };
          if (is_private) {
            private_derived.set(name, field);
          } else {
            public_derived.set(name, field);
          }
        }
      }
    }
  }
  for (const [name, field] of public_derived) {
    let deconflicted = name;
    while (private_ids.includes(deconflicted)) {
      deconflicted = "_" + deconflicted;
    }
    private_ids.push(deconflicted);
    field.id = private_id(deconflicted);
  }
  const body = [];
  const child_state = { ...context.state, private_derived };
  for (const definition of node.body) {
    if (definition.type === "PropertyDefinition" && (definition.key.type === "Identifier" || definition.key.type === "PrivateIdentifier")) {
      const name = definition.key.name;
      const is_private = definition.key.type === "PrivateIdentifier";
      const field = (is_private ? private_derived : public_derived).get(name);
      if (((_b2 = definition.value) == null ? void 0 : _b2.type) === "CallExpression" && field !== void 0) {
        const init2 = (
          /** @type {Expression} **/
          context.visit(definition.value.arguments[0], child_state)
        );
        const value = field.kind === "derived_by" ? call("$.once", init2) : call("$.once", thunk(init2));
        if (is_private) {
          body.push(prop_def(field.id, value));
        } else {
          const member2 = member(this_instance, field.id);
          body.push(prop_def(field.id, value));
          body.push(method("get", definition.key, [], [return_builder(call(member2))]));
          if (dev && (field.kind === "derived" || field.kind === "derived_by")) {
            body.push(
              method(
                "set",
                definition.key,
                [id("_")],
                [throw_error(`Cannot update a derived property ('${name}')`)]
              )
            );
          }
        }
        continue;
      }
    }
    body.push(
      /** @type {MethodDefinition} **/
      context.visit(definition, child_state)
    );
  }
  return { ...node, body };
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/shared/component.js
function build_inline_component(node, expression, context) {
  const props_and_spreads = [];
  const custom_css_props = [];
  const lets = { default: [] };
  const child_state = {
    ...context.state,
    scope: node.metadata.scopes.default
  };
  const children = {};
  const slot_scope_applies_to_itself = node.attributes.some(
    (node2) => node2.type === "Attribute" && node2.name === "slot"
  );
  let has_children_prop = false;
  function push_prop(prop2) {
    const current = props_and_spreads.at(-1);
    const current_is_props = Array.isArray(current);
    const props = current_is_props ? current : [];
    props.push(prop2);
    if (!current_is_props) {
      props_and_spreads.push(props);
    }
  }
  for (const attribute of node.attributes) {
    if (attribute.type === "LetDirective") {
      if (!slot_scope_applies_to_itself) {
        lets.default.push(attribute);
      }
    } else if (attribute.type === "SpreadAttribute") {
      props_and_spreads.push(
        /** @type {Expression} */
        context.visit(attribute)
      );
    } else if (attribute.type === "Attribute") {
      if (attribute.name.startsWith("--")) {
        const value2 = build_attribute_value(attribute.value, context, false, true);
        custom_css_props.push(init(attribute.name, value2));
        continue;
      }
      if (attribute.name === "children") {
        has_children_prop = true;
      }
      const value = build_attribute_value(attribute.value, context, false, true);
      push_prop(prop("init", key(attribute.name), value));
    } else if (attribute.type === "BindDirective" && attribute.name !== "this") {
      push_prop(
        get(attribute.name, [
          return_builder(
            /** @type {Expression} */
            context.visit(attribute.expression)
          )
        ])
      );
      push_prop(
        set(attribute.name, [
          stmt(
            /** @type {Expression} */
            context.visit(assignment("=", attribute.expression, id("$$value")))
          ),
          stmt(assignment("=", id("$$settled"), false_instance))
        ])
      );
    }
  }
  const snippet_declarations = [];
  const serialized_slots = [];
  for (const child of node.fragment.nodes) {
    if (child.type === "SnippetBlock") {
      context.visit(child, {
        ...context.state,
        init: snippet_declarations
      });
      push_prop(prop("init", child.expression, child.expression));
      serialized_slots.push(
        init(child.expression.name === "children" ? "default" : child.expression.name, true_instance)
      );
      continue;
    }
    let slot_name = "default";
    if (is_element_node(child)) {
      const slot = (
        /** @type {AST.Attribute | undefined} */
        child.attributes.find(
          (attribute) => attribute.type === "Attribute" && attribute.name === "slot"
        )
      );
      if (slot !== void 0) {
        slot_name = /** @type {AST.Text[]} */
        slot.value[0].data;
        lets[slot_name] = child.attributes.filter((attribute) => attribute.type === "LetDirective");
      } else if (child.type === "SvelteFragment") {
        lets.default.push(
          ...child.attributes.filter((attribute) => attribute.type === "LetDirective")
        );
      }
    }
    children[slot_name] = children[slot_name] || [];
    children[slot_name].push(child);
  }
  for (const slot_name of Object.keys(children)) {
    const block2 = (
      /** @type {BlockStatement} */
      context.visit(
        {
          ...node.fragment,
          // @ts-expect-error
          nodes: children[slot_name]
        },
        slot_name === "default" ? child_state : {
          ...context.state,
          scope: node.metadata.scopes[slot_name]
        }
      )
    );
    if (block2.body.length === 0) continue;
    const params = [id("$$payload")];
    if (lets[slot_name].length > 0) {
      const pattern = object_pattern(
        lets[slot_name].map((node2) => {
          if (node2.expression === null) {
            return init(node2.name, id(node2.name));
          }
          if (node2.expression.type === "ObjectExpression") {
            return init(node2.name, object_pattern(node2.expression.properties));
          }
          if (node2.expression.type === "ArrayExpression") {
            return init(node2.name, array_pattern(node2.expression.elements));
          }
          return init(node2.name, node2.expression);
        })
      );
      params.push(pattern);
    }
    const slot_fn = arrow(params, block(block2.body));
    if (slot_name === "default" && !has_children_prop) {
      if (lets.default.length === 0 && children.default.every(
        (node2) => node2.type !== "SvelteFragment" || !node2.attributes.some((attr) => attr.type === "LetDirective")
      )) {
        push_prop(prop("init", id("children"), slot_fn));
        serialized_slots.push(init(slot_name, true_instance));
      } else {
        serialized_slots.push(init(slot_name, slot_fn));
        push_prop(init("children", id("$.invalid_default_snippet")));
      }
    } else {
      serialized_slots.push(init(slot_name, slot_fn));
    }
  }
  if (serialized_slots.length > 0) {
    push_prop(prop("init", id("$$slots"), object(serialized_slots)));
  }
  const props_expression = props_and_spreads.length === 0 || props_and_spreads.length === 1 && Array.isArray(props_and_spreads[0]) ? object(
    /** @type {Property[]} */
    props_and_spreads[0] || []
  ) : call(
    "$.spread_props",
    array(props_and_spreads.map((p) => Array.isArray(p) ? object(p) : p))
  );
  let statement = stmt(
    (node.type === "SvelteComponent" ? maybe_call : call)(
      expression,
      id("$$payload"),
      props_expression
    )
  );
  if (snippet_declarations.length > 0) {
    statement = block([...snippet_declarations, statement]);
  }
  const dynamic = node.type === "SvelteComponent" || node.type === "Component" && node.metadata.dynamic;
  if (custom_css_props.length > 0) {
    context.state.template.push(
      stmt(
        call(
          "$.css_props",
          id("$$payload"),
          literal(context.state.namespace === "svg" ? false : true),
          object(custom_css_props),
          thunk(block([statement])),
          dynamic && true_instance
        )
      )
    );
  } else {
    if (dynamic) {
      context.state.template.push(empty_comment);
    }
    context.state.template.push(statement);
    if (!context.state.skip_hydration_boundaries) {
      context.state.template.push(empty_comment);
    }
  }
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/Component.js
function Component2(node, context) {
  build_inline_component(node, id(node.name), context);
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/ConstTag.js
function ConstTag2(node, context) {
  const declaration2 = node.declaration.declarations[0];
  const id2 = (
    /** @type {Pattern} */
    context.visit(declaration2.id)
  );
  const init2 = (
    /** @type {Expression} */
    context.visit(declaration2.init)
  );
  context.state.init.push(const_builder(id2, init2));
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/DebugTag.js
function DebugTag2(node, context) {
  context.state.template.push(
    stmt(
      call(
        "console.log",
        object(
          node.identifiers.map(
            (identifier) => prop(
              "init",
              identifier,
              /** @type {Expression} */
              context.visit(identifier)
            )
          )
        )
      )
    ),
    debugger_builder
  );
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/EachBlock.js
function EachBlock2(node, context) {
  const state = context.state;
  const each_node_meta = node.metadata;
  const collection = (
    /** @type {Expression} */
    context.visit(node.expression)
  );
  const index = each_node_meta.contains_group_binding || !node.index ? each_node_meta.index : id(node.index);
  const array_id = state.scope.root.unique("each_array");
  state.init.push(const_builder(array_id, call("$.ensure_array_like", collection)));
  const each = [let_builder(
    /** @type {Pattern} */
    node.context,
    member(array_id, index, true)
  )];
  if (index.name !== node.index && node.index != null) {
    each.push(let_builder(node.index, index));
  }
  each.push(.../** @type {BlockStatement} */
  context.visit(node.body).body);
  const for_loop = for_builder(
    declaration("let", [
      declarator(index, literal(0)),
      declarator("$$length", member(array_id, "length"))
    ]),
    binary("<", index, id("$$length")),
    update("++", index, false),
    block(each)
  );
  if (node.fallback) {
    const open2 = stmt(assignment("+=", id("$$payload.out"), block_open));
    const fallback = (
      /** @type {BlockStatement} */
      context.visit(node.fallback)
    );
    fallback.body.unshift(
      stmt(assignment("+=", id("$$payload.out"), literal(BLOCK_OPEN_ELSE)))
    );
    state.template.push(
      if_builder(
        binary("!==", member(array_id, "length"), literal(0)),
        block([open2, for_loop]),
        fallback
      ),
      block_close
    );
  } else {
    state.template.push(block_open, for_loop, block_close);
  }
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/ExpressionStatement.js
function ExpressionStatement2(node, context) {
  const rune = get_rune(node.expression, context.state.scope);
  if (rune === "$effect" || rune === "$effect.pre" || rune === "$effect.root") {
    return empty;
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/Fragment.js
function Fragment(node, context) {
  const parent = context.path.at(-1) ?? node;
  const namespace = infer_namespace(context.state.namespace, parent, node.nodes);
  const { hoisted, trimmed, is_standalone, is_text_first } = clean_nodes(
    parent,
    node.nodes,
    context.path,
    namespace,
    context.state,
    context.state.preserve_whitespace,
    context.state.options.preserveComments
  );
  const state = {
    ...context.state,
    init: [],
    template: [],
    namespace,
    skip_hydration_boundaries: is_standalone
  };
  for (const node2 of hoisted) {
    context.visit(node2, state);
  }
  if (is_text_first) {
    state.template.push(empty_comment);
  }
  process_children(trimmed, { ...context, state });
  return block([...state.init, ...build_template(state.template)]);
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/HtmlTag.js
function HtmlTag2(node, context) {
  const expression = (
    /** @type {Expression} */
    context.visit(node.expression)
  );
  context.state.template.push(call("$.html", expression));
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/Identifier.js
function Identifier2(node, context) {
  if (is_reference(
    node,
    /** @type {Node} */
    context.path.at(-1)
  )) {
    if (node.name === "$$props") {
      return id("$$sanitized_props");
    }
    return build_getter2(node, context.state);
  }
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/IfBlock.js
function IfBlock2(node, context) {
  const test = (
    /** @type {Expression} */
    context.visit(node.test)
  );
  const consequent = (
    /** @type {BlockStatement} */
    context.visit(node.consequent)
  );
  const alternate = node.alternate ? (
    /** @type {BlockStatement} */
    context.visit(node.alternate)
  ) : block([]);
  consequent.body.unshift(stmt(assignment("+=", id("$$payload.out"), block_open)));
  alternate.body.unshift(
    stmt(assignment("+=", id("$$payload.out"), literal(BLOCK_OPEN_ELSE)))
  );
  context.state.template.push(if_builder(test, consequent, alternate), block_close);
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/KeyBlock.js
function KeyBlock2(node, context) {
  context.state.template.push(
    empty_comment,
    /** @type {BlockStatement} */
    context.visit(node.fragment),
    empty_comment
  );
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/LabeledStatement.js
function LabeledStatement2(node, context) {
  if (context.state.analysis.runes || context.path.length > 1 || node.label.name !== "$") {
    return;
  }
  context.state.legacy_reactive_statements.set(
    node,
    // people could do "break $" inside, so we need to keep the label
    labeled(
      "$",
      /** @type {ExpressionStatement} */
      context.visit(node.body)
    )
  );
  return empty;
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/MemberExpression.js
function MemberExpression2(node, context) {
  if (context.state.analysis.runes && node.object.type === "ThisExpression" && node.property.type === "PrivateIdentifier") {
    const field = context.state.private_derived.get(node.property.name);
    if (field) {
      return call(node);
    }
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/PropertyDefinition.js
function PropertyDefinition(node, context) {
  if (context.state.analysis.runes && node.value != null && node.value.type === "CallExpression") {
    const rune = get_rune(node.value, context.state.scope);
    if (rune === "$state" || rune === "$state.raw" || rune === "$derived") {
      return {
        ...node,
        value: node.value.arguments.length === 0 ? null : (
          /** @type {Expression} */
          context.visit(node.value.arguments[0])
        )
      };
    }
    if (rune === "$derived.by") {
      return {
        ...node,
        value: node.value.arguments.length === 0 ? null : call(
          /** @type {Expression} */
          context.visit(node.value.arguments[0])
        )
      };
    }
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/shared/element.js
var WHITESPACE_INSENSITIVE_ATTRIBUTES = ["class", "style"];
function build_element_attributes(node, context) {
  const attributes = [];
  const class_directives = [];
  const style_directives = [];
  let content = null;
  let has_spread = false;
  let class_index = -1;
  let style_index = -1;
  let events_to_capture = /* @__PURE__ */ new Set();
  for (const attribute of node.attributes) {
    if (attribute.type === "Attribute") {
      if (attribute.name === "value") {
        if (node.name === "textarea") {
          if (attribute.value !== true && Array.isArray(attribute.value) && attribute.value[0].type === "Text" && regex_starts_with_newline.test(attribute.value[0].data)) {
            attribute.value[0].data = "\n" + attribute.value[0].data;
          }
          content = call("$.escape", build_attribute_value(attribute.value, context));
        } else if (node.name !== "select") {
          attributes.push(attribute);
        }
      } else if (is_event_attribute(attribute)) {
        if ((attribute.name === "onload" || attribute.name === "onerror") && is_load_error_element(node.name)) {
          events_to_capture.add(attribute.name);
        }
      } else {
        if (attribute.name === "class") {
          class_index = attributes.length;
        } else if (attribute.name === "style") {
          style_index = attributes.length;
        }
        attributes.push(attribute);
      }
    } else if (attribute.type === "BindDirective") {
      if (attribute.name === "value" && node.name === "select") continue;
      if (attribute.name === "value" && attributes.some(
        (attr) => attr.type === "Attribute" && attr.name === "type" && is_text_attribute(attr) && attr.value[0].data === "file"
      )) {
        continue;
      }
      if (attribute.name === "this") continue;
      const binding = binding_properties[attribute.name];
      if (binding == null ? void 0 : binding.omit_in_ssr) continue;
      if (is_content_editable_binding(attribute.name)) {
        content = /** @type {Expression} */
        context.visit(attribute.expression);
      } else if (attribute.name === "value" && node.name === "textarea") {
        content = call(
          "$.escape",
          /** @type {Expression} */
          context.visit(attribute.expression)
        );
      } else if (attribute.name === "group") {
        const value_attribute = (
          /** @type {AST.Attribute | undefined} */
          node.attributes.find((attr) => attr.type === "Attribute" && attr.name === "value")
        );
        if (!value_attribute) continue;
        const is_checkbox = node.attributes.some(
          (attr) => attr.type === "Attribute" && attr.name === "type" && is_text_attribute(attr) && attr.value[0].data === "checkbox"
        );
        attributes.push(
          create_attribute("checked", -1, -1, [
            {
              type: "ExpressionTag",
              start: -1,
              end: -1,
              parent: attribute,
              expression: is_checkbox ? call(
                member(attribute.expression, "includes"),
                build_attribute_value(value_attribute.value, context)
              ) : binary(
                "===",
                attribute.expression,
                build_attribute_value(value_attribute.value, context)
              ),
              metadata: {
                expression: create_expression_metadata()
              }
            }
          ])
        );
      } else {
        attributes.push(
          create_attribute(attribute.name, -1, -1, [
            {
              type: "ExpressionTag",
              start: -1,
              end: -1,
              parent: attribute,
              expression: attribute.expression,
              metadata: {
                expression: create_expression_metadata()
              }
            }
          ])
        );
      }
    } else if (attribute.type === "SpreadAttribute") {
      attributes.push(attribute);
      has_spread = true;
      if (is_load_error_element(node.name)) {
        events_to_capture.add("onload");
        events_to_capture.add("onerror");
      }
    } else if (attribute.type === "UseDirective") {
      if (is_load_error_element(node.name)) {
        events_to_capture.add("onload");
        events_to_capture.add("onerror");
      }
    } else if (attribute.type === "ClassDirective") {
      class_directives.push(attribute);
    } else if (attribute.type === "StyleDirective") {
      style_directives.push(attribute);
    } else if (attribute.type === "LetDirective") {
    } else {
      context.visit(attribute);
    }
  }
  if (class_directives.length > 0 && !has_spread) {
    const class_attribute = build_class_directives(
      class_directives,
      /** @type {AST.Attribute | null} */
      attributes[class_index] ?? null
    );
    if (class_index === -1) {
      attributes.push(class_attribute);
    }
  }
  if (style_directives.length > 0 && !has_spread) {
    build_style_directives(
      style_directives,
      /** @type {AST.Attribute | null} */
      attributes[style_index] ?? null,
      context
    );
    if (style_index > -1) {
      attributes.splice(style_index, 1);
    }
  }
  if (has_spread) {
    build_element_spread_attributes(node, attributes, style_directives, class_directives, context);
  } else {
    for (
      const attribute of
      /** @type {AST.Attribute[]} */
      attributes
    ) {
      if (attribute.value === true || is_text_attribute(attribute)) {
        const name2 = get_attribute_name(node, attribute);
        const literal_value = (
          /** @type {Literal} */
          build_attribute_value(
            attribute.value,
            context,
            WHITESPACE_INSENSITIVE_ATTRIBUTES.includes(name2)
          ).value
        );
        if (name2 !== "class" || literal_value) {
          context.state.template.push(
            literal(
              ` ${attribute.name}${is_boolean_attribute(name2) && literal_value === true ? "" : `="${literal_value === true ? "" : String(literal_value)}"`}`
            )
          );
        }
        continue;
      }
      const name = get_attribute_name(node, attribute);
      const value = build_attribute_value(
        attribute.value,
        context,
        WHITESPACE_INSENSITIVE_ATTRIBUTES.includes(name)
      );
      context.state.template.push(
        call("$.attr", literal(name), value, is_boolean_attribute(name) && true_instance)
      );
    }
  }
  if (events_to_capture.size !== 0) {
    for (const event of events_to_capture) {
      context.state.template.push(literal(` ${event}="this.__e=event"`));
    }
  }
  return content;
}
function get_attribute_name(element2, attribute) {
  let name = attribute.name;
  if (!element2.metadata.svg && !element2.metadata.mathml) {
    name = name.toLowerCase();
  }
  return name;
}
function build_element_spread_attributes(element2, attributes, style_directives, class_directives, context) {
  let classes;
  let styles;
  let flags = 0;
  if (class_directives.length > 0 || context.state.analysis.css.hash) {
    const properties = class_directives.map(
      (directive) => init(
        directive.name,
        directive.expression.type === "Identifier" && directive.expression.name === directive.name ? id(directive.name) : (
          /** @type {Expression} */
          context.visit(directive.expression)
        )
      )
    );
    if (context.state.analysis.css.hash) {
      properties.unshift(init(context.state.analysis.css.hash, literal(true)));
    }
    classes = object(properties);
  }
  if (style_directives.length > 0) {
    const properties = style_directives.map(
      (directive) => init(
        directive.name,
        directive.value === true ? id(directive.name) : build_attribute_value(directive.value, context, true)
      )
    );
    styles = object(properties);
  }
  if (element2.metadata.svg || element2.metadata.mathml) {
    flags |= ELEMENT_IS_NAMESPACED | ELEMENT_PRESERVE_ATTRIBUTE_CASE;
  } else if (is_custom_element_node(element2)) {
    flags |= ELEMENT_PRESERVE_ATTRIBUTE_CASE;
  }
  const object4 = object(
    attributes.map((attribute) => {
      if (attribute.type === "Attribute") {
        const name = get_attribute_name(element2, attribute);
        const value = build_attribute_value(
          attribute.value,
          context,
          WHITESPACE_INSENSITIVE_ATTRIBUTES.includes(name)
        );
        return prop("init", key(name), value);
      }
      return spread(
        /** @type {Expression} */
        context.visit(attribute)
      );
    })
  );
  const args = [object4, classes, styles, flags ? literal(flags) : void 0];
  context.state.template.push(call("$.spread_attributes", ...args));
}
function build_class_directives(class_directives, class_attribute) {
  const expressions = class_directives.map(
    (directive) => conditional(directive.expression, literal(directive.name), literal(""))
  );
  if (class_attribute === null) {
    class_attribute = create_attribute("class", -1, -1, []);
  }
  const chunks = get_attribute_chunks(class_attribute.value);
  const last = chunks.at(-1);
  if ((last == null ? void 0 : last.type) === "Text") {
    last.data += " ";
    last.raw += " ";
  } else if (last) {
    chunks.push({
      type: "Text",
      start: -1,
      end: -1,
      parent: class_attribute,
      data: " ",
      raw: " "
    });
  }
  chunks.push({
    type: "ExpressionTag",
    start: -1,
    end: -1,
    parent: class_attribute,
    expression: call(
      member(call(member(array(expressions), "filter"), id("Boolean")), id("join")),
      literal(" ")
    ),
    metadata: {
      expression: create_expression_metadata()
    }
  });
  class_attribute.value = chunks;
  return class_attribute;
}
function build_style_directives(style_directives, style_attribute, context) {
  const styles = style_directives.map((directive) => {
    let value = directive.value === true ? id(directive.name) : build_attribute_value(directive.value, context, true);
    if (directive.modifiers.includes("important")) {
      value = binary("+", value, literal(" !important"));
    }
    return init(directive.name, value);
  });
  const arg = style_attribute === null ? object(styles) : call(
    "$.merge_styles",
    build_attribute_value(style_attribute.value, context, true),
    object(styles)
  );
  context.state.template.push(call("$.add_styles", arg));
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/RegularElement.js
function RegularElement2(node, context) {
  const namespace = determine_namespace_for_children(node, context.state.namespace);
  const state = {
    ...context.state,
    namespace,
    preserve_whitespace: context.state.preserve_whitespace || node.name === "pre" || node.name === "textarea"
  };
  context.state.template.push(literal(`<${node.name}`));
  const body = build_element_attributes(node, { ...context, state });
  context.state.template.push(literal(">"));
  if ((node.name === "script" || node.name === "style") && node.fragment.nodes.length === 1) {
    context.state.template.push(
      literal(
        /** @type {AST.Text} */
        node.fragment.nodes[0].data
      ),
      literal(`</${node.name}>`)
    );
    return;
  }
  const { hoisted, trimmed } = clean_nodes(
    node,
    node.fragment.nodes,
    context.path,
    namespace,
    {
      ...state,
      scope: (
        /** @type {Scope} */
        state.scopes.get(node.fragment)
      )
    },
    state.preserve_whitespace,
    state.options.preserveComments
  );
  for (const node2 of hoisted) {
    context.visit(node2, state);
  }
  if (dev) {
    const location = (
      /** @type {Location} */
      locator(node.start)
    );
    state.template.push(
      stmt(
        call(
          "$.push_element",
          id("$$payload"),
          literal(node.name),
          literal(location.line),
          literal(location.column)
        )
      )
    );
  }
  if (body === null) {
    process_children(trimmed, { ...context, state });
  } else {
    let id2 = body;
    if (body.type !== "Identifier") {
      id2 = id(state.scope.generate("$$body"));
      state.template.push(const_builder(id2, body));
    }
    const inner_state = { ...state, template: [], init: [] };
    process_children(trimmed, { ...context, state: inner_state });
    state.template.push(
      if_builder(
        id2,
        block(build_template([id2])),
        block([...inner_state.init, ...build_template(inner_state.template)])
      )
    );
  }
  if (!is_void(node.name)) {
    state.template.push(literal(`</${node.name}>`));
  }
  if (dev) {
    state.template.push(stmt(call("$.pop_element")));
  }
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/RenderTag.js
function RenderTag2(node, context) {
  const callee = unwrap_optional(node.expression).callee;
  const raw_args = unwrap_optional(node.expression).arguments;
  const snippet_function = (
    /** @type {Expression} */
    context.visit(callee)
  );
  const snippet_args = raw_args.map((arg) => {
    return (
      /** @type {Expression} */
      context.visit(arg)
    );
  });
  context.state.template.push(
    stmt(
      (node.expression.type === "CallExpression" ? call : maybe_call)(
        snippet_function,
        id("$$payload"),
        ...snippet_args
      )
    )
  );
  if (!context.state.skip_hydration_boundaries) {
    context.state.template.push(empty_comment);
  }
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/SlotElement.js
function SlotElement2(node, context) {
  const props = [];
  const spreads = [];
  let name = literal("default");
  for (const attribute of node.attributes) {
    if (attribute.type === "SpreadAttribute") {
      spreads.push(
        /** @type {Expression} */
        context.visit(attribute)
      );
    } else if (attribute.type === "Attribute") {
      const value = build_attribute_value(attribute.value, context, false, true);
      if (attribute.name === "name") {
        name = /** @type {Literal} */
        value;
      } else if (attribute.name !== "slot") {
        props.push(init(attribute.name, value));
      }
    }
  }
  const props_expression = spreads.length === 0 ? object(props) : call("$.spread_props", array([object(props), ...spreads]));
  const fallback = node.fragment.nodes.length === 0 ? literal(null) : thunk(
    /** @type {BlockStatement} */
    context.visit(node.fragment)
  );
  const slot = call(
    "$.slot",
    id("$$payload"),
    id("$$props"),
    name,
    props_expression,
    fallback
  );
  context.state.template.push(empty_comment, stmt(slot), empty_comment);
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/SnippetBlock.js
function SnippetBlock2(node, context) {
  const fn = function_declaration(
    node.expression,
    [id("$$payload"), ...node.parameters],
    /** @type {BlockStatement} */
    context.visit(node.body)
  );
  fn.___snippet = true;
  context.state.init.push(fn);
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/SpreadAttribute.js
function SpreadAttribute2(node, context) {
  return context.visit(node.expression);
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/SvelteComponent.js
function SvelteComponent2(node, context) {
  build_inline_component(
    node,
    /** @type {Expression} */
    context.visit(node.expression),
    context
  );
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/SvelteElement.js
function SvelteElement2(node, context) {
  let tag2 = (
    /** @type {Expression} */
    context.visit(node.tag)
  );
  if (tag2.type !== "Identifier") {
    const tag_id = context.state.scope.generate("$$tag");
    context.state.init.push(const_builder(tag_id, tag2));
    tag2 = id(tag_id);
  }
  if (dev) {
    if (node.fragment.nodes.length > 0) {
      context.state.init.push(stmt(call("$.validate_void_dynamic_element", thunk(tag2))));
    }
    context.state.init.push(stmt(call("$.validate_dynamic_element_tag", thunk(tag2))));
  }
  const state = {
    ...context.state,
    namespace: determine_namespace_for_children(node, context.state.namespace),
    template: [],
    init: []
  };
  build_element_attributes(node, { ...context, state });
  if (dev) {
    const location = (
      /** @type {Location} */
      locator(node.start)
    );
    context.state.template.push(
      stmt(
        call(
          "$.push_element",
          id("$$payload"),
          tag2,
          literal(location.line),
          literal(location.column)
        )
      )
    );
  }
  const attributes = block([...state.init, ...build_template(state.template)]);
  const children = (
    /** @type {BlockStatement} */
    context.visit(node.fragment, state)
  );
  context.state.template.push(
    stmt(
      call(
        "$.element",
        id("$$payload"),
        tag2,
        attributes.body.length > 0 && thunk(attributes),
        children.body.length > 0 && thunk(children)
      )
    )
  );
  if (dev) {
    context.state.template.push(stmt(call("$.pop_element")));
  }
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/SvelteFragment.js
function SvelteFragment2(node, context) {
  context.state.template.push(
    /** @type {BlockStatement} */
    context.visit(node.fragment)
  );
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/SvelteHead.js
function SvelteHead2(node, context) {
  const block2 = (
    /** @type {BlockStatement} */
    context.visit(node.fragment)
  );
  context.state.template.push(
    stmt(call("$.head", id("$$payload"), arrow([id("$$payload")], block2)))
  );
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/SvelteSelf.js
function SvelteSelf2(node, context) {
  build_inline_component(node, id(context.state.analysis.name), context);
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/TitleElement.js
function TitleElement2(node, context) {
  const template3 = [literal("<title>")];
  process_children(node.fragment.nodes, { ...context, state: { ...context.state, template: template3 } });
  template3.push(literal("</title>"));
  context.state.init.push(...build_template(template3, id("$$payload.title"), "="));
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/UpdateExpression.js
function UpdateExpression2(node, context) {
  var _a2;
  const argument = node.argument;
  if (argument.type === "Identifier" && ((_a2 = context.state.scope.get(argument.name)) == null ? void 0 : _a2.kind) === "store_sub") {
    return call(
      node.prefix ? "$.update_store_pre" : "$.update_store",
      assignment("??=", id("$$store_subs"), object([])),
      literal(argument.name),
      id(argument.name.slice(1)),
      node.operator === "--" && literal(-1)
    );
  }
  return context.next();
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/VariableDeclaration.js
function VariableDeclaration(node, context) {
  var _a2;
  const declarations = [];
  if (context.state.analysis.runes) {
    for (const declarator2 of node.declarations) {
      const init2 = declarator2.init;
      const rune = get_rune(init2, context.state.scope);
      if (!rune || rune === "$effect.tracking" || rune === "$inspect" || rune === "$effect.root") {
        declarations.push(
          /** @type {VariableDeclarator} */
          context.visit(declarator2)
        );
        continue;
      }
      if (rune === "$props") {
        let has_rest = false;
        let id2 = walk(declarator2.id, null, {
          RestElement(node2, context2) {
            if (context2.path.at(-1) === declarator2.id) {
              has_rest = true;
            }
          },
          AssignmentPattern(node2) {
            if (node2.right.type === "CallExpression" && get_rune(node2.right, context.state.scope) === "$bindable") {
              const right = node2.right.arguments.length ? (
                /** @type {Expression} */
                context.visit(node2.right.arguments[0])
              ) : id("undefined");
              return assignment_pattern(node2.left, right);
            }
          }
        });
        if (id2.type === "ObjectPattern" && has_rest) {
          id2.properties.splice(
            id2.properties.length - 1,
            0,
            // @ts-ignore
            prop("init", id("$$slots"), id("$$slots")),
            prop("init", id("$$events"), id("$$events"))
          );
        } else if (id2.type === "Identifier") {
          id2 = object_pattern([
            prop("init", id("$$slots"), id("$$slots")),
            prop("init", id("$$events"), id("$$events")),
            rest(id(id2.name))
          ]);
        }
        declarations.push(
          declarator(
            /** @type {Pattern} */
            context.visit(id2),
            id("$$props")
          )
        );
        continue;
      }
      const args = (
        /** @type {CallExpression} */
        init2.arguments
      );
      const value = args.length === 0 ? id("undefined") : (
        /** @type {Expression} */
        context.visit(args[0])
      );
      if (rune === "$derived.by") {
        declarations.push(
          declarator(
            /** @type {Pattern} */
            context.visit(declarator2.id),
            call(value)
          )
        );
        continue;
      }
      if (declarator2.id.type === "Identifier") {
        declarations.push(declarator(declarator2.id, value));
        continue;
      }
      if (rune === "$derived") {
        declarations.push(
          declarator(
            /** @type {Pattern} */
            context.visit(declarator2.id),
            value
          )
        );
        continue;
      }
      declarations.push(...create_state_declarators(declarator2, context.state.scope, value));
    }
  } else {
    for (const declarator2 of node.declarations) {
      const bindings = (
        /** @type {Binding[]} */
        context.state.scope.get_bindings(declarator2)
      );
      const has_state = bindings.some((binding) => binding.kind === "state");
      const has_props = bindings.some((binding) => binding.kind === "bindable_prop");
      if (!has_state && !has_props) {
        declarations.push(
          /** @type {VariableDeclarator} */
          context.visit(declarator2)
        );
        continue;
      }
      if (has_props) {
        if (declarator2.id.type !== "Identifier") {
          const tmp = context.state.scope.generate("tmp");
          const paths = extract_paths(declarator2.id);
          declarations.push(
            declarator(
              id(tmp),
              /** @type {Expression} */
              context.visit(
                /** @type {Expression} */
                declarator2.init
              )
            )
          );
          for (const path of paths) {
            const value = (_a2 = path.expression) == null ? void 0 : _a2.call(path, id(tmp));
            const name = (
              /** @type {Identifier} */
              path.node.name
            );
            const binding2 = (
              /** @type {Binding} */
              context.state.scope.get(name)
            );
            const prop3 = member(id("$$props"), literal(binding2.prop_alias ?? name), true);
            declarations.push(declarator(path.node, build_fallback(prop3, value)));
          }
          continue;
        }
        const binding = (
          /** @type {Binding} */
          context.state.scope.get(declarator2.id.name)
        );
        const prop2 = member(
          id("$$props"),
          literal(binding.prop_alias ?? declarator2.id.name),
          true
        );
        let init2 = prop2;
        if (declarator2.init) {
          const default_value = (
            /** @type {Expression} */
            context.visit(declarator2.init)
          );
          init2 = build_fallback(prop2, default_value);
        }
        declarations.push(declarator(declarator2.id, init2));
        continue;
      }
      declarations.push(
        ...create_state_declarators(
          declarator2,
          context.state.scope,
          /** @type {Expression} */
          declarator2.init && context.visit(declarator2.init)
        )
      );
    }
  }
  return {
    ...node,
    declarations
  };
}
function create_state_declarators(declarator2, scope, value) {
  if (declarator2.id.type === "Identifier") {
    return [declarator(declarator2.id, value)];
  }
  const tmp = scope.generate("tmp");
  const paths = extract_paths(declarator2.id);
  return [
    declarator(id(tmp), value),
    // TODO inject declarator for opts, so we can use it below
    ...paths.map((path) => {
      var _a2;
      const value2 = (_a2 = path.expression) == null ? void 0 : _a2.call(path, id(tmp));
      return declarator(path.node, value2);
    })
  ];
}

// node_modules/svelte/src/compiler/phases/3-transform/server/transform-server.js
var global_visitors = {
  _: set_scope,
  AssignmentExpression: AssignmentExpression2,
  CallExpression: CallExpression2,
  ClassBody: ClassBody2,
  ExpressionStatement: ExpressionStatement2,
  Identifier: Identifier2,
  LabeledStatement: LabeledStatement2,
  MemberExpression: MemberExpression2,
  PropertyDefinition,
  UpdateExpression: UpdateExpression2,
  VariableDeclaration
};
var template_visitors = {
  AwaitBlock: AwaitBlock2,
  Component: Component2,
  ConstTag: ConstTag2,
  DebugTag: DebugTag2,
  EachBlock: EachBlock2,
  Fragment,
  HtmlTag: HtmlTag2,
  IfBlock: IfBlock2,
  KeyBlock: KeyBlock2,
  RegularElement: RegularElement2,
  RenderTag: RenderTag2,
  SlotElement: SlotElement2,
  SnippetBlock: SnippetBlock2,
  SpreadAttribute: SpreadAttribute2,
  SvelteComponent: SvelteComponent2,
  SvelteElement: SvelteElement2,
  SvelteFragment: SvelteFragment2,
  SvelteHead: SvelteHead2,
  SvelteSelf: SvelteSelf2,
  TitleElement: TitleElement2
};
function server_component(analysis, options) {
  const state = {
    analysis,
    options,
    scope: analysis.module.scope,
    scopes: analysis.module.scopes,
    hoisted: [import_all("$", "svelte/internal/server")],
    legacy_reactive_statements: /* @__PURE__ */ new Map(),
    // these are set inside the `Fragment` visitor, and cannot be used until then
    init: (
      /** @type {any} */
      null
    ),
    template: (
      /** @type {any} */
      null
    ),
    namespace: options.namespace,
    preserve_whitespace: options.preserveWhitespace,
    private_derived: /* @__PURE__ */ new Map(),
    skip_hydration_boundaries: false
  };
  const module = (
    /** @type {Program} */
    walk(
      /** @type {SvelteNode} */
      analysis.module.ast,
      state,
      global_visitors
    )
  );
  const instance = (
    /** @type {Program} */
    walk(
      /** @type {SvelteNode} */
      analysis.instance.ast,
      { ...state, scopes: analysis.instance.scopes },
      {
        ...global_visitors,
        ImportDeclaration(node) {
          state.hoisted.push(node);
          return empty;
        },
        ExportNamedDeclaration(node, context) {
          if (node.declaration) {
            return context.visit(node.declaration);
          }
          return empty;
        }
      }
    )
  );
  const template3 = (
    /** @type {Program} */
    walk(
      /** @type {SvelteNode} */
      analysis.template.ast,
      { ...state, scopes: analysis.template.scopes },
      // @ts-expect-error don't know, don't care
      { ...global_visitors, ...template_visitors }
    )
  );
  const legacy_reactive_declarations = [];
  for (const [node] of analysis.reactive_statements) {
    const statement = [...state.legacy_reactive_statements].find(([n]) => n === node);
    if (statement === void 0) {
      throw new Error("Could not find reactive statement");
    }
    if (node.body.type === "ExpressionStatement" && node.body.expression.type === "AssignmentExpression") {
      for (const id2 of extract_identifiers(node.body.expression.left)) {
        const binding = analysis.instance.scope.get(id2.name);
        if ((binding == null ? void 0 : binding.kind) === "legacy_reactive") {
          legacy_reactive_declarations.push(declarator(id2));
        }
      }
    }
    instance.body.push(statement[1]);
  }
  if (legacy_reactive_declarations.length > 0) {
    instance.body.unshift({
      type: "VariableDeclaration",
      kind: "let",
      declarations: legacy_reactive_declarations
    });
  }
  if (analysis.uses_component_bindings) {
    const snippets = template3.body.filter(
      // @ts-expect-error
      (node) => node.type === "FunctionDeclaration" && node.___snippet
    );
    const rest2 = template3.body.filter(
      // @ts-expect-error
      (node) => node.type !== "FunctionDeclaration" || !node.___snippet
    );
    template3.body = [
      ...snippets,
      let_builder("$$settled", true_instance),
      let_builder("$$inner_payload"),
      stmt(
        function_builder(
          id("$$render_inner"),
          [id("$$payload")],
          block(
            /** @type {Statement[]} */
            rest2
          )
        )
      ),
      do_while(
        unary("!", id("$$settled")),
        block([
          stmt(assignment("=", id("$$settled"), true_instance)),
          stmt(
            assignment("=", id("$$inner_payload"), call("$.copy_payload", id("$$payload")))
          ),
          stmt(call("$$render_inner", id("$$inner_payload")))
        ])
      ),
      stmt(call("$.assign_payload", id("$$payload"), id("$$inner_payload")))
    ];
  }
  if ([...analysis.instance.scope.declarations.values()].some(
    (binding) => binding.kind === "store_sub"
  )) {
    instance.body.unshift(var_builder("$$store_subs"));
    template3.body.push(
      if_builder(id("$$store_subs"), stmt(call("$.unsubscribe_stores", id("$$store_subs"))))
    );
  }
  const props = [];
  for (const [name, binding] of analysis.instance.scope.declarations) {
    if (binding.kind === "bindable_prop" && !name.startsWith("$$")) {
      props.push(init(binding.prop_alias ?? name, id(name)));
    }
  }
  for (const { name, alias } of analysis.exports) {
    props.push(init(alias ?? name, id(name)));
  }
  if (props.length > 0) {
    template3.body.push(stmt(call("$.bind_props", id("$$props"), object(props))));
  }
  const component_block = block([
    .../** @type {Statement[]} */
    instance.body,
    .../** @type {Statement[]} */
    template3.body
  ]);
  let should_inject_context = dev || analysis.needs_context;
  if (should_inject_context) {
    component_block.body.unshift(stmt(call("$.push", dev && id(analysis.name))));
    component_block.body.push(stmt(call("$.pop")));
  }
  if (analysis.uses_rest_props) {
    const named_props = analysis.exports.map(({ name, alias }) => alias ?? name);
    for (const [name, binding] of analysis.instance.scope.declarations) {
      if (binding.kind === "bindable_prop") named_props.push(binding.prop_alias ?? name);
    }
    component_block.body.unshift(
      const_builder(
        "$$restProps",
        call(
          "$.rest_props",
          id("$$sanitized_props"),
          array(named_props.map((name) => literal(name)))
        )
      )
    );
  }
  if (analysis.uses_props || analysis.uses_rest_props) {
    component_block.body.unshift(
      const_builder("$$sanitized_props", call("$.sanitize_props", id("$$props")))
    );
  }
  if (analysis.uses_slots) {
    component_block.body.unshift(const_builder("$$slots", call("$.sanitize_slots", id("$$props"))));
  }
  const body = [...state.hoisted, ...module.body];
  if (analysis.css.ast !== null && options.css === "injected" && !options.customElement) {
    const hash2 = literal(analysis.css.hash);
    const code = literal(render_stylesheet(analysis.source, analysis, options).code);
    body.push(const_builder("$$css", object([init("hash", hash2), init("code", code)])));
    component_block.body.unshift(stmt(call("$$payload.css.add", id("$$css"))));
  }
  let should_inject_props = should_inject_context || props.length > 0 || analysis.needs_props || analysis.uses_props || analysis.uses_rest_props || analysis.uses_slots || analysis.slot_names.size > 0;
  const component_function = function_declaration(
    id(analysis.name),
    should_inject_props ? [id("$$payload"), id("$$props")] : [id("$$payload")],
    component_block
  );
  if (options.compatibility.componentApi === 4) {
    body.unshift(imports([["render", "$$_render"]], "svelte/server"));
    body.push(
      component_function,
      stmt(
        assignment(
          "=",
          member_id(`${analysis.name}.render`),
          function_builder(
            null,
            [id("$$props"), id("$$opts")],
            block([
              return_builder(
                call(
                  "$$_render",
                  id(analysis.name),
                  object([
                    init("props", id("$$props")),
                    init("context", member(id("$$opts"), "context", false, true))
                  ])
                )
              )
            ])
          )
        )
      ),
      export_default(id(analysis.name))
    );
  } else if (dev) {
    body.push(
      component_function,
      stmt(
        assignment(
          "=",
          member_id(`${analysis.name}.render`),
          function_builder(
            null,
            [],
            block([
              throw_error(
                `Component.render(...) is no longer valid in Svelte 5. See https://svelte.dev/docs/svelte/v5-migration-guide#Components-are-no-longer-classes for more information`
              )
            ])
          )
        )
      ),
      export_default(id(analysis.name))
    );
  } else {
    body.push(export_default(component_function));
  }
  if (dev) {
    body.unshift(
      stmt(
        assignment("=", member(id(analysis.name), "$.FILENAME", true), literal(filename))
      )
    );
  }
  return {
    type: "Program",
    sourceType: "module",
    body
  };
}
function server_module(analysis, options) {
  const state = {
    analysis,
    options,
    scope: analysis.module.scope,
    scopes: analysis.module.scopes,
    // this is an anomaly — it can only be used in components, but it needs
    // to be present for `javascript_visitors_legacy` and so is included in module
    // transform state as well as component transform state
    legacy_reactive_statements: /* @__PURE__ */ new Map(),
    private_derived: /* @__PURE__ */ new Map()
  };
  const module = (
    /** @type {Program} */
    walk(
      /** @type {SvelteNode} */
      analysis.module.ast,
      state,
      global_visitors
    )
  );
  return {
    type: "Program",
    sourceType: "module",
    body: [import_all("$", "svelte/internal/server"), ...module.body]
  };
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/shared/utils.js
function get_states_and_calls(values) {
  let states = 0;
  let calls = 0;
  for (let i = 0; i < values.length; i++) {
    const node = values[i];
    if (node.type === "ExpressionTag") {
      if (node.metadata.expression.has_call) {
        calls++;
      }
      if (node.metadata.expression.has_state) {
        states++;
      }
    }
  }
  return { states, calls };
}
function build_template_literal(values, visit, state) {
  const expressions = [];
  let quasi2 = quasi("");
  const quasis = [quasi2];
  const { states, calls } = get_states_and_calls(values);
  let has_call = calls > 0;
  let has_state = states > 0;
  let contains_multiple_call_expression = calls > 1;
  for (let i = 0; i < values.length; i++) {
    const node = values[i];
    if (node.type === "Text") {
      quasi2.value.cooked += node.data;
    } else if (node.type === "ExpressionTag" && node.expression.type === "Literal") {
      if (node.expression.value != null) {
        quasi2.value.cooked += node.expression.value + "";
      }
    } else {
      if (contains_multiple_call_expression) {
        const id2 = id(state.scope.generate("stringified_text"));
        state.init.push(
          const_builder(
            id2,
            create_derived(
              state,
              thunk(
                logical(
                  "??",
                  /** @type {Expression} */
                  visit(node.expression, state),
                  literal("")
                )
              )
            )
          )
        );
        expressions.push(call("$.get", id2));
      } else if (values.length === 1) {
        return { value: visit(node.expression, state), has_state, has_call };
      } else {
        expressions.push(logical("??", visit(node.expression, state), literal("")));
      }
      quasi2 = quasi("", i + 1 === values.length);
      quasis.push(quasi2);
    }
  }
  for (const quasi3 of quasis) {
    quasi3.value.raw = sanitize_template_string(
      /** @type {string} */
      quasi3.value.cooked
    );
  }
  const value = template(quasis, expressions);
  return { value, has_state, has_call };
}
function build_update(statement) {
  const body = statement.type === "ExpressionStatement" ? statement.expression : block([statement]);
  return stmt(call("$.template_effect", thunk(body)));
}
function build_render_statement(update2) {
  return update2.length === 1 ? build_update(update2[0]) : stmt(call("$.template_effect", thunk(block(update2))));
}
function parse_directive_name(name) {
  const parts = name.split(".");
  let part = (
    /** @type {string} */
    parts.shift()
  );
  let expression = id(part);
  while (part = /** @type {string} */
  parts.shift()) {
    const computed = !regex_is_valid_identifier.test(part);
    expression = member(expression, computed ? literal(part) : id(part), computed);
  }
  return expression;
}
function build_update_assignment(state, id2, init2, value, update2) {
  state.init.push(var_builder(id2, init2));
  state.update.push(
    if_builder(binary("!==", id(id2), assignment("=", id(id2), value)), block([update2]))
  );
}
function build_bind_this(expression, value, { state, visit }) {
  const ids = [];
  const values = [];
  const seen = [];
  const transform = { ...state.transform };
  walk(expression, null, {
    Identifier(node2, { path }) {
      if (seen.includes(node2.name)) return;
      seen.push(node2.name);
      const parent = (
        /** @type {Expression} */
        path.at(-1)
      );
      if (!is_reference(node2, parent)) return;
      const binding = state.scope.get(node2.name);
      if (!binding) return;
      for (const [owner, scope] of state.scopes) {
        if (owner.type === "EachBlock" && scope === binding.scope) {
          ids.push(node2);
          values.push(
            /** @type {Expression} */
            visit(node2)
          );
          if (transform[node2.name]) {
            transform[node2.name] = {
              ...transform[node2.name],
              read: (node3) => node3
            };
          }
          break;
        }
      }
    }
  });
  const child_state = { ...state, transform };
  const get2 = (
    /** @type {Expression} */
    visit(expression, child_state)
  );
  const set2 = (
    /** @type {Expression} */
    visit(assignment("=", expression, id("$$value")), child_state)
  );
  let node = get2;
  while (node.type === "MemberExpression") {
    node.optional = true;
    node = node.object;
  }
  return call(
    "$.bind_this",
    value,
    arrow([id("$$value"), ...ids], set2),
    arrow([...ids], get2),
    values.length > 0 && thunk(array(values))
  );
}
function validate_binding(state, binding, expression) {
  const left = object2(binding.expression);
  const left_binding = left && state.scope.get(left.name);
  if ((left_binding == null ? void 0 : left_binding.kind) === "store_sub") return;
  const loc = locator(binding.start);
  state.init.push(
    stmt(
      call(
        "$.validate_binding",
        literal(state.analysis.source.slice(binding.start, binding.end)),
        thunk(
          /** @type {Expression} */
          expression.object
        ),
        thunk(
          /** @type {Expression} */
          expression.computed ? expression.property : literal(
            /** @type {Identifier} */
            expression.property.name
          )
        ),
        loc && literal(loc.line),
        loc && literal(loc.column)
      )
    )
  );
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/AnimateDirective.js
function AnimateDirective(node, context) {
  const expression = node.expression === null ? literal(null) : thunk(
    /** @type {Expression} */
    context.visit(node.expression)
  );
  context.state.after_update.push(
    stmt(
      call(
        "$.animation",
        context.state.node,
        thunk(
          /** @type {Expression} */
          context.visit(parse_directive_name(node.name))
        ),
        expression
      )
    )
  );
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/shared/function.js
var visit_function2 = (node, context) => {
  const metadata = node.metadata;
  let state = { ...context.state, in_constructor: false };
  if (node.type === "FunctionExpression") {
    const parent = (
      /** @type {Node} */
      context.path.at(-1)
    );
    state.in_constructor = parent.type === "MethodDefinition" && parent.kind === "constructor";
  }
  if ((metadata == null ? void 0 : metadata.hoisted) === true) {
    const params = build_hoisted_params(node, context);
    return (
      /** @type {FunctionExpression} */
      {
        ...node,
        params,
        body: context.visit(node.body, state)
      }
    );
  }
  context.next(state);
};

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/ArrowFunctionExpression.js
function ArrowFunctionExpression2(node, context) {
  return visit_function2(node, context);
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/AssignmentExpression.js
function AssignmentExpression3(node, context) {
  const expression = (
    /** @type {Expression} */
    visit_assignment_expression(node, context, build_assignment2) ?? context.next()
  );
  return is_ignored(node, "ownership_invalid_mutation") ? call("$.skip_ownership_validation", thunk(expression)) : expression;
}
function build_assignment2(operator, left, right, context) {
  if (context.state.analysis.runes && left.type === "MemberExpression" && left.object.type === "ThisExpression") {
    if (left.property.type === "PrivateIdentifier") {
      const private_state = context.state.private_state.get(left.property.name);
      if (private_state !== void 0) {
        let transformed = false;
        let value = (
          /** @type {Expression} */
          context.visit(build_assignment_value(operator, left, right))
        );
        if (should_proxy(value, context.state.scope)) {
          transformed = true;
          value = private_state.kind === "raw_state" ? value : build_proxy_reassignment(value, member(this_instance, private_state.id));
        }
        if (!context.state.in_constructor) {
          return call("$.set", left, value);
        } else if (transformed) {
          return assignment(
            operator,
            /** @type {Pattern} */
            context.visit(left),
            value
          );
        }
      }
    }
  }
  let object4 = left;
  while (object4.type === "MemberExpression") {
    object4 = object4.object;
  }
  if (object4.type !== "Identifier") {
    return null;
  }
  const binding = context.state.scope.get(object4.name);
  if (!binding) return null;
  const transform = Object.hasOwn(context.state.transform, object4.name) ? context.state.transform[object4.name] : null;
  if (object4 === left && (transform == null ? void 0 : transform.assign)) {
    let value = (
      /** @type {Expression} */
      context.visit(build_assignment_value(operator, left, right))
    );
    const path = context.path.map((node) => node.type);
    const is_primitive = path.at(-1) === "BindDirective" && path.at(-2) === "RegularElement";
    if (!is_primitive && binding.kind !== "prop" && binding.kind !== "bindable_prop" && context.state.analysis.runes && should_proxy(value, context.state.scope)) {
      value = binding.kind === "raw_state" ? value : build_proxy_reassignment(value, object4);
    }
    return transform.assign(object4, value);
  }
  if (transform == null ? void 0 : transform.mutate) {
    return transform.mutate(
      object4,
      assignment(
        operator,
        /** @type {Pattern} */
        context.visit(left),
        /** @type {Expression} */
        context.visit(right)
      )
    );
  }
  return null;
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/shared/events.js
function visit_event_attribute(node, context) {
  let capture = false;
  let event_name = node.name.slice(2);
  if (is_capture_event(event_name)) {
    event_name = event_name.slice(0, -7);
    capture = true;
  }
  const tag2 = Array.isArray(node.value) ? (
    /** @type {AST.ExpressionTag} */
    node.value[0]
  ) : (
    /** @type {AST.ExpressionTag} */
    node.value
  );
  let handler = build_event_handler(tag2.expression, tag2.metadata.expression, context);
  if (node.metadata.delegated) {
    let delegated_assignment;
    if (!context.state.events.has(event_name)) {
      context.state.events.add(event_name);
    }
    if (node.metadata.delegated.hoisted) {
      if (node.metadata.delegated.function === tag2.expression) {
        const func_name = context.state.scope.root.unique("on_" + event_name);
        context.state.hoisted.push(var_builder(func_name, handler));
        handler = func_name;
      }
      const hoisted_params = (
        /** @type {Expression[]} */
        node.metadata.delegated.function.metadata.hoisted_params
      );
      const args = [handler, ...hoisted_params];
      delegated_assignment = array(args);
    } else {
      delegated_assignment = handler;
    }
    context.state.init.push(
      stmt(
        assignment("=", member(context.state.node, "__" + event_name), delegated_assignment)
      )
    );
  } else {
    const statement = stmt(
      build_event(
        event_name,
        context.state.node,
        handler,
        capture,
        is_passive_event(event_name) ? true : void 0
      )
    );
    const type = (
      /** @type {SvelteNode} */
      context.path.at(-1).type
    );
    if (type === "SvelteDocument" || type === "SvelteWindow" || type === "SvelteBody") {
      context.state.init.push(statement);
    } else {
      context.state.after_update.push(statement);
    }
  }
}
function build_event(event_name, node, handler, capture, passive) {
  return call(
    "$.event",
    literal(event_name),
    node,
    handler,
    capture && true_instance,
    passive === void 0 ? void 0 : literal(passive)
  );
}
function build_event_handler(node, metadata, context) {
  var _a2;
  if (node === null) {
    return function_builder(
      null,
      [id("$$arg")],
      block([stmt(call("$.bubble_event.call", this_instance, id("$$props"), id("$$arg")))])
    );
  }
  let handler = (
    /** @type {Expression} */
    context.visit(node)
  );
  if (handler.type === "ArrowFunctionExpression" || handler.type === "FunctionExpression") {
    return handler;
  }
  if (handler.type === "Identifier" && ((_a2 = context.state.scope.get(handler.name)) == null ? void 0 : _a2.declaration_kind) !== "import") {
    return handler;
  }
  if (metadata.has_call) {
    const id2 = id(context.state.scope.generate("event_handler"));
    context.state.init.push(var_builder(id2, call("$.derived", thunk(handler))));
    handler = call("$.get", id2);
  }
  let call2 = call(member(handler, "apply", false, true), this_instance, id("$$args"));
  if (dev) {
    const loc = locator(
      /** @type {number} */
      node.start
    );
    const remove_parens = node.type === "CallExpression" && node.arguments.length === 0 && node.callee.type === "Identifier";
    call2 = call(
      "$.apply",
      thunk(handler),
      this_instance,
      id("$$args"),
      id(context.state.analysis.name),
      loc && array([literal(loc.line), literal(loc.column)]),
      has_side_effects(node) && true_instance,
      remove_parens && true_instance
    );
  }
  return function_builder(null, [rest(id("$$args"))], block([stmt(call2)]));
}
function has_side_effects(node) {
  if (node.type === "CallExpression" || node.type === "NewExpression" || node.type === "AssignmentExpression" || node.type === "UpdateExpression") {
    return true;
  }
  if (node.type === "SequenceExpression") {
    return node.expressions.some(has_side_effects);
  }
  return false;
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/Attribute.js
function Attribute2(node, context) {
  if (is_event_attribute(node)) {
    visit_event_attribute(node, context);
  }
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/AwaitBlock.js
function AwaitBlock3(node, context) {
  context.state.template.push("<!>");
  const expression = thunk(
    /** @type {Expression} */
    context.visit(node.expression)
  );
  let then_block;
  let catch_block;
  if (node.then) {
    const then_context = {
      ...context,
      state: { ...context.state, transform: { ...context.state.transform } }
    };
    const argument = node.value && create_derived_block_argument(node.value, then_context);
    const args = [id("$$anchor")];
    if (argument) args.push(argument.id);
    const declarations = (argument == null ? void 0 : argument.declarations) ?? [];
    const block2 = (
      /** @type {BlockStatement} */
      then_context.visit(node.then, then_context.state)
    );
    then_block = arrow(args, block([...declarations, ...block2.body]));
  }
  if (node.catch) {
    const catch_context = { ...context, state: { ...context.state } };
    const argument = node.error && create_derived_block_argument(node.error, catch_context);
    const args = [id("$$anchor")];
    if (argument) args.push(argument.id);
    const declarations = (argument == null ? void 0 : argument.declarations) ?? [];
    const block2 = (
      /** @type {BlockStatement} */
      catch_context.visit(node.catch, catch_context.state)
    );
    catch_block = arrow(args, block([...declarations, ...block2.body]));
  }
  context.state.init.push(
    stmt(
      call(
        "$.await",
        context.state.node,
        expression,
        node.pending ? arrow(
          [id("$$anchor")],
          /** @type {BlockStatement} */
          context.visit(node.pending)
        ) : literal(null),
        then_block,
        catch_block
      )
    )
  );
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/BinaryExpression.js
function BinaryExpression(node, context) {
  if (dev) {
    const operator = node.operator;
    if (operator === "===" || operator === "!==") {
      return call(
        "$.strict_equals",
        /** @type {Expression} */
        context.visit(node.left),
        /** @type {Expression} */
        context.visit(node.right),
        operator === "!==" && literal(false)
      );
    }
    if (operator === "==" || operator === "!=") {
      return call(
        "$.equals",
        /** @type {Expression} */
        context.visit(node.left),
        /** @type {Expression} */
        context.visit(node.right),
        operator === "!=" && literal(false)
      );
    }
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/shared/element.js
function build_set_attributes(attributes, context, element2, element_id, attributes_id, preserve_attribute_case, is_custom_element, state) {
  let has_state = false;
  const values = [];
  for (const attribute of attributes) {
    if (attribute.type === "Attribute") {
      const { value } = build_attribute_value2(attribute.value, context);
      if (is_event_attribute(attribute) && (value.type === "ArrowFunctionExpression" || value.type === "FunctionExpression")) {
        const id2 = context.state.scope.generate("event_handler");
        context.state.init.push(var_builder(id2, value));
        values.push(init(attribute.name, id(id2)));
      } else {
        values.push(init(attribute.name, value));
      }
      has_state || (has_state = attribute.metadata.expression.has_state);
    } else {
      has_state = true;
      let value = (
        /** @type {Expression} */
        context.visit(attribute)
      );
      if (attribute.metadata.expression.has_call) {
        const id2 = id(state.scope.generate("spread_with_call"));
        state.init.push(const_builder(id2, create_derived(state, thunk(value))));
        value = call("$.get", id2);
      }
      values.push(spread(value));
    }
  }
  const call2 = call(
    "$.set_attributes",
    element_id,
    has_state ? attributes_id : literal(null),
    object(values),
    context.state.analysis.css.hash !== "" && literal(context.state.analysis.css.hash),
    preserve_attribute_case,
    is_custom_element,
    is_ignored(element2, "hydration_attribute_changed") && true_instance
  );
  if (has_state) {
    context.state.init.push(let_builder(attributes_id));
    const update2 = stmt(assignment("=", attributes_id, call2));
    context.state.update.push(update2);
    return true;
  }
  context.state.init.push(stmt(call2));
  return false;
}
function build_style_directives2(style_directives, element_id, context, is_attributes_reactive) {
  const state = context.state;
  for (const directive of style_directives) {
    const { has_state, has_call } = directive.metadata.expression;
    let value = directive.value === true ? build_getter({ name: directive.name, type: "Identifier" }, context.state) : build_attribute_value2(directive.value, context).value;
    if (has_call) {
      const id2 = id(state.scope.generate("style_directive"));
      state.init.push(const_builder(id2, create_derived(state, thunk(value))));
      value = call("$.get", id2);
    }
    const update2 = stmt(
      call(
        "$.set_style",
        element_id,
        literal(directive.name),
        value,
        /** @type {Expression} */
        directive.modifiers.includes("important") ? true_instance : void 0
      )
    );
    if (!is_attributes_reactive && has_call) {
      state.init.push(build_update(update2));
    } else if (is_attributes_reactive || has_state || has_call) {
      state.update.push(update2);
    } else {
      state.init.push(update2);
    }
  }
}
function build_class_directives2(class_directives, element_id, context, is_attributes_reactive) {
  const state = context.state;
  for (const directive of class_directives) {
    const { has_state, has_call } = directive.metadata.expression;
    let value = (
      /** @type {Expression} */
      context.visit(directive.expression)
    );
    if (has_call) {
      const id2 = id(state.scope.generate("class_directive"));
      state.init.push(const_builder(id2, create_derived(state, thunk(value))));
      value = call("$.get", id2);
    }
    const update2 = stmt(call("$.toggle_class", element_id, literal(directive.name), value));
    if (!is_attributes_reactive && has_call) {
      state.init.push(build_update(update2));
    } else if (is_attributes_reactive || has_state || has_call) {
      state.update.push(update2);
    } else {
      state.init.push(update2);
    }
  }
}
function build_attribute_value2(value, context) {
  if (value === true) {
    return { has_state: false, has_call: false, value: literal(true) };
  }
  if (!Array.isArray(value) || value.length === 1) {
    const chunk = Array.isArray(value) ? value[0] : value;
    if (chunk.type === "Text") {
      return { has_state: false, has_call: false, value: literal(chunk.data) };
    }
    return {
      has_state: chunk.metadata.expression.has_state,
      has_call: chunk.metadata.expression.has_call,
      value: (
        /** @type {Expression} */
        context.visit(chunk.expression)
      )
    };
  }
  return build_template_literal(value, context.visit, context.state);
}
function get_attribute_name2(element2, attribute) {
  if (!element2.metadata.svg && !element2.metadata.mathml) {
    return normalize_attribute(attribute.name);
  }
  return attribute.name;
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/BindDirective.js
function BindDirective2(node, context) {
  var _a2;
  const expression = node.expression;
  const property = binding_properties[node.name];
  const parent = (
    /** @type {SvelteNode} */
    context.path.at(-1)
  );
  if (dev && context.state.analysis.runes && expression.type === "MemberExpression" && (node.name !== "this" || context.path.some(
    ({ type }) => type === "IfBlock" || type === "EachBlock" || type === "AwaitBlock" || type === "KeyBlock"
  )) && !is_ignored(node, "binding_property_non_reactive")) {
    validate_binding(
      context.state,
      node,
      /**@type {MemberExpression} */
      context.visit(expression)
    );
  }
  const get2 = thunk(
    /** @type {Expression} */
    context.visit(expression)
  );
  let set2 = unthunk(
    arrow(
      [id("$$value")],
      /** @type {Expression} */
      context.visit(assignment("=", expression, id("$$value")))
    )
  );
  if (get2 === set2) {
    set2 = void 0;
  }
  let call2;
  if (property == null ? void 0 : property.event) {
    call2 = call(
      "$.bind_property",
      literal(node.name),
      literal(property.event),
      context.state.node,
      set2 ?? get2,
      property.bidirectional && get2
    );
  } else {
    switch (node.name) {
      case "online":
        call2 = call(`$.bind_online`, set2 ?? get2);
        break;
      case "scrollX":
      case "scrollY":
        call2 = call(
          "$.bind_window_scroll",
          literal(node.name === "scrollX" ? "x" : "y"),
          get2,
          set2
        );
        break;
      case "innerWidth":
      case "innerHeight":
      case "outerWidth":
      case "outerHeight":
        call2 = call("$.bind_window_size", literal(node.name), set2 ?? get2);
        break;
      case "activeElement":
        call2 = call("$.bind_active_element", set2 ?? get2);
        break;
      case "muted":
        call2 = call(`$.bind_muted`, context.state.node, get2, set2);
        break;
      case "paused":
        call2 = call(`$.bind_paused`, context.state.node, get2, set2);
        break;
      case "volume":
        call2 = call(`$.bind_volume`, context.state.node, get2, set2);
        break;
      case "playbackRate":
        call2 = call(`$.bind_playback_rate`, context.state.node, get2, set2);
        break;
      case "currentTime":
        call2 = call(`$.bind_current_time`, context.state.node, get2, set2);
        break;
      case "buffered":
        call2 = call(`$.bind_buffered`, context.state.node, set2 ?? get2);
        break;
      case "played":
        call2 = call(`$.bind_played`, context.state.node, set2 ?? get2);
        break;
      case "seekable":
        call2 = call(`$.bind_seekable`, context.state.node, set2 ?? get2);
        break;
      case "seeking":
        call2 = call(`$.bind_seeking`, context.state.node, set2 ?? get2);
        break;
      case "ended":
        call2 = call(`$.bind_ended`, context.state.node, set2 ?? get2);
        break;
      case "readyState":
        call2 = call(`$.bind_ready_state`, context.state.node, set2 ?? get2);
        break;
      case "contentRect":
      case "contentBoxSize":
      case "borderBoxSize":
      case "devicePixelContentBoxSize":
        call2 = call(
          "$.bind_resize_observer",
          context.state.node,
          literal(node.name),
          set2 ?? get2
        );
        break;
      case "clientWidth":
      case "clientHeight":
      case "offsetWidth":
      case "offsetHeight":
        call2 = call("$.bind_element_size", context.state.node, literal(node.name), set2 ?? get2);
        break;
      case "value": {
        if ((parent == null ? void 0 : parent.type) === "RegularElement" && parent.name === "select") {
          call2 = call(`$.bind_select_value`, context.state.node, get2, set2);
        } else {
          call2 = call(`$.bind_value`, context.state.node, get2, set2);
        }
        break;
      }
      case "files":
        call2 = call(`$.bind_files`, context.state.node, get2, set2);
        break;
      case "this":
        call2 = build_bind_this(expression, context.state.node, context);
        break;
      case "textContent":
      case "innerHTML":
      case "innerText":
        call2 = call(
          "$.bind_content_editable",
          literal(node.name),
          context.state.node,
          get2,
          set2
        );
        break;
      case "checked":
        call2 = call(`$.bind_checked`, context.state.node, get2, set2);
        break;
      case "focused":
        call2 = call(`$.bind_focused`, context.state.node, set2 ?? get2);
        break;
      case "group": {
        const indexes = node.metadata.parent_each_blocks.map((each) => {
          return each.metadata.keyed && each.index ? call("$.get", each.metadata.index) : each.metadata.index;
        });
        let group_getter = get2;
        if ((parent == null ? void 0 : parent.type) === "RegularElement") {
          const value = (
            /** @type {any[]} */
            /** @type {AST.Attribute} */
            (_a2 = parent.attributes.find(
              (a) => a.type === "Attribute" && a.name === "value" && !is_text_attribute(a) && a.value !== true
            )) == null ? void 0 : _a2.value
          );
          if (value !== void 0) {
            group_getter = thunk(
              block([
                stmt(build_attribute_value2(value, context).value),
                return_builder(
                  /** @type {Expression} */
                  context.visit(expression)
                )
              ])
            );
          }
        }
        call2 = call(
          "$.bind_group",
          node.metadata.binding_group_name,
          array(indexes),
          context.state.node,
          group_getter,
          set2 ?? get2
        );
        break;
      }
      default:
        throw new Error("unknown binding " + node.name);
    }
  }
  if (node.name === "this") {
    context.state.init.push(stmt(call2));
  } else {
    const has_use = parent.type === "RegularElement" && parent.attributes.find((a) => a.type === "UseDirective");
    if (has_use) {
      context.state.init.push(stmt(call("$.effect", thunk(call2))));
    } else {
      context.state.after_update.push(stmt(call2));
    }
  }
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/BlockStatement.js
function BlockStatement(node, context) {
  add_state_transformers(context);
  context.next();
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/BreakStatement.js
function BreakStatement(node, context) {
  if (context.state.analysis.runes || !node.label || node.label.name !== "$") {
    return;
  }
  const in_reactive_statement = context.path[1].type === "LabeledStatement" && context.path[1].label.name === "$";
  if (in_reactive_statement) {
    return return_builder();
  }
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/CallExpression.js
function CallExpression3(node, context) {
  switch (get_rune(node, context.state.scope)) {
    case "$host":
      return id("$$props.$$host");
    case "$effect.tracking":
      return call("$.effect_tracking");
    case "$state.snapshot":
      return call(
        "$.snapshot",
        /** @type {Expression} */
        context.visit(node.arguments[0]),
        is_ignored(node, "state_snapshot_uncloneable") && true_instance
      );
    case "$effect.root":
      return call(
        "$.effect_root",
        .../** @type {Expression[]} */
        node.arguments.map((arg) => context.visit(arg))
      );
    case "$inspect":
    case "$inspect().with":
      return transform_inspect_rune(node, context);
  }
  if (dev && node.callee.type === "MemberExpression" && node.callee.object.type === "Identifier" && node.callee.object.name === "console" && context.state.scope.get("console") === null && node.callee.property.type === "Identifier" && ["debug", "dir", "error", "group", "groupCollapsed", "info", "log", "trace", "warn"].includes(
    node.callee.property.name
  )) {
    return call(
      node.callee,
      spread(
        call(
          "$.log_if_contains_state",
          literal(node.callee.property.name),
          .../** @type {Expression[]} */
          node.arguments.map((arg) => context.visit(arg))
        )
      )
    );
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/ClassBody.js
function ClassBody3(node, context) {
  var _a2, _b2;
  if (!context.state.analysis.runes) {
    context.next();
    return;
  }
  const public_state = /* @__PURE__ */ new Map();
  const private_state = /* @__PURE__ */ new Map();
  const private_ids = [];
  for (const definition of node.body) {
    if (definition.type === "PropertyDefinition" && (definition.key.type === "Identifier" || definition.key.type === "PrivateIdentifier" || definition.key.type === "Literal")) {
      const type = definition.key.type;
      const name = get_name(definition.key);
      if (!name) continue;
      const is_private = type === "PrivateIdentifier";
      if (is_private) private_ids.push(name);
      if (((_a2 = definition.value) == null ? void 0 : _a2.type) === "CallExpression") {
        const rune = get_rune(definition.value, context.state.scope);
        if (rune === "$state" || rune === "$state.raw" || rune === "$derived" || rune === "$derived.by") {
          const field = {
            kind: rune === "$state" ? "state" : rune === "$state.raw" ? "raw_state" : rune === "$derived.by" ? "derived_by" : "derived",
            // @ts-expect-error this is set in the next pass
            id: is_private ? definition.key : null
          };
          if (is_private) {
            private_state.set(name, field);
          } else {
            public_state.set(name, field);
          }
        }
      }
    }
  }
  for (const [name, field] of public_state) {
    let deconflicted = name;
    while (private_ids.includes(deconflicted)) {
      deconflicted = "_" + deconflicted;
    }
    private_ids.push(deconflicted);
    field.id = private_id(deconflicted);
  }
  const body = [];
  const child_state = { ...context.state, public_state, private_state };
  for (const definition of node.body) {
    if (definition.type === "PropertyDefinition" && (definition.key.type === "Identifier" || definition.key.type === "PrivateIdentifier" || definition.key.type === "Literal")) {
      const name = get_name(definition.key);
      if (!name) continue;
      const is_private = definition.key.type === "PrivateIdentifier";
      const field = (is_private ? private_state : public_state).get(name);
      if (((_b2 = definition.value) == null ? void 0 : _b2.type) === "CallExpression" && field !== void 0) {
        let value = null;
        if (definition.value.arguments.length > 0) {
          const init2 = (
            /** @type {Expression} **/
            context.visit(definition.value.arguments[0], child_state)
          );
          value = field.kind === "state" ? call(
            "$.state",
            should_proxy(init2, context.state.scope) ? call("$.proxy", init2) : init2
          ) : field.kind === "raw_state" ? call("$.state", init2) : field.kind === "derived_by" ? call("$.derived", init2) : call("$.derived", thunk(init2));
        } else {
          value = call("$.state");
        }
        if (is_private) {
          body.push(prop_def(field.id, value));
        } else {
          const member2 = member(this_instance, field.id);
          body.push(prop_def(field.id, value));
          body.push(method("get", definition.key, [], [return_builder(call("$.get", member2))]));
          if (field.kind === "state") {
            const value2 = id("value");
            const prev = member(this_instance, field.id);
            body.push(
              method(
                "set",
                definition.key,
                [value2],
                [stmt(call("$.set", member2, build_proxy_reassignment(value2, prev)))]
              )
            );
          }
          if (field.kind === "raw_state") {
            const value2 = id("value");
            body.push(
              method("set", definition.key, [value2], [stmt(call("$.set", member2, value2))])
            );
          }
          if (dev && (field.kind === "derived" || field.kind === "derived_by")) {
            body.push(
              method(
                "set",
                definition.key,
                [id("_")],
                [throw_error(`Cannot update a derived property ('${name}')`)]
              )
            );
          }
        }
        continue;
      }
    }
    body.push(
      /** @type {MethodDefinition} **/
      context.visit(definition, child_state)
    );
  }
  if (dev && public_state.size > 0) {
    body.push(
      method(
        "method",
        id("$.ADD_OWNER"),
        [id("owner")],
        Array.from(public_state.keys()).map(
          (name) => stmt(
            call(
              "$.add_owner",
              call("$.get", member(this_instance, private_id(name))),
              id("owner"),
              literal(false),
              is_ignored(node, "ownership_invalid_binding") && true_instance
            )
          )
        ),
        true
      )
    );
  }
  return { ...node, body };
}
function get_name(node) {
  var _a2;
  if (node.type === "Literal") {
    return (_a2 = node.value) == null ? void 0 : _a2.toString().replace(regex_invalid_identifier_chars, "_");
  } else {
    return node.name;
  }
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/Comment.js
function Comment(node, context) {
  context.state.template.push(`<!--${node.data}-->`);
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/shared/component.js
function build_component(node, component_name, context, anchor = context.state.node) {
  var _a2, _b2;
  const props_and_spreads = [];
  const lets = [];
  const states = {
    default: {
      ...context.state,
      scope: node.metadata.scopes.default,
      transform: { ...context.state.transform }
    }
  };
  const children = {};
  const events = {};
  const custom_css_props = [];
  let bind_this = null;
  const binding_initializers = [];
  let slot_scope_applies_to_itself = !!determine_slot(node);
  let has_children_prop = false;
  function push_prop(prop2) {
    const current = props_and_spreads.at(-1);
    const current_is_props = Array.isArray(current);
    const props = current_is_props ? current : [];
    props.push(prop2);
    if (!current_is_props) {
      props_and_spreads.push(props);
    }
  }
  if (slot_scope_applies_to_itself) {
    for (const attribute of node.attributes) {
      if (attribute.type === "LetDirective") {
        lets.push(
          /** @type {ExpressionStatement} */
          context.visit(attribute)
        );
      }
    }
  }
  for (const attribute of node.attributes) {
    if (attribute.type === "LetDirective") {
      if (!slot_scope_applies_to_itself) {
        lets.push(
          /** @type {ExpressionStatement} */
          context.visit(attribute, states.default)
        );
      }
    } else if (attribute.type === "OnDirective") {
      if (!attribute.expression) {
        context.state.analysis.needs_props = true;
      }
      let handler = build_event_handler(
        attribute.expression,
        attribute.metadata.expression,
        context
      );
      if (attribute.modifiers.includes("once")) {
        handler = call("$.once", handler);
      }
      (events[_a2 = attribute.name] || (events[_a2] = [])).push(handler);
    } else if (attribute.type === "SpreadAttribute") {
      const expression = (
        /** @type {Expression} */
        context.visit(attribute)
      );
      if (attribute.metadata.expression.has_state) {
        let value = expression;
        if (attribute.metadata.expression.has_call) {
          const id2 = id(context.state.scope.generate("spread_element"));
          context.state.init.push(var_builder(id2, call("$.derived", thunk(value))));
          value = call("$.get", id2);
        }
        props_and_spreads.push(thunk(value));
      } else {
        props_and_spreads.push(expression);
      }
    } else if (attribute.type === "Attribute") {
      if (attribute.name.startsWith("--")) {
        custom_css_props.push(
          init(attribute.name, build_attribute_value2(attribute.value, context).value)
        );
        continue;
      }
      if (attribute.name === "slot") {
        slot_scope_applies_to_itself = true;
      }
      if (attribute.name === "children") {
        has_children_prop = true;
      }
      const { value } = build_attribute_value2(attribute.value, context);
      if (attribute.metadata.expression.has_state) {
        let arg = value;
        const should_wrap_in_derived = get_attribute_chunks(attribute.value).some((n) => {
          return n.type === "ExpressionTag" && n.expression.type !== "Identifier" && n.expression.type !== "MemberExpression";
        });
        if (should_wrap_in_derived) {
          const id2 = id(context.state.scope.generate(attribute.name));
          context.state.init.push(var_builder(id2, create_derived(context.state, thunk(value))));
          arg = call("$.get", id2);
        }
        push_prop(get(attribute.name, [return_builder(arg)]));
      } else {
        push_prop(init(attribute.name, value));
      }
    } else if (attribute.type === "BindDirective") {
      const expression = (
        /** @type {Expression} */
        context.visit(attribute.expression)
      );
      if (dev && expression.type === "MemberExpression" && context.state.analysis.runes && !is_ignored(node, "binding_property_non_reactive")) {
        validate_binding(context.state, attribute, expression);
      }
      if (attribute.name === "this") {
        bind_this = attribute.expression;
      } else {
        if (dev) {
          binding_initializers.push(
            stmt(
              call(
                id("$.add_owner_effect"),
                thunk(expression),
                id(component_name),
                is_ignored(node, "ownership_invalid_binding") && true_instance
              )
            )
          );
        }
        const is_store_sub = attribute.expression.type === "Identifier" && ((_b2 = context.state.scope.get(attribute.expression.name)) == null ? void 0 : _b2.kind) === "store_sub";
        if (is_store_sub) {
          push_prop(
            get(attribute.name, [stmt(call("$.mark_store_binding")), return_builder(expression)])
          );
        } else {
          push_prop(get(attribute.name, [return_builder(expression)]));
        }
        const assignment2 = assignment("=", attribute.expression, id("$$value"));
        push_prop(
          set(attribute.name, [stmt(
            /** @type {Expression} */
            context.visit(assignment2)
          )])
        );
      }
    }
  }
  if (slot_scope_applies_to_itself) {
    context.state.init.push(...lets);
  }
  if (Object.keys(events).length > 0) {
    const events_expression = object(
      Object.keys(events).map(
        (name) => init(name, events[name].length > 1 ? array(events[name]) : events[name][0])
      )
    );
    push_prop(init("$$events", events_expression));
  }
  const snippet_declarations = [];
  const serialized_slots = [];
  for (const child of node.fragment.nodes) {
    if (child.type === "SnippetBlock") {
      context.visit(child, {
        ...context.state,
        init: snippet_declarations
      });
      push_prop(prop("init", child.expression, child.expression));
      serialized_slots.push(
        init(child.expression.name === "children" ? "default" : child.expression.name, true_instance)
      );
      continue;
    }
    let slot_name = determine_slot(child) ?? "default";
    (children[slot_name] || (children[slot_name] = [])).push(child);
  }
  for (const slot_name of Object.keys(children)) {
    const block2 = (
      /** @type {BlockStatement} */
      context.visit(
        {
          ...node.fragment,
          // @ts-expect-error
          nodes: children[slot_name]
        },
        slot_name === "default" ? slot_scope_applies_to_itself ? context.state : states.default : {
          ...context.state,
          scope: node.metadata.scopes[slot_name],
          transform: { ...context.state.transform }
        }
      )
    );
    if (block2.body.length === 0) continue;
    const slot_fn = arrow(
      [id("$$anchor"), id("$$slotProps")],
      block([
        ...slot_name === "default" && !slot_scope_applies_to_itself ? lets : [],
        ...block2.body
      ])
    );
    if (slot_name === "default" && !has_children_prop) {
      if (lets.length === 0 && children.default.every(
        (node2) => node2.type !== "SvelteFragment" || !node2.attributes.some((attr) => attr.type === "LetDirective")
      )) {
        push_prop(
          init(
            "children",
            dev ? call("$.wrap_snippet", id(context.state.analysis.name), slot_fn) : slot_fn
          )
        );
        serialized_slots.push(init(slot_name, true_instance));
      } else {
        serialized_slots.push(init(slot_name, slot_fn));
        push_prop(init("children", id("$.invalid_default_snippet")));
      }
    } else {
      serialized_slots.push(init(slot_name, slot_fn));
    }
  }
  if (serialized_slots.length > 0) {
    push_prop(init("$$slots", object(serialized_slots)));
  }
  if (!context.state.analysis.runes && node.attributes.some((attribute) => attribute.type === "BindDirective")) {
    push_prop(init("$$legacy", true_instance));
  }
  const props_expression = props_and_spreads.length === 0 || props_and_spreads.length === 1 && Array.isArray(props_and_spreads[0]) ? object(
    /** @type {Property[]} */
    props_and_spreads[0] || []
  ) : call(
    "$.spread_props",
    ...props_and_spreads.map((p) => Array.isArray(p) ? object(p) : p)
  );
  let fn = (node_id) => {
    return call(
      // TODO We can remove this ternary once we remove legacy mode, since in runes mode dynamic components
      // will be handled separately through the `$.component` function, and then the component name will
      // always be referenced through just the identifier here.
      node.type === "SvelteComponent" ? component_name : (
        /** @type {Expression} */
        context.visit(member_id(component_name))
      ),
      node_id,
      props_expression
    );
  };
  if (bind_this !== null) {
    const prev = fn;
    fn = (node_id) => {
      return build_bind_this(bind_this, prev(node_id), context);
    };
  }
  const statements = [...snippet_declarations];
  if (node.type === "SvelteComponent") {
    const prev = fn;
    fn = (node_id) => {
      return call(
        "$.component",
        node_id,
        thunk(
          /** @type {Expression} */
          context.visit(node.expression)
        ),
        arrow(
          [id("$$anchor"), id(component_name)],
          block([...binding_initializers, stmt(prev(id("$$anchor")))])
        )
      );
    };
  } else {
    statements.push(...binding_initializers);
  }
  if (Object.keys(custom_css_props).length > 0) {
    context.state.template.push(
      context.state.metadata.namespace === "svg" ? "<g><!></g>" : '<svelte-css-wrapper style="display: contents"><!></svelte-css-wrapper>'
    );
    statements.push(
      stmt(call("$.css_props", anchor, thunk(object(custom_css_props)))),
      stmt(fn(member(anchor, "lastChild"))),
      stmt(call("$.reset", anchor))
    );
  } else {
    context.state.template.push("<!>");
    statements.push(stmt(fn(anchor)));
  }
  return statements.length > 1 ? block(statements) : statements[0];
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/Component.js
function Component3(node, context) {
  if (node.metadata.dynamic) {
    const component2 = build_component(node, "$$component", context, id("$$anchor"));
    context.state.init.push(
      stmt(
        call(
          "$.component",
          context.state.node,
          // TODO use untrack here to not update when binding changes?
          // Would align with Svelte 4 behavior, but it's arguably nicer/expected to update this
          thunk(
            /** @type {Expression} */
            context.visit(member_id(node.name))
          ),
          arrow([id("$$anchor"), id("$$component")], block([component2]))
        )
      )
    );
    return;
  }
  const component = build_component(node, node.name, context);
  context.state.init.push(component);
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/ConstTag.js
function ConstTag3(node, context) {
  const declaration2 = node.declaration.declarations[0];
  if (declaration2.id.type === "Identifier") {
    context.state.init.push(
      const_builder(
        declaration2.id,
        create_derived(
          context.state,
          thunk(
            /** @type {Expression} */
            context.visit(declaration2.init)
          )
        )
      )
    );
    context.state.transform[declaration2.id.name] = { read: get_value };
    if (dev) {
      context.state.init.push(stmt(call("$.get", declaration2.id)));
    }
  } else {
    const identifiers = extract_identifiers(declaration2.id);
    const tmp = id(context.state.scope.generate("computed_const"));
    const transform = { ...context.state.transform };
    for (const node2 of identifiers) {
      delete transform[node2.name];
    }
    const child_state = { ...context.state, transform };
    const fn = arrow(
      [],
      block([
        const_builder(
          /** @type {Pattern} */
          context.visit(declaration2.id, child_state),
          /** @type {Expression} */
          context.visit(declaration2.init, child_state)
        ),
        return_builder(object(identifiers.map((node2) => prop("init", node2, node2))))
      ])
    );
    context.state.init.push(const_builder(tmp, create_derived(context.state, fn)));
    if (dev) {
      context.state.init.push(stmt(call("$.get", tmp)));
    }
    for (const node2 of identifiers) {
      context.state.transform[node2.name] = {
        read: (node3) => member(call("$.get", tmp), node3)
      };
    }
  }
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/DebugTag.js
function DebugTag3(node, context) {
  const object4 = object(
    node.identifiers.map((identifier) => {
      const visited = call(
        "$.snapshot",
        /** @type {Expression} */
        context.visit(identifier)
      );
      return prop(
        "init",
        identifier,
        context.state.analysis.runes ? visited : call("$.untrack", thunk(visited))
      );
    })
  );
  const call2 = call("console.log", object4);
  context.state.init.push(
    stmt(call("$.template_effect", thunk(block([stmt(call2), debugger_builder]))))
  );
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/EachBlock.js
function EachBlock3(node, context) {
  var _a2, _b2;
  const each_node_meta = node.metadata;
  const collection = (
    /** @type {Expression} */
    context.visit(node.expression, {
      ...context.state,
      scope: (
        /** @type {Scope} */
        context.state.scope.parent
      )
    })
  );
  if (!each_node_meta.is_controlled) {
    context.state.template.push("<!>");
  }
  if (each_node_meta.array_name !== null) {
    context.state.init.push(const_builder(each_node_meta.array_name, thunk(collection)));
  }
  let flags = 0;
  if (node.metadata.keyed && node.index) {
    flags |= EACH_INDEX_REACTIVE;
  }
  const key_is_item = ((_a2 = node.key) == null ? void 0 : _a2.type) === "Identifier" && node.context.type === "Identifier" && node.context.name === node.key.name;
  let uses_store;
  for (const binding of node.metadata.expression.dependencies) {
    if (binding.kind === "store_sub") {
      uses_store = true;
      break;
    }
  }
  for (const binding of node.metadata.expression.dependencies) {
    if (binding.scope.function_depth >= context.state.scope.function_depth) {
      continue;
    }
    if (!context.state.analysis.runes || !key_is_item || uses_store) {
      flags |= EACH_ITEM_REACTIVE;
      break;
    }
  }
  if (context.state.analysis.runes && !uses_store) {
    flags |= EACH_ITEM_IMMUTABLE;
  }
  if (node.key && node.body.nodes.some((child) => {
    if (child.type !== "RegularElement" && child.type !== "SvelteElement") return false;
    return child.attributes.some((attr) => attr.type === "AnimateDirective");
  })) {
    flags |= EACH_IS_ANIMATED;
  }
  if (each_node_meta.is_controlled) {
    flags |= EACH_IS_CONTROLLED;
  }
  let store_to_invalidate = "";
  if (node.expression.type === "Identifier" || node.expression.type === "MemberExpression") {
    const id2 = object2(node.expression);
    if (id2) {
      const binding = context.state.scope.get(id2.name);
      if ((binding == null ? void 0 : binding.kind) === "store_sub") {
        store_to_invalidate = id2.name;
      }
    }
  }
  const indirect_dependencies = collect_parent_each_blocks(context).flatMap((block3) => {
    const array2 = (
      /** @type {Expression} */
      context.visit(block3.expression)
    );
    const transitive_dependencies = build_transitive_dependencies(
      block3.metadata.expression.dependencies,
      context
    );
    return [array2, ...transitive_dependencies];
  });
  if (each_node_meta.array_name) {
    indirect_dependencies.push(call(each_node_meta.array_name));
  } else {
    indirect_dependencies.push(collection);
    const transitive_dependencies = build_transitive_dependencies(
      each_node_meta.expression.dependencies,
      context
    );
    indirect_dependencies.push(...transitive_dependencies);
  }
  const child_state = {
    ...context.state,
    transform: { ...context.state.transform }
  };
  const key_state = {
    ...context.state,
    transform: { ...context.state.transform }
  };
  const index = each_node_meta.contains_group_binding || !node.index ? each_node_meta.index : id(node.index);
  const item = node.context.type === "Identifier" ? node.context : id("$$item");
  let uses_index = each_node_meta.contains_group_binding;
  let key_uses_index = false;
  if (node.index) {
    child_state.transform[node.index] = {
      read: (node2) => {
        uses_index = true;
        return (flags & EACH_INDEX_REACTIVE) !== 0 ? get_value(node2) : node2;
      }
    };
    key_state.transform[node.index] = {
      read: (node2) => {
        key_uses_index = true;
        return node2;
      }
    };
  }
  const declarations = [];
  const invalidate = call(
    "$.invalidate_inner_signals",
    thunk(sequence(indirect_dependencies))
  );
  const invalidate_store = store_to_invalidate ? call("$.invalidate_store", id("$$stores"), literal(store_to_invalidate)) : void 0;
  const sequence2 = [];
  if (!context.state.analysis.runes) sequence2.push(invalidate);
  if (invalidate_store) sequence2.push(invalidate_store);
  if (node.context.type === "Identifier") {
    const binding = (
      /** @type {Binding} */
      context.state.scope.get(node.context.name)
    );
    child_state.transform[node.context.name] = {
      read: (node2) => {
        if (binding.reassigned) {
          return member(
            each_node_meta.array_name ? call(each_node_meta.array_name) : collection,
            index,
            true
          );
        }
        return (flags & EACH_ITEM_REACTIVE) !== 0 ? get_value(node2) : node2;
      },
      assign: (_, value) => {
        uses_index = true;
        const left = member(
          each_node_meta.array_name ? call(each_node_meta.array_name) : collection,
          index,
          true
        );
        return sequence([assignment("=", left, value), ...sequence2]);
      },
      mutate: (_, mutation) => sequence([mutation, ...sequence2])
    };
    delete key_state.transform[node.context.name];
  } else {
    const unwrapped = (flags & EACH_ITEM_REACTIVE) !== 0 ? call("$.get", item) : item;
    for (const path of extract_paths(node.context)) {
      const name = (
        /** @type {Identifier} */
        path.node.name
      );
      const needs_derived = path.has_default_value;
      const fn = thunk(
        /** @type {Expression} */
        context.visit((_b2 = path.expression) == null ? void 0 : _b2.call(path, unwrapped), child_state)
      );
      declarations.push(let_builder(path.node, needs_derived ? call("$.derived_safe_equal", fn) : fn));
      const read = needs_derived ? get_value : call;
      child_state.transform[name] = {
        read,
        assign: (_, value) => {
          const left = (
            /** @type {Pattern} */
            path.update_expression(unwrapped)
          );
          return sequence([assignment("=", left, value), ...sequence2]);
        },
        mutate: (_, mutation) => {
          return sequence([mutation, ...sequence2]);
        }
      };
      if (dev) {
        declarations.push(stmt(read(id(name))));
      }
      delete key_state.transform[name];
    }
  }
  const block2 = (
    /** @type {BlockStatement} */
    context.visit(node.body, child_state)
  );
  let key_function = id("$.index");
  if (node.metadata.keyed) {
    const expression = (
      /** @type {Expression} */
      context.visit(
        /** @type {Expression} */
        node.key,
        key_state
      )
    );
    key_function = arrow(key_uses_index ? [node.context, index] : [node.context], expression);
  }
  if (node.index && each_node_meta.contains_group_binding) {
    declarations.push(let_builder(node.index, index));
  }
  if (dev && node.metadata.keyed) {
    context.state.init.push(
      stmt(call("$.validate_each_keys", thunk(collection), key_function))
    );
  }
  const args = [
    context.state.node,
    literal(flags),
    each_node_meta.array_name ? each_node_meta.array_name : thunk(collection),
    key_function,
    arrow(
      uses_index ? [id("$$anchor"), item, index] : [id("$$anchor"), item],
      block(declarations.concat(block2.body))
    )
  ];
  if (node.fallback) {
    args.push(
      arrow(
        [id("$$anchor")],
        /** @type {BlockStatement} */
        context.visit(node.fallback)
      )
    );
  }
  context.state.init.push(stmt(call("$.each", ...args)));
}
function collect_parent_each_blocks(context) {
  return (
    /** @type {AST.EachBlock[]} */
    context.path.filter((node) => node.type === "EachBlock")
  );
}
function build_transitive_dependencies(references, context) {
  const dependencies = /* @__PURE__ */ new Set();
  for (const ref of references) {
    const deps = collect_transitive_dependencies(ref);
    for (const dep of deps) {
      dependencies.add(dep);
    }
  }
  return [...dependencies].map((dep) => build_getter({ ...dep.node }, context.state));
}
function collect_transitive_dependencies(binding, seen = /* @__PURE__ */ new Set()) {
  if (binding.kind !== "legacy_reactive") return [];
  for (const dep of binding.legacy_dependencies) {
    if (!seen.has(dep)) {
      seen.add(dep);
      for (const transitive_dep of collect_transitive_dependencies(dep, seen)) {
        seen.add(transitive_dep);
      }
    }
  }
  return [...seen];
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/ExportNamedDeclaration.js
function ExportNamedDeclaration2(node, context) {
  if (context.state.is_instance) {
    if (node.declaration) {
      return context.visit(node.declaration);
    }
    return empty;
  }
  return context.next();
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/ExpressionStatement.js
function ExpressionStatement3(node, context) {
  if (node.expression.type === "CallExpression") {
    const rune = get_rune(node.expression, context.state.scope);
    if (rune === "$effect" || rune === "$effect.pre") {
      const callee = rune === "$effect" ? "$.user_effect" : "$.user_pre_effect";
      const func = (
        /** @type {Expression} */
        context.visit(node.expression.arguments[0])
      );
      const expr = call(
        callee,
        /** @type {Expression} */
        func
      );
      expr.callee.loc = node.expression.callee.loc;
      return stmt(expr);
    }
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/shared/fragment.js
function process_children2(nodes, initial, is_element, { visit, state }) {
  const within_bound_contenteditable = state.metadata.bound_contenteditable;
  let prev = initial;
  let skipped = 0;
  let sequence2 = [];
  function get_node(is_text) {
    if (skipped === 0) {
      return prev(is_text);
    }
    return call(
      "$.sibling",
      prev(false),
      (is_text || skipped !== 1) && literal(skipped),
      is_text && true_instance
    );
  }
  function flush_node(is_text, name) {
    const expression = get_node(is_text);
    let id2 = expression;
    if (id2.type !== "Identifier") {
      id2 = id(state.scope.generate(name));
      state.init.push(var_builder(id2, expression));
    }
    prev = () => id2;
    skipped = 1;
    return id2;
  }
  function flush_sequence(sequence3) {
    if (sequence3.every((node) => node.type === "Text")) {
      skipped += 1;
      state.template.push(sequence3.map((node) => node.raw).join(""));
      return;
    }
    state.template.push(" ");
    const { has_state, has_call, value } = build_template_literal(sequence3, visit, state);
    const is_text = sequence3.length === 1;
    const id2 = flush_node(is_text, "text");
    const update2 = stmt(call("$.set_text", id2, value));
    if (has_call && !within_bound_contenteditable) {
      state.init.push(build_update(update2));
    } else if (has_state && !within_bound_contenteditable) {
      state.update.push(update2);
    } else {
      state.init.push(stmt(assignment("=", member(id2, "nodeValue"), value)));
    }
  }
  for (const node of nodes) {
    if (node.type === "Text" || node.type === "ExpressionTag") {
      sequence2.push(node);
    } else {
      if (sequence2.length > 0) {
        flush_sequence(sequence2);
        sequence2 = [];
      }
      let child_state = state;
      if (is_static_element2(node)) {
        skipped += 1;
      } else if (node.type === "EachBlock" && nodes.length === 1 && is_element) {
        node.metadata.is_controlled = true;
      } else {
        const id2 = flush_node(false, node.type === "RegularElement" ? node.name : "node");
        child_state = { ...state, node: id2 };
      }
      visit(node, child_state);
    }
  }
  if (sequence2.length > 0) {
    flush_sequence(sequence2);
  }
  if (skipped > 1) {
    skipped -= 1;
    state.init.push(stmt(call("$.next", skipped !== 1 && literal(skipped))));
  }
}
function is_static_element2(node) {
  if (node.type !== "RegularElement") return false;
  if (node.fragment.metadata.dynamic) return false;
  for (const attribute of node.attributes) {
    if (attribute.type !== "Attribute") {
      return false;
    }
    if (is_event_attribute(attribute)) {
      return false;
    }
    if (attribute.value !== true && !is_text_attribute(attribute)) {
      return false;
    }
    if (attribute.name === "autofocus" || attribute.name === "muted") {
      return false;
    }
    if (node.name === "option" && attribute.name === "value") {
      return false;
    }
    if (node.name.includes("-")) {
      return false;
    }
  }
  return true;
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/Fragment.js
function Fragment2(node, context) {
  const parent = context.path.at(-1) ?? node;
  const namespace = infer_namespace(context.state.metadata.namespace, parent, node.nodes);
  const { hoisted, trimmed, is_standalone, is_text_first } = clean_nodes(
    parent,
    node.nodes,
    context.path,
    namespace,
    context.state,
    context.state.preserve_whitespace,
    context.state.options.preserveComments
  );
  if (hoisted.length === 0 && trimmed.length === 0) {
    return block([]);
  }
  const is_single_element = trimmed.length === 1 && trimmed[0].type === "RegularElement";
  const is_single_child_not_needing_template = trimmed.length === 1 && (trimmed[0].type === "SvelteFragment" || trimmed[0].type === "TitleElement");
  const template_name = context.state.scope.root.unique("root");
  const body = [];
  let close2 = void 0;
  const state = {
    ...context.state,
    before_init: [],
    init: [],
    update: [],
    after_update: [],
    template: [],
    locations: [],
    transform: { ...context.state.transform },
    metadata: {
      context: {
        template_needs_import_node: false,
        template_contains_script_tag: false
      },
      namespace,
      bound_contenteditable: context.state.metadata.bound_contenteditable
    }
  };
  for (const node2 of hoisted) {
    context.visit(node2, state);
  }
  if (is_text_first) {
    body.push(stmt(call("$.next")));
  }
  const add_template = (template_name2, args) => {
    let call2 = call(get_template_function(namespace, state), ...args);
    if (dev) {
      call2 = call(
        "$.add_locations",
        call2,
        member(id(context.state.analysis.name), "$.FILENAME", true),
        build_locations(state.locations)
      );
    }
    context.state.hoisted.push(var_builder(template_name2, call2));
  };
  if (is_single_element) {
    const element2 = (
      /** @type {AST.RegularElement} */
      trimmed[0]
    );
    const id2 = id(context.state.scope.generate(element2.name));
    context.visit(element2, {
      ...state,
      node: id2
    });
    const args = [join_template(state.template)];
    if (state.metadata.context.template_needs_import_node) {
      args.push(literal(TEMPLATE_USE_IMPORT_NODE));
    }
    add_template(template_name, args);
    body.push(var_builder(id2, call(template_name)), ...state.before_init, ...state.init);
    close2 = stmt(call("$.append", id("$$anchor"), id2));
  } else if (is_single_child_not_needing_template) {
    context.visit(trimmed[0], state);
    body.push(...state.before_init, ...state.init);
  } else if (trimmed.length === 1 && trimmed[0].type === "Text") {
    const id2 = id(context.state.scope.generate("text"));
    body.push(
      var_builder(id2, call("$.text", literal(trimmed[0].data))),
      ...state.before_init,
      ...state.init
    );
    close2 = stmt(call("$.append", id("$$anchor"), id2));
  } else if (trimmed.length > 0) {
    const id2 = id(context.state.scope.generate("fragment"));
    const use_space_template = trimmed.some((node2) => node2.type === "ExpressionTag") && trimmed.every((node2) => node2.type === "Text" || node2.type === "ExpressionTag");
    if (use_space_template) {
      const id3 = id(context.state.scope.generate("text"));
      process_children2(trimmed, () => id3, false, {
        ...context,
        state
      });
      body.push(var_builder(id3, call("$.text")), ...state.before_init, ...state.init);
      close2 = stmt(call("$.append", id("$$anchor"), id3));
    } else {
      if (is_standalone) {
        process_children2(trimmed, () => id("$$anchor"), false, { ...context, state });
      } else {
        const expression = (is_text) => call("$.first_child", id2, is_text && true_instance);
        process_children2(trimmed, expression, false, { ...context, state });
        let flags = TEMPLATE_FRAGMENT;
        if (state.metadata.context.template_needs_import_node) {
          flags |= TEMPLATE_USE_IMPORT_NODE;
        }
        if (state.template.length === 1 && state.template[0] === "<!>") {
          body.push(var_builder(id2, call("$.comment")));
        } else {
          add_template(template_name, [join_template(state.template), literal(flags)]);
          body.push(var_builder(id2, call(template_name)));
        }
        close2 = stmt(call("$.append", id("$$anchor"), id2));
      }
      body.push(...state.before_init, ...state.init);
    }
  } else {
    body.push(...state.before_init, ...state.init);
  }
  if (state.update.length > 0) {
    body.push(build_render_statement(state.update));
  }
  body.push(...state.after_update);
  if (close2 !== void 0) {
    body.push(close2);
  }
  return block(body);
}
function join_template(items) {
  let quasi2 = quasi("");
  const template3 = template([quasi2], []);
  for (const item of items) {
    if (typeof item === "string") {
      quasi2.value.cooked += item;
    } else {
      template3.expressions.push(item);
      template3.quasis.push(quasi2 = quasi(""));
    }
  }
  for (const quasi3 of template3.quasis) {
    quasi3.value.raw = sanitize_template_string(
      /** @type {string} */
      quasi3.value.cooked
    );
  }
  quasi2.tail = true;
  return template3;
}
function get_template_function(namespace, state) {
  const contains_script_tag = state.metadata.context.template_contains_script_tag;
  return namespace === "svg" ? contains_script_tag ? "$.svg_template_with_script" : "$.ns_template" : namespace === "mathml" ? "$.mathml_template" : contains_script_tag ? "$.template_with_script" : "$.template";
}
function build_locations(locations) {
  return array(
    locations.map((loc) => {
      const expression = array([literal(loc[0]), literal(loc[1])]);
      if (loc.length === 3) {
        expression.elements.push(build_locations(loc[2]));
      }
      return expression;
    })
  );
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/FunctionDeclaration.js
function FunctionDeclaration2(node, context) {
  var _a2;
  const state = { ...context.state, in_constructor: false };
  if (((_a2 = node.metadata) == null ? void 0 : _a2.hoisted) === true) {
    const params = build_hoisted_params(node, context);
    const body = context.visit(node.body, state);
    context.state.hoisted.push(
      /** @type {FunctionDeclaration} */
      { ...node, params, body }
    );
    return empty;
  }
  context.next(state);
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/FunctionExpression.js
function FunctionExpression2(node, context) {
  return visit_function2(node, context);
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/HtmlTag.js
function HtmlTag3(node, context) {
  context.state.template.push("<!>");
  context.state.init.push(
    stmt(
      call(
        "$.html",
        context.state.node,
        thunk(
          /** @type {Expression} */
          context.visit(node.expression)
        ),
        literal(context.state.metadata.namespace === "svg"),
        literal(context.state.metadata.namespace === "mathml"),
        is_ignored(node, "hydration_html_changed") && true_instance
      )
    )
  );
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/Identifier.js
function Identifier3(node, context) {
  const parent = (
    /** @type {Node} */
    context.path.at(-1)
  );
  if (is_reference(node, parent)) {
    if (node.name === "$$props") {
      return id("$$sanitized_props");
    }
    const binding = context.state.scope.get(node.name);
    if (context.state.analysis.runes && // can't do this in legacy mode because the proxy does more than just read/write
    binding !== null && node !== binding.node && binding.kind === "rest_prop") {
      const grand_parent = context.path.at(-2);
      if ((parent == null ? void 0 : parent.type) === "MemberExpression" && !parent.computed && (grand_parent == null ? void 0 : grand_parent.type) !== "AssignmentExpression" && (grand_parent == null ? void 0 : grand_parent.type) !== "UpdateExpression") {
        return id("$$props");
      }
    }
    return build_getter(node, context.state);
  }
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/IfBlock.js
function IfBlock3(node, context) {
  context.state.template.push("<!>");
  const consequent = (
    /** @type {BlockStatement} */
    context.visit(node.consequent)
  );
  const args = [
    context.state.node,
    thunk(
      /** @type {Expression} */
      context.visit(node.test)
    ),
    arrow([id("$$anchor")], consequent)
  ];
  if (node.alternate || node.elseif) {
    args.push(
      node.alternate ? arrow(
        [id("$$anchor")],
        /** @type {BlockStatement} */
        context.visit(node.alternate)
      ) : literal(null)
    );
  }
  if (node.elseif) {
    args.push(literal(true));
  }
  context.state.init.push(stmt(call("$.if", ...args)));
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/ImportDeclaration.js
function ImportDeclaration2(node, context) {
  if ("hoisted" in context.state) {
    context.state.hoisted.push(node);
    return empty;
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/KeyBlock.js
function KeyBlock3(node, context) {
  context.state.template.push("<!>");
  const key2 = (
    /** @type {Expression} */
    context.visit(node.expression)
  );
  const body = (
    /** @type {Expression} */
    context.visit(node.fragment)
  );
  context.state.init.push(
    stmt(call("$.key", context.state.node, thunk(key2), arrow([id("$$anchor")], body)))
  );
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/LabeledStatement.js
function LabeledStatement3(node, context) {
  if (context.state.analysis.runes || context.path.length > 1 || node.label.name !== "$") {
    context.next();
    return;
  }
  const reactive_statement = (
    /** @type {ReactiveStatement} */
    context.state.analysis.reactive_statements.get(node)
  );
  if (!reactive_statement) return;
  let serialized_body = (
    /** @type {Statement} */
    context.visit(node.body)
  );
  if (serialized_body.type !== "BlockStatement") {
    serialized_body = block([serialized_body]);
  }
  const body = serialized_body.body;
  const sequence2 = [];
  for (const binding of reactive_statement.dependencies) {
    if (binding.kind === "normal" && binding.declaration_kind !== "import") continue;
    const name = binding.node.name;
    let serialized = build_getter(id(name), context.state);
    if (name === "$$props" || name === "$$restProps" || binding.kind === "bindable_prop") {
      serialized = call("$.deep_read_state", serialized);
    }
    sequence2.push(serialized);
  }
  context.state.legacy_reactive_statements.set(
    node,
    stmt(
      call(
        "$.legacy_pre_effect",
        sequence2.length > 0 ? thunk(sequence(sequence2)) : thunk(block([])),
        thunk(block(body))
      )
    )
  );
  return empty;
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/LetDirective.js
function LetDirective2(node, context) {
  if (node.expression && node.expression.type !== "Identifier") {
    const name = context.state.scope.generate(node.name);
    const bindings = context.state.scope.get_bindings(node);
    for (const binding of bindings) {
      context.state.transform[binding.node.name] = {
        read: (node2) => member(call("$.get", id(name)), node2)
      };
    }
    return const_builder(
      name,
      call(
        "$.derived",
        thunk(
          block([
            let_builder(
              /** @type {Expression} */
              node.expression.type === "ObjectExpression" ? (
                // @ts-expect-error types don't match, but it can't contain spread elements and the structure is otherwise fine
                object_pattern(node.expression.properties)
              ) : (
                // @ts-expect-error types don't match, but it can't contain spread elements and the structure is otherwise fine
                array_pattern(node.expression.elements)
              ),
              member(id("$$slotProps"), node.name)
            ),
            return_builder(object(bindings.map((binding) => init(binding.node.name, binding.node))))
          ])
        )
      )
    );
  } else {
    const name = node.expression === null ? node.name : node.expression.name;
    context.state.transform[name] = {
      read: (node2) => call("$.get", node2)
    };
    return const_builder(
      name,
      create_derived(context.state, thunk(member(id("$$slotProps"), node.name)))
    );
  }
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/MemberExpression.js
function MemberExpression3(node, context) {
  if (node.property.type === "PrivateIdentifier") {
    const field = context.state.private_state.get(node.property.name);
    if (field) {
      return context.state.in_constructor ? member(node, "v") : call("$.get", node);
    }
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/OnDirective.js
var modifiers = [
  "stopPropagation",
  "stopImmediatePropagation",
  "preventDefault",
  "self",
  "trusted",
  "once"
];
function OnDirective2(node, context) {
  if (!node.expression) {
    context.state.analysis.needs_props = true;
  }
  let handler = build_event_handler(node.expression, node.metadata.expression, context);
  for (const modifier of modifiers) {
    if (node.modifiers.includes(modifier)) {
      handler = call("$." + modifier, handler);
    }
  }
  const capture = node.modifiers.includes("capture");
  const passive = node.modifiers.includes("passive") || (node.modifiers.includes("nonpassive") ? false : void 0);
  return build_event(node.name, context.state.node, handler, capture, passive);
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/Program.js
function Program(_, context) {
  if (!context.state.analysis.runes) {
    context.state.transform["$$props"] = {
      read: (node) => ({ ...node, name: "$$sanitized_props" })
    };
    for (const [name, binding] of context.state.scope.declarations) {
      if (binding.declaration_kind === "import" && binding.mutated) {
        const { start, end } = context.state.analysis.instance.ast;
        const node = (
          /** @type {ImportDeclaration} */
          binding.initial
        );
        const is_instance_import = (
          /** @type {number} */
          node.start > /** @type {number} */
          start && /** @type {number} */
          node.end < /** @type {number} */
          end
        );
        if (is_instance_import) {
          const id2 = id("$$_import_" + name);
          context.state.transform[name] = {
            read: (_2) => call(id2),
            mutate: (_2, mutation) => call(id2, mutation)
          };
          context.state.legacy_reactive_imports.push(
            var_builder(id2, call("$.reactive_import", thunk(id(name))))
          );
        }
      }
    }
  }
  for (const [name, binding] of context.state.scope.declarations) {
    if (binding.kind === "store_sub") {
      let cached;
      const get_store = () => {
        return cached ?? (cached = /** @type {Expression} */
        context.visit(id(name.slice(1))));
      };
      context.state.transform[name] = {
        read: call,
        assign: (_2, value) => call("$.store_set", get_store(), value),
        mutate: (node, mutation) => {
          const untracked = call("$.untrack", node);
          function replace(n) {
            if (n.type === "MemberExpression") {
              return {
                ...n,
                object: replace(
                  /** @type {Expression} */
                  n.object
                ),
                property: n.property
              };
            }
            return untracked;
          }
          return call(
            "$.store_mutate",
            get_store(),
            assignment(
              mutation.operator,
              /** @type {MemberExpression} */
              replace(
                /** @type {MemberExpression} */
                mutation.left
              ),
              mutation.right
            ),
            untracked
          );
        },
        update: (node) => {
          return call(
            node.prefix ? "$.update_pre_store" : "$.update_store",
            build_getter(id(name.slice(1)), context.state),
            call(node.argument),
            node.operator === "--" && literal(-1)
          );
        }
      };
    }
    if (binding.kind === "prop" || binding.kind === "bindable_prop") {
      if (is_prop_source(binding, context.state)) {
        context.state.transform[name] = {
          read: call,
          assign: (node, value) => call(node, value),
          mutate: (node, value) => {
            if (binding.kind === "bindable_prop") {
              return call(node, value, true_instance);
            }
            return value;
          },
          update: (node) => {
            return call(
              node.prefix ? "$.update_pre_prop" : "$.update_prop",
              node.argument,
              node.operator === "--" && literal(-1)
            );
          }
        };
      } else if (binding.prop_alias) {
        const key2 = key(binding.prop_alias);
        context.state.transform[name] = {
          read: (_2) => member(id("$$props"), key2, key2.type === "Literal")
        };
      } else {
        context.state.transform[name] = {
          read: (node) => member(id("$$props"), node)
        };
      }
    }
  }
  add_state_transformers(context);
  context.next();
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/RegularElement.js
function RegularElement3(node, context) {
  let location = [-1, -1];
  if (dev) {
    const loc = locator(node.start);
    if (loc) {
      location[0] = loc.line;
      location[1] = loc.column;
      context.state.locations.push(location);
    }
  }
  if (node.name === "noscript") {
    context.state.template.push("<noscript></noscript>");
    return;
  }
  const is_custom_element = is_custom_element_node(node);
  if (is_custom_element) {
    context.state.metadata.context.template_needs_import_node = true;
  }
  if (node.name === "script") {
    context.state.metadata.context.template_contains_script_tag = true;
  }
  context.state.template.push(`<${node.name}`);
  const attributes = [];
  const class_directives = [];
  const style_directives = [];
  const other_directives = [];
  const lets = [];
  const lookup = /* @__PURE__ */ new Map();
  const bindings = /* @__PURE__ */ new Map();
  let has_spread = node.metadata.has_spread;
  let has_use = false;
  for (const attribute of node.attributes) {
    switch (attribute.type) {
      case "AnimateDirective":
        other_directives.push(attribute);
        break;
      case "Attribute":
        if (attribute.name === "is" && context.state.metadata.namespace === "html") {
          const { value } = build_attribute_value2(attribute.value, context);
          if (value.type === "Literal" && typeof value.value === "string") {
            context.state.template.push(` is="${escape_html(value.value, true)}"`);
            continue;
          }
        }
        attributes.push(attribute);
        lookup.set(attribute.name, attribute);
        break;
      case "BindDirective":
        bindings.set(attribute.name, attribute);
        other_directives.push(attribute);
        break;
      case "ClassDirective":
        class_directives.push(attribute);
        break;
      case "LetDirective":
        lets.push(
          /** @type {ExpressionStatement} */
          context.visit(attribute)
        );
        break;
      case "OnDirective":
        other_directives.push(attribute);
        break;
      case "SpreadAttribute":
        attributes.push(attribute);
        break;
      case "StyleDirective":
        style_directives.push(attribute);
        break;
      case "TransitionDirective":
        other_directives.push(attribute);
        break;
      case "UseDirective":
        has_use = true;
        other_directives.push(attribute);
        break;
    }
  }
  const element_state = { ...context.state, init: [], after_update: [] };
  for (const attribute of other_directives) {
    if (attribute.type === "OnDirective") {
      const handler = (
        /** @type {Expression} */
        context.visit(attribute)
      );
      if (has_use) {
        element_state.init.push(stmt(call("$.effect", thunk(handler))));
      } else {
        element_state.after_update.push(stmt(handler));
      }
    } else {
      context.visit(attribute, element_state);
    }
  }
  if (node.name === "input" && (has_spread || bindings.has("value") || bindings.has("checked") || bindings.has("group") || attributes.some(
    (attribute) => attribute.type === "Attribute" && (attribute.name === "value" || attribute.name === "checked") && !is_text_attribute(attribute)
  ))) {
    context.state.init.push(stmt(call("$.remove_input_defaults", context.state.node)));
  }
  if (node.name === "textarea") {
    const attribute = lookup.get("value") ?? lookup.get("checked");
    const needs_content_reset = attribute && !is_text_attribute(attribute);
    if (has_spread || bindings.has("value") || needs_content_reset) {
      context.state.init.push(stmt(call("$.remove_textarea_child", context.state.node)));
    }
  }
  if (node.name === "select" && bindings.has("value")) {
    setup_select_synchronization(
      /** @type {AST.BindDirective} */
      bindings.get("value"),
      context
    );
  }
  context.state.init.push(...lets);
  const node_id = context.state.node;
  let is_attributes_reactive = has_spread;
  if (has_spread) {
    const attributes_id = id(context.state.scope.generate("attributes"));
    build_set_attributes(
      attributes,
      context,
      node,
      node_id,
      attributes_id,
      (node.metadata.svg || node.metadata.mathml || is_custom_element_node(node)) && true_instance,
      node.name.includes("-") && true_instance,
      context.state
    );
    if (node.name === "select" && !bindings.has("value")) {
      context.state.init.push(
        stmt(call("$.init_select", node_id, thunk(member(attributes_id, "value"))))
      );
      context.state.update.push(
        if_builder(
          binary("in", literal("value"), attributes_id),
          block([
            // This ensures a one-way street to the DOM in case it's <select {value}>
            // and not <select bind:value>. We need it in addition to $.init_select
            // because the select value is not reflected as an attribute, so the
            // mutation observer wouldn't notice.
            stmt(call("$.select_option", node_id, member(attributes_id, "value")))
          ])
        )
      );
    }
  } else {
    const needs_special_value_handling = node.name === "option" || node.name === "select" || bindings.has("group") || bindings.has("checked");
    for (
      const attribute of
      /** @type {AST.Attribute[]} */
      attributes
    ) {
      if (is_event_attribute(attribute)) {
        visit_event_attribute(attribute, context);
        continue;
      }
      if (needs_special_value_handling && attribute.name === "value") {
        build_element_special_value_attribute(node.name, node_id, attribute, context);
        continue;
      }
      if (!is_custom_element && attribute.name !== "autofocus" && attribute.name !== "muted" && (attribute.value === true || is_text_attribute(attribute))) {
        const name = get_attribute_name2(node, attribute);
        const value = is_text_attribute(attribute) ? attribute.value[0].data : true;
        if (name !== "class" || value) {
          context.state.template.push(
            ` ${attribute.name}${is_boolean_attribute(name) && value === true ? "" : `="${value === true ? "" : escape_html(value, true)}"`}`
          );
        }
        continue;
      }
      const is = is_custom_element ? build_custom_element_attribute_update_assignment(node_id, attribute, context) : build_element_attribute_update_assignment(node, node_id, attribute, context);
      if (is) is_attributes_reactive = true;
    }
  }
  build_class_directives2(class_directives, node_id, context, is_attributes_reactive);
  build_style_directives2(style_directives, node_id, context, is_attributes_reactive);
  if (node.name === "img" && (has_spread || lookup.has("loading"))) {
    context.state.after_update.push(stmt(call("$.handle_lazy_img", node_id)));
  }
  if (is_load_error_element(node.name) && (has_spread || has_use || lookup.has("onload") || lookup.has("onerror"))) {
    context.state.after_update.push(stmt(call("$.replay_events", node_id)));
  }
  context.state.template.push(">");
  const metadata = {
    ...context.state.metadata,
    namespace: determine_namespace_for_children(node, context.state.metadata.namespace)
  };
  if (bindings.has("innerHTML") || bindings.has("innerText") || bindings.has("textContent")) {
    const contenteditable = lookup.get("contenteditable");
    if (contenteditable && (contenteditable.value === true || is_text_attribute(contenteditable) && contenteditable.value[0].data === "true")) {
      metadata.bound_contenteditable = true;
    }
  }
  const state = {
    ...context.state,
    metadata,
    locations: [],
    scope: (
      /** @type {Scope} */
      context.state.scopes.get(node.fragment)
    ),
    preserve_whitespace: context.state.preserve_whitespace || node.name === "pre" || node.name === "textarea"
  };
  const { hoisted, trimmed } = clean_nodes(
    node,
    node.fragment.nodes,
    context.path,
    state.metadata.namespace,
    state,
    node.name === "script" || state.preserve_whitespace,
    state.options.preserveComments
  );
  const child_state = { ...state, init: [], update: [], after_update: [] };
  for (const node2 of hoisted) {
    context.visit(node2, child_state);
  }
  const states_and_calls = trimmed.every((node2) => node2.type === "Text" || node2.type === "ExpressionTag") && trimmed.some((node2) => node2.type === "ExpressionTag") && get_states_and_calls(trimmed);
  if (states_and_calls && states_and_calls.states === 0) {
    child_state.init.push(
      stmt(
        assignment(
          "=",
          member(context.state.node, "textContent"),
          build_template_literal(trimmed, context.visit, child_state).value
        )
      )
    );
  } else {
    let arg = context.state.node;
    let needs_reset = trimmed.some((node2) => node2.type !== "Text");
    if (node.name === "template") {
      needs_reset = true;
      child_state.init.push(stmt(call("$.hydrate_template", arg)));
      arg = member(arg, "content");
    }
    process_children2(trimmed, (is_text) => call("$.child", arg, is_text && true_instance), true, {
      ...context,
      state: child_state
    });
    if (needs_reset) {
      child_state.init.push(stmt(call("$.reset", context.state.node)));
    }
  }
  if (node.fragment.nodes.some((node2) => node2.type === "SnippetBlock")) {
    context.state.init.push(
      block([
        ...child_state.init,
        ...element_state.init,
        child_state.update.length > 0 ? build_render_statement(child_state.update) : empty,
        ...child_state.after_update,
        ...element_state.after_update
      ])
    );
  } else if (node.fragment.metadata.dynamic) {
    context.state.init.push(...child_state.init, ...element_state.init);
    context.state.update.push(...child_state.update);
    context.state.after_update.push(...child_state.after_update, ...element_state.after_update);
  } else {
    context.state.init.push(...element_state.init);
    context.state.after_update.push(...element_state.after_update);
  }
  if (lookup.has("dir")) {
    const dir = member(node_id, "dir");
    context.state.update.push(stmt(assignment("=", dir, dir)));
  }
  if (state.locations.length > 0) {
    location.push(state.locations);
  }
  if (!is_void(node.name)) {
    context.state.template.push(`</${node.name}>`);
  }
}
function setup_select_synchronization(value_binding, context) {
  if (context.state.analysis.runes) return;
  let bound = value_binding.expression;
  while (bound.type === "MemberExpression") {
    bound = /** @type {Identifier | MemberExpression} */
    bound.object;
  }
  const names = [];
  for (const [name, refs] of context.state.scope.references) {
    if (refs.length > 0 && // prevent infinite loop
    name !== bound.name) {
      names.push(name);
    }
  }
  const invalidator = call(
    "$.invalidate_inner_signals",
    thunk(
      block(
        names.map((name) => {
          const serialized = build_getter(id(name), context.state);
          return stmt(serialized);
        })
      )
    )
  );
  context.state.init.push(
    stmt(
      call(
        "$.template_effect",
        thunk(
          block([
            stmt(
              /** @type {Expression} */
              context.visit(value_binding.expression)
            ),
            stmt(invalidator)
          ])
        )
      )
    )
  );
}
function build_element_attribute_update_assignment(element2, node_id, attribute, context) {
  const state = context.state;
  const name = get_attribute_name2(element2, attribute);
  const is_svg2 = context.state.metadata.namespace === "svg" || element2.name === "svg";
  const is_mathml2 = context.state.metadata.namespace === "mathml";
  let { has_call, value } = build_attribute_value2(attribute.value, context);
  if (name === "autofocus") {
    state.init.push(stmt(call("$.autofocus", node_id, value)));
    return false;
  }
  if (name === "muted") {
    state.init.push(stmt(assignment("=", member(node_id, id("muted")), value)));
    return false;
  }
  let update2;
  if (name === "class") {
    if (attribute.metadata.expression.has_state && has_call) {
      const id2 = id(state.scope.generate("class_derived"));
      state.init.push(const_builder(id2, create_derived(state, thunk(value))));
      value = call("$.get", id2);
      has_call = false;
    }
    update2 = stmt(
      call(
        is_svg2 ? "$.set_svg_class" : is_mathml2 ? "$.set_mathml_class" : "$.set_class",
        node_id,
        value
      )
    );
  } else if (name === "value") {
    update2 = stmt(call("$.set_value", node_id, value));
  } else if (name === "checked") {
    update2 = stmt(call("$.set_checked", node_id, value));
  } else if (is_dom_property(name)) {
    update2 = stmt(assignment("=", member(node_id, name), value));
  } else {
    if (name === "style" && attribute.metadata.expression.has_state && has_call) {
      const id2 = id(state.scope.generate("style_derived"));
      state.init.push(const_builder(id2, create_derived(state, thunk(value))));
      value = call("$.get", id2);
      has_call = false;
    }
    const callee = name.startsWith("xlink") ? "$.set_xlink_attribute" : "$.set_attribute";
    update2 = stmt(
      call(
        callee,
        node_id,
        literal(name),
        value,
        is_ignored(element2, "hydration_attribute_changed") && true_instance
      )
    );
  }
  const inlinable_expression = attribute.value === true ? false : is_inlinable_expression(
    Array.isArray(attribute.value) ? attribute.value : [attribute.value],
    context.state
  );
  if (attribute.metadata.expression.has_state) {
    if (has_call) {
      state.init.push(build_update(update2));
    } else {
      state.update.push(update2);
    }
    return true;
  } else {
    if (inlinable_expression) {
      context.state.template.push(` ${name}="`, value, '"');
    } else {
      state.init.push(update2);
    }
    return false;
  }
}
function is_inlinable_expression(nodes, state) {
  var _a2;
  let has_expression_tag = false;
  for (let value of nodes) {
    if (value.type === "ExpressionTag") {
      if (value.expression.type === "Identifier") {
        const binding = (_a2 = state.scope.owner(value.expression.name)) == null ? void 0 : _a2.declarations.get(value.expression.name);
        if (!can_inline_variable(binding)) {
          return false;
        }
      } else {
        return false;
      }
      has_expression_tag = true;
    }
  }
  return has_expression_tag;
}
function build_custom_element_attribute_update_assignment(node_id, attribute, context) {
  const state = context.state;
  const name = attribute.name;
  let { has_call, value } = build_attribute_value2(attribute.value, context);
  const update2 = stmt(call("$.set_custom_element_data", node_id, literal(name), value));
  if (attribute.metadata.expression.has_state) {
    if (has_call) {
      state.init.push(build_update(update2));
    } else {
      state.update.push(update2);
    }
    return true;
  } else {
    state.init.push(update2);
    return false;
  }
}
function build_element_special_value_attribute(element2, node_id, attribute, context) {
  const state = context.state;
  const { value } = build_attribute_value2(attribute.value, context);
  const inner_assignment = assignment(
    "=",
    member(node_id, "value"),
    conditional(
      binary("==", literal(null), assignment("=", member(node_id, "__value"), value)),
      literal(""),
      // render null/undefined values as empty string to support placeholder options
      value
    )
  );
  const is_select_with_value = (
    // attribute.metadata.dynamic would give false negatives because even if the value does not change,
    // the inner options could still change, so we need to always treat it as reactive
    element2 === "select" && attribute.value !== true && !is_text_attribute(attribute)
  );
  const update2 = stmt(
    is_select_with_value ? sequence([
      inner_assignment,
      // This ensures a one-way street to the DOM in case it's <select {value}>
      // and not <select bind:value>. We need it in addition to $.init_select
      // because the select value is not reflected as an attribute, so the
      // mutation observer wouldn't notice.
      call("$.select_option", node_id, value)
    ]) : inner_assignment
  );
  if (is_select_with_value) {
    state.init.push(stmt(call("$.init_select", node_id, thunk(value))));
  }
  if (attribute.metadata.expression.has_state) {
    const id2 = state.scope.generate(`${node_id.name}_value`);
    build_update_assignment(
      state,
      id2,
      // `<option>` is a special case: The value property reflects to the DOM. If the value is set to undefined,
      // that means the value should be set to the empty string. To be able to do that when the value is
      // initially undefined, we need to set a value that is guaranteed to be different.
      element2 === "option" ? object([]) : void 0,
      value,
      update2
    );
    return true;
  } else {
    state.init.push(update2);
    return false;
  }
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/RenderTag.js
function RenderTag3(node, context) {
  context.state.template.push("<!>");
  const callee = unwrap_optional(node.expression).callee;
  const raw_args = unwrap_optional(node.expression).arguments;
  let args = [];
  for (let i = 0; i < raw_args.length; i++) {
    const raw = raw_args[i];
    const arg = (
      /** @type {Expression} */
      context.visit(raw)
    );
    if (node.metadata.args_with_call_expression.has(i)) {
      const id2 = id(context.state.scope.generate("render_arg"));
      context.state.init.push(var_builder(id2, call("$.derived_safe_equal", thunk(arg))));
      args.push(thunk(call("$.get", id2)));
    } else {
      args.push(thunk(arg));
    }
  }
  let snippet_function = (
    /** @type {Expression} */
    context.visit(callee)
  );
  if (node.metadata.dynamic) {
    if (node.expression.type === "ChainExpression") {
      snippet_function = logical("??", snippet_function, id("$.noop"));
    }
    context.state.init.push(
      stmt(call("$.snippet", context.state.node, thunk(snippet_function), ...args))
    );
  } else {
    context.state.init.push(
      stmt(
        (node.expression.type === "CallExpression" ? call : maybe_call)(
          snippet_function,
          context.state.node,
          ...args
        )
      )
    );
  }
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/SlotElement.js
function SlotElement3(node, context) {
  context.state.template.push("<!>");
  const props = [];
  const spreads = [];
  const lets = [];
  let is_default = true;
  let name = literal("default");
  for (const attribute of node.attributes) {
    if (attribute.type === "SpreadAttribute") {
      spreads.push(thunk(
        /** @type {Expression} */
        context.visit(attribute)
      ));
    } else if (attribute.type === "Attribute") {
      const { value } = build_attribute_value2(attribute.value, context);
      if (attribute.name === "name") {
        name = /** @type {Literal} */
        value;
        is_default = false;
      } else if (attribute.name !== "slot") {
        if (attribute.metadata.expression.has_state) {
          props.push(get(attribute.name, [return_builder(value)]));
        } else {
          props.push(init(attribute.name, value));
        }
      }
    } else if (attribute.type === "LetDirective") {
      lets.push(
        /** @type {ExpressionStatement} */
        context.visit(attribute)
      );
    }
  }
  context.state.init.push(...lets);
  const props_expression = spreads.length === 0 ? object(props) : call("$.spread_props", object(props), ...spreads);
  const fallback = node.fragment.nodes.length === 0 ? literal(null) : arrow(
    [id("$$anchor")],
    /** @type {BlockStatement} */
    context.visit(node.fragment)
  );
  const slot = call(
    "$.slot",
    context.state.node,
    id("$$props"),
    name,
    props_expression,
    fallback
  );
  context.state.init.push(stmt(slot));
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/SnippetBlock.js
function SnippetBlock3(node, context) {
  var _a2;
  const args = [id("$$anchor")];
  let body;
  const declarations = [];
  const transform = { ...context.state.transform };
  const child_state = { ...context.state, transform };
  for (let i = 0; i < node.parameters.length; i++) {
    const argument = node.parameters[i];
    if (!argument) continue;
    if (argument.type === "Identifier") {
      args.push({
        type: "AssignmentPattern",
        left: argument,
        right: id("$.noop")
      });
      transform[argument.name] = { read: call };
      continue;
    }
    let arg_alias = `$$arg${i}`;
    args.push(id(arg_alias));
    const paths = extract_paths(argument);
    for (const path of paths) {
      const name = (
        /** @type {Identifier} */
        path.node.name
      );
      const needs_derived = path.has_default_value;
      const fn = thunk(
        /** @type {Expression} */
        context.visit((_a2 = path.expression) == null ? void 0 : _a2.call(path, maybe_call(id(arg_alias))))
      );
      declarations.push(let_builder(path.node, needs_derived ? call("$.derived_safe_equal", fn) : fn));
      transform[name] = {
        read: needs_derived ? get_value : call
      };
      if (dev) {
        declarations.push(stmt(transform[name].read(id(name))));
      }
    }
  }
  body = block([
    ...declarations,
    .../** @type {BlockStatement} */
    context.visit(node.body, child_state).body
  ]);
  let snippet = arrow(args, body);
  if (dev) {
    snippet = call("$.wrap_snippet", id(context.state.analysis.name), snippet);
  }
  const declaration2 = const_builder(node.expression, snippet);
  if (context.path.length === 1 && context.path[0].type === "Fragment") {
    context.state.analysis.top_level_snippets.push(declaration2);
  } else {
    context.state.init.push(declaration2);
  }
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/SpreadAttribute.js
function SpreadAttribute3(node, context) {
  return context.visit(node.expression);
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/shared/special_element.js
function visit_special_element(node, id2, context) {
  const state = { ...context.state, node: id(id2) };
  for (const attribute of node.attributes) {
    if (attribute.type === "OnDirective") {
      context.state.init.push(stmt(
        /** @type {Expression} */
        context.visit(attribute, state)
      ));
    } else {
      context.visit(attribute, state);
    }
  }
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/SvelteBody.js
function SvelteBody2(node, context) {
  visit_special_element(node, "$.document.body", context);
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/SvelteComponent.js
function SvelteComponent3(node, context) {
  const component = build_component(node, "$$component", context);
  context.state.init.push(component);
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/SvelteDocument.js
function SvelteDocument2(node, context) {
  visit_special_element(node, "$.document", context);
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/SvelteElement.js
function SvelteElement3(node, context) {
  context.state.template.push(`<!>`);
  const attributes = [];
  let dynamic_namespace = void 0;
  const class_directives = [];
  const style_directives = [];
  const lets = [];
  const element_id = id(context.state.scope.generate("$$element"));
  const inner_context = {
    ...context,
    state: {
      ...context.state,
      node: element_id,
      before_init: [],
      init: [],
      update: [],
      after_update: []
    }
  };
  for (const attribute of node.attributes) {
    if (attribute.type === "Attribute") {
      if (attribute.name === "xmlns" && !is_text_attribute(attribute)) {
        dynamic_namespace = attribute.value;
      }
      attributes.push(attribute);
    } else if (attribute.type === "SpreadAttribute") {
      attributes.push(attribute);
    } else if (attribute.type === "ClassDirective") {
      class_directives.push(attribute);
    } else if (attribute.type === "StyleDirective") {
      style_directives.push(attribute);
    } else if (attribute.type === "LetDirective") {
      lets.push(
        /** @type {ExpressionStatement} */
        context.visit(attribute)
      );
    } else if (attribute.type === "OnDirective") {
      const handler = (
        /** @type {Expression} */
        context.visit(attribute, inner_context.state)
      );
      inner_context.state.after_update.push(stmt(handler));
    } else {
      context.visit(attribute, inner_context.state);
    }
  }
  context.state.init.push(...lets);
  let is_attributes_reactive = false;
  if (attributes.length === 0) {
    if (context.state.analysis.css.hash) {
      inner_context.state.init.push(
        stmt(call("$.set_class", element_id, literal(context.state.analysis.css.hash)))
      );
    }
  } else {
    const attributes_id = id(context.state.scope.generate("attributes"));
    is_attributes_reactive = build_set_attributes(
      attributes,
      inner_context,
      node,
      element_id,
      attributes_id,
      binary("===", member(element_id, "namespaceURI"), id("$.NAMESPACE_SVG")),
      call(member(member(element_id, "nodeName"), "includes"), literal("-")),
      context.state
    );
  }
  build_class_directives2(class_directives, element_id, inner_context, is_attributes_reactive);
  build_style_directives2(style_directives, element_id, inner_context, is_attributes_reactive);
  const get_tag = thunk(
    /** @type {Expression} */
    context.visit(node.tag)
  );
  if (dev) {
    if (node.fragment.nodes.length > 0) {
      context.state.init.push(stmt(call("$.validate_void_dynamic_element", get_tag)));
    }
    context.state.init.push(stmt(call("$.validate_dynamic_element_tag", get_tag)));
  }
  const inner = inner_context.state.init;
  if (inner_context.state.update.length > 0) {
    inner.push(build_render_statement(inner_context.state.update));
  }
  inner.push(...inner_context.state.after_update);
  inner.push(
    .../** @type {BlockStatement} */
    context.visit(node.fragment, {
      ...context.state,
      metadata: {
        ...context.state.metadata,
        namespace: determine_namespace_for_children(node, context.state.metadata.namespace)
      }
    }).body
  );
  const location = dev && locator(node.start);
  context.state.init.push(
    stmt(
      call(
        "$.element",
        context.state.node,
        get_tag,
        node.metadata.svg || node.metadata.mathml ? true_instance : false_instance,
        inner.length > 0 && arrow([element_id, id("$$anchor")], block(inner)),
        dynamic_namespace && thunk(build_attribute_value2(dynamic_namespace, context).value),
        location && array([literal(location.line), literal(location.column)])
      )
    )
  );
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/SvelteFragment.js
function SvelteFragment3(node, context) {
  for (const attribute of node.attributes) {
    if (attribute.type === "LetDirective") {
      context.state.init.push(
        /** @type {ExpressionStatement} */
        context.visit(attribute)
      );
    }
  }
  context.state.init.push(.../** @type {BlockStatement} */
  context.visit(node.fragment).body);
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/SvelteHead.js
function SvelteHead3(node, context) {
  context.state.init.push(
    stmt(
      call(
        "$.head",
        arrow(
          [id("$$anchor")],
          /** @type {BlockStatement} */
          context.visit(node.fragment)
        )
      )
    )
  );
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/SvelteSelf.js
function SvelteSelf3(node, context) {
  const component = build_component(node, context.state.analysis.name, context);
  context.state.init.push(component);
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/SvelteWindow.js
function SvelteWindow2(node, context) {
  visit_special_element(node, "$.window", context);
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/TitleElement.js
function TitleElement3(node, context) {
  const { has_state, value } = build_template_literal(
    /** @type {any} */
    node.fragment.nodes,
    context.visit,
    context.state
  );
  const statement = stmt(assignment("=", id("$.document.title"), value));
  if (has_state) {
    context.state.update.push(statement);
  } else {
    context.state.init.push(statement);
  }
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/TransitionDirective.js
function TransitionDirective2(node, context) {
  let flags = node.modifiers.includes("global") ? TRANSITION_GLOBAL : 0;
  if (node.intro) flags |= TRANSITION_IN;
  if (node.outro) flags |= TRANSITION_OUT;
  const args = [
    literal(flags),
    context.state.node,
    thunk(
      /** @type {Expression} */
      context.visit(parse_directive_name(node.name))
    )
  ];
  if (node.expression) {
    args.push(thunk(
      /** @type {Expression} */
      context.visit(node.expression)
    ));
  }
  context.state.after_update.push(stmt(call("$.transition", ...args)));
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/UpdateExpression.js
function UpdateExpression3(node, context) {
  var _a2;
  const argument = node.argument;
  if (argument.type === "MemberExpression" && argument.object.type === "ThisExpression" && argument.property.type === "PrivateIdentifier" && context.state.private_state.has(argument.property.name)) {
    let fn = "$.update";
    if (node.prefix) fn += "_pre";
    const args = [argument];
    if (node.operator === "--") {
      args.push(literal(-1));
    }
    return call(fn, ...args);
  }
  if (argument.type !== "Identifier" && argument.type !== "MemberExpression") {
    throw new Error("An impossible state was reached");
  }
  const left = object2(argument);
  if (left === null) return context.next();
  if (left === argument) {
    const transform = context.state.transform;
    const update3 = (_a2 = transform[left.name]) == null ? void 0 : _a2.update;
    if (update3 && Object.hasOwn(transform, left.name)) {
      return update3(node);
    }
  }
  const assignment2 = (
    /** @type {Expression} */
    context.visit(
      assignment(
        node.operator === "++" ? "+=" : "-=",
        /** @type {Pattern} */
        argument,
        literal(1)
      )
    )
  );
  const parent = (
    /** @type {Node} */
    context.path.at(-1)
  );
  const is_standalone = parent.type === "ExpressionStatement";
  const update2 = node.prefix || is_standalone ? assignment2 : binary(node.operator === "++" ? "-" : "+", assignment2, literal(1));
  return is_ignored(node, "ownership_invalid_mutation") ? call("$.skip_ownership_validation", thunk(update2)) : update2;
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/UseDirective.js
function UseDirective2(node, context) {
  const params = [id("$$node")];
  if (node.expression) {
    params.push(id("$$action_arg"));
  }
  const args = [
    context.state.node,
    arrow(
      params,
      call(
        /** @type {Expression} */
        context.visit(parse_directive_name(node.name)),
        ...params
      )
    )
  ];
  if (node.expression) {
    args.push(thunk(
      /** @type {Expression} */
      context.visit(node.expression)
    ));
  }
  context.state.init.push(stmt(call("$.action", ...args)));
  context.next();
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/VariableDeclaration.js
function VariableDeclaration2(node, context) {
  var _a2;
  const declarations = [];
  if (context.state.analysis.runes) {
    for (const declarator2 of node.declarations) {
      const init2 = declarator2.init;
      const rune = get_rune(init2, context.state.scope);
      if (!rune || rune === "$effect.tracking" || rune === "$effect.root" || rune === "$inspect" || rune === "$state.snapshot" || rune === "$host") {
        if (init2 != null && is_hoisted_function(init2)) {
          context.state.hoisted.push(
            const_builder(
              declarator2.id,
              /** @type {Expression} */
              context.visit(init2)
            )
          );
          continue;
        }
        declarations.push(
          /** @type {VariableDeclarator} */
          context.visit(declarator2)
        );
        continue;
      }
      if (rune === "$props") {
        const seen = ["$$slots", "$$events", "$$legacy"];
        if (context.state.analysis.custom_element) {
          seen.push("$$host");
        }
        if (declarator2.id.type === "Identifier") {
          const args2 = [id("$$props"), array(seen.map((name) => literal(name)))];
          if (dev) {
            args2.push(literal(declarator2.id.name));
          }
          declarations.push(declarator(declarator2.id, call("$.rest_props", ...args2)));
        } else {
          equal(declarator2.id.type, "ObjectPattern");
          for (const property of declarator2.id.properties) {
            if (property.type === "Property") {
              const key2 = (
                /** @type {Identifier | Literal} */
                property.key
              );
              const name = key2.type === "Identifier" ? key2.name : (
                /** @type {string} */
                key2.value
              );
              seen.push(name);
              let id2 = property.value.type === "AssignmentPattern" ? property.value.left : property.value;
              equal(id2.type, "Identifier");
              const binding = (
                /** @type {Binding} */
                context.state.scope.get(id2.name)
              );
              let initial = binding.initial && /** @type {Expression} */
              context.visit(binding.initial);
              if (initial && binding.kind === "bindable_prop" && should_proxy(initial, context.state.scope)) {
                initial = call("$.proxy", initial);
              }
              if (is_prop_source(binding, context.state)) {
                declarations.push(
                  declarator(id2, get_prop_source(binding, context.state, name, initial))
                );
              }
            } else {
              const args2 = [id("$$props"), array(seen.map((name) => literal(name)))];
              if (dev) {
                args2.push(literal(
                  /** @type {Identifier} */
                  property.argument.name
                ));
              }
              declarations.push(declarator(property.argument, call("$.rest_props", ...args2)));
            }
          }
        }
        continue;
      }
      const args = (
        /** @type {CallExpression} */
        init2.arguments
      );
      const value = args.length === 0 ? id("undefined") : (
        /** @type {Expression} */
        context.visit(args[0])
      );
      if (rune === "$state" || rune === "$state.raw") {
        const create_state_declarator = (id2, value2) => {
          const binding = (
            /** @type {import('#compiler').Binding} */
            context.state.scope.get(id2.name)
          );
          if (rune === "$state" && should_proxy(value2, context.state.scope)) {
            value2 = call("$.proxy", value2);
          }
          if (is_state_source(binding, context.state.analysis)) {
            value2 = call("$.state", value2);
          }
          return value2;
        };
        if (declarator2.id.type === "Identifier") {
          declarations.push(
            declarator(declarator2.id, create_state_declarator(declarator2.id, value))
          );
        } else {
          const tmp = context.state.scope.generate("tmp");
          const paths = extract_paths(declarator2.id);
          declarations.push(
            declarator(id(tmp), value),
            ...paths.map((path) => {
              var _a3;
              const value2 = (_a3 = path.expression) == null ? void 0 : _a3.call(path, id(tmp));
              const binding = context.state.scope.get(
                /** @type {Identifier} */
                path.node.name
              );
              return declarator(
                path.node,
                (binding == null ? void 0 : binding.kind) === "state" || (binding == null ? void 0 : binding.kind) === "raw_state" ? create_state_declarator(binding.node, value2) : value2
              );
            })
          );
        }
        continue;
      }
      if (rune === "$derived" || rune === "$derived.by") {
        if (declarator2.id.type === "Identifier") {
          declarations.push(
            declarator(
              declarator2.id,
              call("$.derived", rune === "$derived.by" ? value : thunk(value))
            )
          );
        } else {
          const bindings = extract_paths(declarator2.id);
          const init3 = (
            /** @type {CallExpression} */
            declarator2.init
          );
          let id2;
          let rhs = value;
          if (rune === "$derived" && init3.arguments[0].type === "Identifier") {
            id2 = init3.arguments[0];
          } else {
            id2 = id(context.state.scope.generate("$$d"));
            rhs = call("$.get", id2);
            declarations.push(
              declarator(id2, call("$.derived", rune === "$derived.by" ? value : thunk(value)))
            );
          }
          for (let i = 0; i < bindings.length; i++) {
            const binding = bindings[i];
            declarations.push(
              declarator(binding.node, call("$.derived", thunk(binding.expression(rhs))))
            );
          }
        }
        continue;
      }
    }
  } else {
    for (const declarator2 of node.declarations) {
      const bindings = (
        /** @type {Binding[]} */
        context.state.scope.get_bindings(declarator2)
      );
      const has_state = bindings.some((binding) => binding.kind === "state");
      const has_props = bindings.some((binding) => binding.kind === "bindable_prop");
      if (!has_state && !has_props) {
        const init2 = declarator2.init;
        if (init2 != null && is_hoisted_function(init2)) {
          context.state.hoisted.push(
            const_builder(
              declarator2.id,
              /** @type {Expression} */
              context.visit(init2)
            )
          );
          continue;
        }
        declarations.push(
          /** @type {VariableDeclarator} */
          context.visit(declarator2)
        );
        continue;
      }
      if (has_props) {
        if (declarator2.id.type !== "Identifier") {
          const tmp = context.state.scope.generate("tmp");
          const paths = extract_paths(declarator2.id);
          declarations.push(
            declarator(
              id(tmp),
              /** @type {Expression} */
              context.visit(
                /** @type {Expression} */
                declarator2.init
              )
            )
          );
          for (const path of paths) {
            const name = (
              /** @type {Identifier} */
              path.node.name
            );
            const binding2 = (
              /** @type {Binding} */
              context.state.scope.get(name)
            );
            const value = (_a2 = path.expression) == null ? void 0 : _a2.call(path, id(tmp));
            declarations.push(
              declarator(
                path.node,
                binding2.kind === "bindable_prop" ? get_prop_source(binding2, context.state, binding2.prop_alias ?? name, value) : value
              )
            );
          }
          continue;
        }
        const binding = (
          /** @type {Binding} */
          context.state.scope.get(declarator2.id.name)
        );
        declarations.push(
          declarator(
            declarator2.id,
            get_prop_source(
              binding,
              context.state,
              binding.prop_alias ?? declarator2.id.name,
              declarator2.init && /** @type {Expression} */
              context.visit(declarator2.init)
            )
          )
        );
        continue;
      }
      declarations.push(
        ...create_state_declarators2(
          declarator2,
          context.state,
          /** @type {Expression} */
          declarator2.init && context.visit(declarator2.init)
        )
      );
    }
  }
  if (declarations.length === 0) {
    return empty;
  }
  return {
    ...node,
    declarations
  };
}
function create_state_declarators2(declarator2, { scope, analysis }, value) {
  if (declarator2.id.type === "Identifier") {
    return [
      declarator(
        declarator2.id,
        call("$.mutable_state", value, analysis.immutable ? true_instance : void 0)
      )
    ];
  }
  const tmp = scope.generate("tmp");
  const paths = extract_paths(declarator2.id);
  return [
    declarator(id(tmp), value),
    ...paths.map((path) => {
      var _a2;
      const value2 = (_a2 = path.expression) == null ? void 0 : _a2.call(path, id(tmp));
      const binding = scope.get(
        /** @type {Identifier} */
        path.node.name
      );
      return declarator(
        path.node,
        (binding == null ? void 0 : binding.kind) === "state" ? call("$.mutable_state", value2, analysis.immutable ? true_instance : void 0) : value2
      );
    })
  ];
}

// node_modules/svelte/src/compiler/phases/3-transform/client/transform-client.js
var visitors6 = {
  _: function set_scope2(node, { next: next2, state }) {
    const scope = state.scopes.get(node);
    if (scope && scope !== state.scope) {
      const transform = { ...state.transform };
      for (const [name, binding] of scope.declarations) {
        if (binding.kind === "normal" || // Reads of `$state(...)` declarations are not
        // transformed if they are never reassigned
        binding.kind === "state" && !is_state_source(binding, state.analysis)) {
          delete transform[name];
        }
      }
      next2({ ...state, transform, scope });
    } else {
      next2();
    }
  },
  AnimateDirective,
  ArrowFunctionExpression: ArrowFunctionExpression2,
  AssignmentExpression: AssignmentExpression3,
  Attribute: Attribute2,
  AwaitBlock: AwaitBlock3,
  BinaryExpression,
  BindDirective: BindDirective2,
  BlockStatement,
  BreakStatement,
  CallExpression: CallExpression3,
  ClassBody: ClassBody3,
  Comment,
  Component: Component3,
  ConstTag: ConstTag3,
  DebugTag: DebugTag3,
  EachBlock: EachBlock3,
  ExportNamedDeclaration: ExportNamedDeclaration2,
  ExpressionStatement: ExpressionStatement3,
  Fragment: Fragment2,
  FunctionDeclaration: FunctionDeclaration2,
  FunctionExpression: FunctionExpression2,
  HtmlTag: HtmlTag3,
  Identifier: Identifier3,
  IfBlock: IfBlock3,
  ImportDeclaration: ImportDeclaration2,
  KeyBlock: KeyBlock3,
  LabeledStatement: LabeledStatement3,
  LetDirective: LetDirective2,
  MemberExpression: MemberExpression3,
  OnDirective: OnDirective2,
  Program,
  RegularElement: RegularElement3,
  RenderTag: RenderTag3,
  SlotElement: SlotElement3,
  SnippetBlock: SnippetBlock3,
  SpreadAttribute: SpreadAttribute3,
  SvelteBody: SvelteBody2,
  SvelteComponent: SvelteComponent3,
  SvelteDocument: SvelteDocument2,
  SvelteElement: SvelteElement3,
  SvelteFragment: SvelteFragment3,
  SvelteHead: SvelteHead3,
  SvelteSelf: SvelteSelf3,
  SvelteWindow: SvelteWindow2,
  TitleElement: TitleElement3,
  TransitionDirective: TransitionDirective2,
  UpdateExpression: UpdateExpression3,
  UseDirective: UseDirective2,
  VariableDeclaration: VariableDeclaration2
};
function client_component(analysis, options) {
  var _a2, _b2;
  const state = {
    analysis,
    options,
    scope: analysis.module.scope,
    scopes: analysis.module.scopes,
    is_instance: false,
    hoisted: [import_all("$", "svelte/internal/client")],
    node: (
      /** @type {any} */
      null
    ),
    // populated by the root node
    legacy_reactive_imports: [],
    legacy_reactive_statements: /* @__PURE__ */ new Map(),
    metadata: {
      context: {
        template_needs_import_node: false,
        template_contains_script_tag: false
      },
      namespace: options.namespace,
      bound_contenteditable: false
    },
    events: /* @__PURE__ */ new Set(),
    preserve_whitespace: options.preserveWhitespace,
    public_state: /* @__PURE__ */ new Map(),
    private_state: /* @__PURE__ */ new Map(),
    transform: {},
    in_constructor: false,
    // these are set inside the `Fragment` visitor, and cannot be used until then
    before_init: (
      /** @type {any} */
      null
    ),
    init: (
      /** @type {any} */
      null
    ),
    update: (
      /** @type {any} */
      null
    ),
    after_update: (
      /** @type {any} */
      null
    ),
    template: (
      /** @type {any} */
      null
    ),
    locations: (
      /** @type {any} */
      null
    )
  };
  const module = (
    /** @type {ESTree.Program} */
    walk(
      /** @type {SvelteNode} */
      analysis.module.ast,
      state,
      visitors6
    )
  );
  const instance_state = {
    ...state,
    transform: { ...state.transform },
    scope: analysis.instance.scope,
    scopes: analysis.instance.scopes,
    is_instance: true
  };
  const instance = (
    /** @type {ESTree.Program} */
    walk(
      /** @type {SvelteNode} */
      analysis.instance.ast,
      instance_state,
      visitors6
    )
  );
  const template3 = (
    /** @type {ESTree.Program} */
    walk(
      /** @type {SvelteNode} */
      analysis.template.ast,
      {
        ...state,
        transform: instance_state.transform,
        scope: analysis.instance.scope,
        scopes: analysis.template.scopes
      },
      visitors6
    )
  );
  module.body.unshift(...state.legacy_reactive_imports);
  const store_setup = [];
  const legacy_reactive_declarations = [];
  for (const [name, binding] of analysis.instance.scope.declarations) {
    if (binding.kind === "legacy_reactive") {
      legacy_reactive_declarations.push(
        const_builder(name, call("$.mutable_state", void 0, analysis.immutable ? true_instance : void 0))
      );
    }
    if (binding.kind === "store_sub") {
      if (store_setup.length === 0) {
        store_setup.push(const_builder("$$stores", call("$.setup_stores")));
      }
      const store_reference = build_getter(id(name.slice(1)), instance_state);
      const store_get = call("$.store_get", store_reference, literal(name), id("$$stores"));
      store_setup.push(
        const_builder(
          binding.node,
          dev ? thunk(
            sequence([
              call("$.validate_store", store_reference, literal(name.slice(1))),
              store_get
            ])
          ) : thunk(store_get)
        )
      );
    }
  }
  for (const [node] of analysis.reactive_statements) {
    const statement = [...state.legacy_reactive_statements].find(([n]) => n === node);
    if (statement === void 0) {
      throw new Error("Could not find reactive statement");
    }
    instance.body.push(statement[1]);
  }
  if (analysis.reactive_statements.size > 0) {
    instance.body.push(stmt(call("$.legacy_pre_effect_reset")));
  }
  const group_binding_declarations = [];
  for (const group of analysis.binding_groups.values()) {
    group_binding_declarations.push(const_builder(group.name, array([])));
  }
  const component_returned_object = analysis.exports.flatMap(({ name, alias }) => {
    const binding = instance_state.scope.get(name);
    const expression = build_getter(id(name), instance_state);
    const getter = get(alias ?? name, [return_builder(expression)]);
    if (expression.type === "Identifier") {
      if ((binding == null ? void 0 : binding.declaration_kind) === "let" || (binding == null ? void 0 : binding.declaration_kind) === "var") {
        return [
          getter,
          set(alias ?? name, [stmt(assignment("=", expression, id("$$value")))])
        ];
      } else if (!dev) {
        return init(alias ?? name, expression);
      }
    }
    if ((binding == null ? void 0 : binding.kind) === "prop" || (binding == null ? void 0 : binding.kind) === "bindable_prop") {
      return [getter, set(alias ?? name, [stmt(call(name, id("$$value")))])];
    }
    if ((binding == null ? void 0 : binding.kind) === "state" || (binding == null ? void 0 : binding.kind) === "raw_state") {
      const value = binding.kind === "state" ? call("$.proxy", id("$$value")) : id("$$value");
      return [getter, set(alias ?? name, [stmt(call("$.set", id(name), value))])];
    }
    return getter;
  });
  const properties = [...analysis.instance.scope.declarations].filter(
    ([name, binding]) => (binding.kind === "prop" || binding.kind === "bindable_prop") && !name.startsWith("$$")
  );
  if (dev && analysis.runes) {
    const exports = analysis.exports.map(({ name, alias }) => literal(alias ?? name));
    const bindable = [];
    for (const [name, binding] of properties) {
      if (binding.kind === "bindable_prop") {
        bindable.push(literal(binding.prop_alias ?? name));
      }
    }
    instance.body.unshift(
      stmt(
        call(
          "$.validate_prop_bindings",
          id("$$props"),
          array(bindable),
          array(exports),
          id(`${analysis.name}`)
        )
      )
    );
  }
  if (analysis.accessors) {
    for (const [name, binding] of properties) {
      const key2 = binding.prop_alias ?? name;
      const getter = get(key2, [return_builder(call(id(name)))]);
      const setter = set(key2, [
        stmt(call(id(name), id("$$value"))),
        stmt(call("$.flush_sync"))
      ]);
      if (analysis.runes && binding.initial) {
        setter.value.params[0] = {
          type: "AssignmentPattern",
          left: id("$$value"),
          right: (
            /** @type {ESTree.Expression} */
            binding.initial
          )
        };
      }
      component_returned_object.push(getter, setter);
    }
  }
  if (options.compatibility.componentApi === 4) {
    component_returned_object.push(
      init("$set", id("$.update_legacy_props")),
      init(
        "$on",
        arrow(
          [id("$$event_name"), id("$$event_cb")],
          call(
            "$.add_legacy_event_listener",
            id("$$props"),
            id("$$event_name"),
            id("$$event_cb")
          )
        )
      )
    );
  } else if (dev) {
    component_returned_object.push(spread(call(id("$.legacy_api"))));
  }
  const push_args = [id("$$props"), literal(analysis.runes)];
  if (dev) push_args.push(id(analysis.name));
  const component_block = block([
    ...store_setup,
    ...legacy_reactive_declarations,
    ...group_binding_declarations,
    ...analysis.top_level_snippets,
    .../** @type {ESTree.Statement[]} */
    instance.body,
    analysis.runes || !analysis.needs_context ? empty : stmt(call("$.init", analysis.immutable ? true_instance : void 0)),
    .../** @type {ESTree.Statement[]} */
    template3.body
  ]);
  if (!analysis.runes) {
    for (const { name, alias } of analysis.exports) {
      component_block.body.push(
        stmt(
          call(
            "$.bind_prop",
            id("$$props"),
            literal(alias ?? name),
            build_getter(id(name), instance_state)
          )
        )
      );
    }
  }
  if (analysis.css.ast !== null && analysis.inject_styles) {
    const hash2 = literal(analysis.css.hash);
    const code = literal(render_stylesheet(analysis.source, analysis, options).code);
    state.hoisted.push(const_builder("$$css", object([init("hash", hash2), init("code", code)])));
    component_block.body.unshift(
      stmt(call("$.append_styles", id("$$anchor"), id("$$css")))
    );
  }
  const should_inject_context = dev || analysis.needs_context || analysis.reactive_statements.size > 0 || component_returned_object.length > 0;
  if (should_inject_context) {
    component_block.body.unshift(stmt(call("$.push", ...push_args)));
    component_block.body.push(
      component_returned_object.length > 0 ? return_builder(call("$.pop", object(component_returned_object))) : stmt(call("$.pop"))
    );
  }
  if (analysis.uses_rest_props) {
    const named_props = analysis.exports.map(({ name, alias }) => alias ?? name);
    for (const [name, binding] of analysis.instance.scope.declarations) {
      if (binding.kind === "bindable_prop") named_props.push(binding.prop_alias ?? name);
    }
    component_block.body.unshift(
      const_builder(
        "$$restProps",
        call(
          "$.legacy_rest_props",
          id("$$sanitized_props"),
          array(named_props.map((name) => literal(name)))
        )
      )
    );
  }
  if (analysis.uses_props || analysis.uses_rest_props) {
    const to_remove = [
      literal("children"),
      literal("$$slots"),
      literal("$$events"),
      literal("$$legacy")
    ];
    if (analysis.custom_element) {
      to_remove.push(literal("$$host"));
    }
    component_block.body.unshift(
      const_builder(
        "$$sanitized_props",
        call("$.legacy_rest_props", id("$$props"), array(to_remove))
      )
    );
  }
  if (analysis.uses_slots) {
    component_block.body.unshift(const_builder("$$slots", call("$.sanitize_slots", id("$$props"))));
  }
  let should_inject_props = should_inject_context || analysis.needs_props || analysis.uses_props || analysis.uses_rest_props || analysis.uses_slots || analysis.slot_names.size > 0;
  const imports2 = [];
  let body = [];
  for (const entry of [...module.body, ...state.hoisted]) {
    if (entry.type === "ImportDeclaration") {
      imports2.push(entry);
    } else {
      body.push(entry);
    }
  }
  body = [...imports2, ...body];
  const component = function_declaration(
    id(analysis.name),
    should_inject_props ? [id("$$anchor"), id("$$props")] : [id("$$anchor")],
    component_block
  );
  if (options.hmr) {
    const id2 = id(analysis.name);
    const HMR = id("$.HMR");
    const existing = member(id2, HMR, true);
    const incoming = member(id("module.default"), HMR, true);
    const accept_fn_body = [
      stmt(assignment("=", member(incoming, "source"), member(existing, "source"))),
      stmt(call("$.set", member(existing, "source"), member(incoming, "original")))
    ];
    if (analysis.css.hash) {
      accept_fn_body.unshift(stmt(call("$.cleanup_styles", literal(analysis.css.hash))));
    }
    const hmr = block([
      stmt(assignment("=", id2, call("$.hmr", id2, thunk(member(existing, "source"))))),
      stmt(call("import.meta.hot.accept", arrow([id("module")], block(accept_fn_body))))
    ]);
    body.push(component, if_builder(id("import.meta.hot"), hmr), export_default(id(analysis.name)));
  } else {
    body.push(export_default(component));
  }
  if (dev) {
    body.unshift(
      stmt(
        assignment("=", member(id(analysis.name), "$.FILENAME", true), literal(filename))
      )
    );
    body.unshift(stmt(call(id("$.mark_module_start"))));
    body.push(stmt(call(id("$.mark_module_end"), id(analysis.name))));
  }
  if (options.discloseVersion) {
    body.unshift(imports([], "svelte/internal/disclose-version"));
  }
  if (options.compatibility.componentApi === 4) {
    body.unshift(imports([["createClassComponent", "$$_createClassComponent"]], "svelte/legacy"));
    component_block.body.unshift(
      if_builder(
        id("new.target"),
        return_builder(
          call(
            "$$_createClassComponent",
            // When called with new, the first argument is the constructor options
            object([init("component", id(analysis.name)), spread(id("$$anchor"))])
          )
        )
      )
    );
  } else if (dev) {
    component_block.body.unshift(stmt(call("$.check_target", id("new.target"))));
  }
  if (state.events.size > 0) {
    body.push(
      stmt(call("$.delegate", array(Array.from(state.events).map((name) => literal(name)))))
    );
  }
  if (analysis.custom_element) {
    const ce = analysis.custom_element;
    const props_str = [];
    for (const [name, binding] of properties) {
      const key2 = binding.prop_alias ?? name;
      const prop_def2 = typeof ce === "boolean" ? {} : ((_a2 = ce.props) == null ? void 0 : _a2[key2]) || {};
      if (!prop_def2.type && ((_b2 = binding.initial) == null ? void 0 : _b2.type) === "Literal" && typeof binding.initial.value === "boolean") {
        prop_def2.type = "Boolean";
      }
      const value = object(
        /** @type {ESTree.Property[]} */
        [
          prop_def2.attribute ? init("attribute", literal(prop_def2.attribute)) : void 0,
          prop_def2.reflect ? init("reflect", literal(true)) : void 0,
          prop_def2.type ? init("type", literal(prop_def2.type)) : void 0
        ].filter(Boolean)
      );
      props_str.push(init(key2, value));
    }
    const slots_str = array([...analysis.slot_names.keys()].map((name) => literal(name)));
    const accessors_str = array(
      analysis.exports.map(({ name, alias }) => literal(alias ?? name))
    );
    const use_shadow_dom = typeof ce === "boolean" || ce.shadow !== "none" ? true : false;
    const create_ce = call(
      "$.create_custom_element",
      id(analysis.name),
      object(props_str),
      slots_str,
      accessors_str,
      literal(use_shadow_dom),
      /** @type {any} */
      typeof ce !== "boolean" ? ce.extend : void 0
    );
    if (typeof ce !== "boolean" && typeof ce.tag === "string") {
      const define = stmt(call("customElements.define", literal(ce.tag), create_ce));
      if (options.hmr) {
        body.push(
          if_builder(binary("==", call("customElements.get", literal(ce.tag)), null_instane), define)
        );
      } else {
        body.push(define);
      }
    } else {
      body.push(stmt(create_ce));
    }
  }
  return {
    type: "Program",
    sourceType: "module",
    body
  };
}
function client_module(analysis, options) {
  const state = {
    analysis,
    options,
    scope: analysis.module.scope,
    scopes: analysis.module.scopes,
    public_state: /* @__PURE__ */ new Map(),
    private_state: /* @__PURE__ */ new Map(),
    transform: {},
    in_constructor: false
  };
  const module = (
    /** @type {ESTree.Program} */
    walk(
      /** @type {SvelteNode} */
      analysis.module.ast,
      state,
      visitors6
    )
  );
  return {
    type: "Program",
    sourceType: "module",
    body: [import_all("$", "svelte/internal/client"), ...module.body]
  };
}

// node_modules/svelte/src/compiler/phases/3-transform/index.js
function transform_component(analysis, source2, options) {
  if (options.generate === false) {
    return {
      js: (
        /** @type {any} */
        null
      ),
      css: null,
      warnings,
      // set afterwards
      metadata: {
        runes: analysis.runes
      },
      ast: (
        /** @type {any} */
        null
      )
      // set afterwards
    };
  }
  const program = options.generate === "server" ? server_component(analysis, options) : client_component(analysis, options);
  const js_source_name = get_source_name(options.filename, options.outputFilename, "input.svelte");
  const js2 = print(program, {
    // include source content; makes it easier/more robust looking up the source map code
    // (else esrap does return null for source and sourceMapContent which may trip up tooling)
    sourceMapContent: source2,
    sourceMapSource: js_source_name
  });
  merge_with_preprocessor_map(js2, options, js_source_name);
  const css = analysis.css.ast && !analysis.inject_styles ? render_stylesheet(source2, analysis, options) : null;
  return {
    js: js2,
    css,
    warnings,
    // set afterwards. TODO apply preprocessor sourcemap
    metadata: {
      runes: analysis.runes
    },
    ast: (
      /** @type {any} */
      null
    )
    // set afterwards
  };
}
function transform_module(analysis, source2, options) {
  if (options.generate === false) {
    return {
      js: (
        /** @type {any} */
        null
      ),
      css: null,
      warnings,
      // set afterwards
      metadata: {
        runes: true
      },
      ast: (
        /** @type {any} */
        null
      )
      // set afterwards
    };
  }
  const program = options.generate === "server" ? server_module(analysis, options) : client_module(analysis, options);
  const basename = options.filename.split(/[/\\]/).at(-1);
  if (program.body.length > 0) {
    program.body[0].leadingComments = [
      {
        type: "Block",
        value: ` ${basename} generated by Svelte v${VERSION} `
      }
    ];
  }
  return {
    js: print(program, {
      // include source content; makes it easier/more robust looking up the source map code
      // (else esrap does return null for source and sourceMapContent which may trip up tooling)
      sourceMapContent: source2,
      sourceMapSource: get_source_name(options.filename, void 0, "input.svelte.js")
    }),
    css: null,
    metadata: {
      runes: true
    },
    warnings,
    // set afterwards
    ast: (
      /** @type {any} */
      null
    )
    // set afterwards
  };
}

// node_modules/svelte/src/compiler/validate-options.js
var import_node_process = __toESM(require_node_process(), 1);
var _a, _b;
var common = {
  filename: string("(unknown)"),
  // default to process.cwd() where it exists to replicate svelte4 behavior
  // see https://github.com/sveltejs/svelte/blob/b62fc8c8fd2640c9b99168f01b9d958cb2f7574f/packages/svelte/src/compiler/compile/Component.js#L211
  rootDir: string(typeof import_node_process.default !== "undefined" ? (_b = (_a = import_node_process.default).cwd) == null ? void 0 : _b.call(_a) : void 0),
  dev: boolean(false),
  generate: validator("client", (input, keypath) => {
    if (input === "dom" || input === "ssr") {
      warn_once(options_renamed_ssr_dom);
      return input === "dom" ? "client" : "server";
    }
    if (input !== "client" && input !== "server" && input !== false) {
      throw_error2(`${keypath} must be "client", "server" or false`);
    }
    return input;
  }),
  warningFilter: fun(() => true)
};
var validate_module_options = (
  /** @type {Validator<ModuleCompileOptions, ValidatedModuleCompileOptions>} */
  object3({
    ...common
  })
);
var validate_component_options = (
  /** @type {Validator<CompileOptions, ValidatedCompileOptions>} */
  object3({
    ...common,
    accessors: deprecate(options_deprecated_accessors, boolean(false)),
    css: validator("external", (input) => {
      if (input === true || input === false) {
        throw_error2(
          'The boolean options have been removed from the css option. Use "external" instead of false and "injected" instead of true'
        );
      }
      if (input === "none") {
        throw_error2(
          'css: "none" is no longer a valid option. If this was crucial for you, please open an issue on GitHub with your use case.'
        );
      }
      if (input !== "external" && input !== "injected") {
        throw_error2(`css should be either "external" (default, recommended) or "injected"`);
      }
      return input;
    }),
    cssHash: fun(({ css, hash: hash2 }) => {
      return `svelte-${hash2(css)}`;
    }),
    // TODO this is a sourcemap option, would be good to put under a sourcemap namespace
    cssOutputFilename: string(void 0),
    customElement: boolean(false),
    discloseVersion: boolean(true),
    immutable: deprecate(options_deprecated_immutable, boolean(false)),
    legacy: removed(
      "The legacy option has been removed. If you are using this because of legacy.componentApi, use compatibility.componentApi instead"
    ),
    compatibility: object3({
      componentApi: list2([4, 5], 5)
    }),
    loopGuardTimeout: warn_removed(options_removed_loop_guard_timeout),
    name: string(void 0),
    namespace: list2(["html", "mathml", "svg"]),
    modernAst: boolean(false),
    outputFilename: string(void 0),
    preserveComments: boolean(false),
    preserveWhitespace: boolean(false),
    runes: boolean(void 0),
    hmr: boolean(false),
    sourcemap: validator(void 0, (input) => {
      return input;
    }),
    enableSourcemap: warn_removed(options_removed_enable_sourcemap),
    hydratable: warn_removed(options_removed_hydratable),
    format: removed(
      'The format option has been removed in Svelte 4, the compiler only outputs ESM now. Remove "format" from your compiler options. If you did not set this yourself, bump the version of your bundler plugin (vite-plugin-svelte/rollup-plugin-svelte/svelte-loader)'
    ),
    tag: removed(
      'The tag option has been removed in Svelte 5. Use `<svelte:options customElement="tag-name" />` inside the component instead. If that does not solve your use case, please open an issue on GitHub with details.'
    ),
    sveltePath: removed(
      "The sveltePath option has been removed in Svelte 5. If this option was crucial for you, please open an issue on GitHub with your use case."
    ),
    // These two were primarily created for svelte-preprocess (https://github.com/sveltejs/svelte/pull/6194),
    // but with new TypeScript compilation modes strictly separating types it's not necessary anymore
    errorMode: removed(
      "The errorMode option has been removed. If you are using this through svelte-preprocess with TypeScript, use the https://www.typescriptlang.org/tsconfig#verbatimModuleSyntax setting instead"
    ),
    varsReport: removed(
      "The vars option has been removed. If you are using this through svelte-preprocess with TypeScript, use the https://www.typescriptlang.org/tsconfig#verbatimModuleSyntax setting instead"
    )
  })
);
function removed(msg) {
  return (input) => {
    if (input !== void 0) {
      options_removed(null, msg);
    }
    return (
      /** @type {any} */
      void 0
    );
  };
}
var warned = /* @__PURE__ */ new Set();
function warn_once(fn) {
  if (!warned.has(fn)) {
    warned.add(fn);
    fn(null);
  }
}
function warn_removed(fn) {
  return (input) => {
    if (input !== void 0) warn_once(fn);
    return (
      /** @type {any} */
      void 0
    );
  };
}
function deprecate(fn, validator2) {
  return (input, keypath) => {
    if (input !== void 0) warn_once(fn);
    return validator2(input, keypath);
  };
}
function object3(children, allow_unknown = false) {
  return (input, keypath) => {
    const output = {};
    if (input && typeof input !== "object" || Array.isArray(input)) {
      throw_error2(`${keypath} should be an object`);
    }
    for (const key2 in input) {
      if (!(key2 in children)) {
        if (allow_unknown) {
          output[key2] = input[key2];
        } else {
          options_unrecognised(null, `${keypath ? `${keypath}.${key2}` : key2}`);
        }
      }
    }
    for (const key2 in children) {
      const validator2 = children[key2];
      output[key2] = validator2(input && input[key2], keypath ? `${keypath}.${key2}` : key2);
    }
    return output;
  };
}
function validator(fallback, fn) {
  return (input, keypath) => {
    return input === void 0 ? fallback : fn(input, keypath);
  };
}
function string(fallback, allow_empty = true) {
  return validator(fallback, (input, keypath) => {
    if (typeof input !== "string") {
      throw_error2(`${keypath} should be a string, if specified`);
    }
    if (!allow_empty && input === "") {
      throw_error2(`${keypath} cannot be empty`);
    }
    return input;
  });
}
function boolean(fallback) {
  return validator(fallback, (input, keypath) => {
    if (typeof input !== "boolean") {
      throw_error2(`${keypath} should be true or false, if specified`);
    }
    return input;
  });
}
function list2(options, fallback = options[0]) {
  return validator(fallback, (input, keypath) => {
    if (!options.includes(input)) {
      const msg = options.length > 2 ? `${keypath} should be one of ${options.slice(0, -1).map((input2) => `"${input2}"`).join(", ")} or "${options[options.length - 1]}"` : `${keypath} should be either "${options[0]}" or "${options[1]}"`;
      throw_error2(msg);
    }
    return input;
  });
}
function fun(fallback) {
  return validator(fallback, (input, keypath) => {
    if (typeof input !== "function") {
      throw_error2(`${keypath} should be a function, if specified`);
    }
    return input;
  });
}
function throw_error2(msg) {
  options_invalid_value(null, msg);
}

// node_modules/svelte/src/compiler/preprocess/decode_sourcemap.js
var import_sourcemap_codec = __toESM(require_sourcemap_codec_umd(), 1);
function decoded_sourcemap_from_generator(generator) {
  let previous_generated_line = 1;
  const converted_mappings = [[]];
  let result_line = converted_mappings[0];
  let result_segment;
  let mapping;
  const source_idx = generator._sources.toArray().reduce((acc, val, idx) => (acc[val] = idx, acc), {});
  const name_idx = generator._names.toArray().reduce((acc, val, idx) => (acc[val] = idx, acc), {});
  const mappings = generator._mappings.toArray();
  for (let i = 0, len = mappings.length; i < len; i++) {
    mapping = mappings[i];
    if (mapping.generatedLine > previous_generated_line) {
      while (mapping.generatedLine > previous_generated_line) {
        converted_mappings.push([]);
        previous_generated_line++;
      }
      result_line = converted_mappings[mapping.generatedLine - 1];
    } else if (i > 0) {
      const previous_mapping = mappings[i - 1];
      if (
        // sorted by selectivity
        mapping.generatedColumn === previous_mapping.generatedColumn && mapping.originalColumn === previous_mapping.originalColumn && mapping.name === previous_mapping.name && mapping.generatedLine === previous_mapping.generatedLine && mapping.originalLine === previous_mapping.originalLine && mapping.source === previous_mapping.source
      ) {
        continue;
      }
    }
    result_line.push([mapping.generatedColumn]);
    result_segment = result_line[result_line.length - 1];
    if (mapping.source != null) {
      result_segment.push(
        ...[source_idx[mapping.source], mapping.originalLine - 1, mapping.originalColumn]
      );
      if (mapping.name != null) {
        result_segment.push(name_idx[mapping.name]);
      }
    }
  }
  const map = {
    version: generator._version,
    sources: generator._sources.toArray(),
    names: generator._names.toArray(),
    mappings: converted_mappings
  };
  if (generator._file != null) {
    map.file = generator._file;
  }
  return map;
}
function decode_map(processed) {
  let decoded_map = typeof processed.map === "string" ? JSON.parse(processed.map) : processed.map;
  if (typeof decoded_map.mappings === "string") {
    decoded_map.mappings = (0, import_sourcemap_codec.decode)(decoded_map.mappings);
  }
  if (decoded_map._mappings && decoded_map.constructor.name === "SourceMapGenerator") {
    decoded_map = decoded_sourcemap_from_generator(decoded_map);
  }
  return decoded_map;
}

// node_modules/svelte/src/compiler/preprocess/replace_in_code.js
function slice_source(code_slice, offset, { file_basename, filename: filename2, get_location }) {
  return {
    source: code_slice,
    get_location: (index) => get_location(index + offset),
    file_basename,
    filename: filename2
  };
}
function calculate_replacements(re, get_replacement, source2) {
  const replacements2 = [];
  source2.replace(re, (...match) => {
    replacements2.push(
      get_replacement(...match).then((replacement) => {
        const matched_string = match[0];
        const offset = match[match.length - 2];
        return { offset, length: matched_string.length, replacement };
      })
    );
    return "";
  });
  return Promise.all(replacements2);
}
function perform_replacements(replacements2, source2) {
  const out = new MappedCode();
  let last_end = 0;
  for (const { offset, length, replacement } of replacements2) {
    const unchanged_prefix = MappedCode.from_source(
      slice_source(source2.source.slice(last_end, offset), last_end, source2)
    );
    out.concat(unchanged_prefix).concat(replacement);
    last_end = offset + length;
  }
  const unchanged_suffix = MappedCode.from_source(
    slice_source(source2.source.slice(last_end), last_end, source2)
  );
  return out.concat(unchanged_suffix);
}
async function replace_in_code(regex, get_replacement, location) {
  const replacements2 = await calculate_replacements(regex, get_replacement, location.source);
  return perform_replacements(replacements2, location);
}

// node_modules/svelte/src/compiler/preprocess/index.js
var PreprocessResult = class {
  /**
   * @param {string} source
   * @param {string} [filename]
   */
  constructor(source2, filename2) {
    /** @type {string} */
    __publicField(this, "source");
    /** @type {string | undefined} The filename passed as-is to preprocess */
    __publicField(this, "filename");
    // sourcemap_list is sorted in reverse order from last map (index 0) to first map (index -1)
    // so we use sourcemap_list.unshift() to add new maps
    // https://github.com/ampproject/remapping#multiple-transformations-of-a-file
    /**
     * @default []
     * @type {Array<DecodedSourceMap | RawSourceMap>}
     */
    __publicField(this, "sourcemap_list", []);
    /**
     * @default []
     * @type {string[]}
     */
    __publicField(this, "dependencies", []);
    /**
     * @type {string | null} last part of the filename, as used for `sources` in sourcemaps
     */
    __publicField(this, "file_basename");
    /**
     * @type {ReturnType<typeof getLocator>}
     */
    __publicField(this, "get_location");
    this.source = source2;
    this.filename = filename2;
    this.update_source({ string: source2 });
    this.file_basename = filename2 == null ? null : get_basename(filename2);
  }
  /**
   * @param {SourceUpdate} opts
   */
  update_source({ string: source2, map, dependencies }) {
    if (source2 != null) {
      this.source = source2;
      this.get_location = getLocator(source2);
    }
    if (map) {
      this.sourcemap_list.unshift(map);
    }
    if (dependencies) {
      this.dependencies.push(...dependencies);
    }
  }
  /**
   * @returns {Processed}
   */
  to_processed() {
    const map = combine_sourcemaps(this.file_basename, this.sourcemap_list);
    return {
      // TODO return separated output, in future version where svelte.compile supports it:
      // style: { code: styleCode, map: styleMap },
      // script { code: scriptCode, map: scriptMap },
      // markup { code: markupCode, map: markupMap },
      code: this.source,
      dependencies: [...new Set(this.dependencies)],
      // @ts-expect-error TODO there might be a bug in hiding here
      map,
      toString: () => this.source
    };
  }
};
function processed_content_to_code(processed, location, file_basename) {
  let decoded_map = void 0;
  if (processed.map) {
    decoded_map = decode_map(processed);
    if (decoded_map == null ? void 0 : decoded_map.sources) {
      const source_index = decoded_map.sources.indexOf(file_basename);
      if (source_index !== -1) {
        sourcemap_add_offset(decoded_map, location, source_index);
      }
    }
  }
  return MappedCode.from_processed(processed.code, decoded_map);
}
function processed_tag_to_code(processed, tag_name, original_attributes, generated_attributes, source2) {
  const { file_basename, get_location } = source2;
  const build_mapped_code = (code, offset) => MappedCode.from_source(slice_source(code, offset, source2));
  const original_tag_open = `<${tag_name}${original_attributes}>`;
  const tag_open = `<${tag_name}${generated_attributes}>`;
  let tag_open_code;
  if (original_tag_open.length !== tag_open.length) {
    const mappings = [
      [
        // start of tag
        [0, 0, 0, 0],
        // end of tag start
        [`<${tag_name}`.length, 0, 0, `<${tag_name}`.length]
      ]
    ];
    const line = tag_open.split("\n").length - 1;
    const column = tag_open.length - (line === 0 ? 0 : tag_open.lastIndexOf("\n")) - 1;
    while (mappings.length <= line) {
      mappings.push([[0, 0, 0, `<${tag_name}`.length]]);
    }
    mappings[line].push([
      column,
      0,
      original_tag_open.split("\n").length - 1,
      original_tag_open.length - original_tag_open.lastIndexOf("\n") - 1
    ]);
    const map = {
      version: 3,
      names: [],
      sources: [file_basename],
      mappings
    };
    sourcemap_add_offset(map, get_location(0), 0);
    tag_open_code = MappedCode.from_processed(tag_open, map);
  } else {
    tag_open_code = build_mapped_code(tag_open, 0);
  }
  const tag_close = `</${tag_name}>`;
  const tag_close_code = build_mapped_code(
    tag_close,
    original_tag_open.length + source2.source.length
  );
  parse_attached_sourcemap(processed, tag_name);
  const content_code = processed_content_to_code(
    processed,
    get_location(original_tag_open.length),
    file_basename
  );
  return tag_open_code.concat(content_code).concat(tag_close_code);
}
var attribute_pattern = /([\w-$]+\b)(?:=(?:"([^"]*)"|'([^']*)'|(\S+)))?/g;
function parse_tag_attributes(str) {
  const attrs = {};
  let match;
  while ((match = attribute_pattern.exec(str)) !== null) {
    const name = match[1];
    const value = match[2] || match[3] || match[4];
    attrs[name] = !value || value;
  }
  return attrs;
}
function stringify_tag_attributes(attributes) {
  if (!attributes) return;
  let value = Object.entries(attributes).map(([key2, value2]) => value2 === true ? key2 : `${key2}="${value2}"`).join(" ");
  if (value) {
    value = " " + value;
  }
  return value;
}
var regex_style_tags = /<!--[^]*?-->|<style((?:\s+[^=>'"/\s]+=(?:"[^"]*"|'[^']*'|[^>\s]+)|\s+[^=>'"/\s]+)*\s*)(?:\/>|>([\S\s]*?)<\/style>)/g;
var regex_script_tags = /<!--[^]*?-->|<script((?:\s+[^=>'"/\s]+=(?:"[^"]*"|'[^']*'|[^>\s]+)|\s+[^=>'"/\s]+)*\s*)(?:\/>|>([\S\s]*?)<\/script>)/g;
async function process_tag(tag_name, preprocessor, source2) {
  const { filename: filename2, source: markup } = source2;
  const tag_regex = tag_name === "style" ? regex_style_tags : regex_script_tags;
  const dependencies = [];
  async function process_single_tag(tag_with_content, attributes = "", content = "", tag_offset) {
    const no_change = () => MappedCode.from_source(slice_source(tag_with_content, tag_offset, source2));
    if (!attributes && !content) return no_change();
    const processed = await preprocessor({
      content: content || "",
      attributes: parse_tag_attributes(attributes || ""),
      markup,
      filename: filename2
    });
    if (!processed) return no_change();
    if (processed.dependencies) dependencies.push(...processed.dependencies);
    if (!processed.map && processed.code === content) return no_change();
    return processed_tag_to_code(
      processed,
      tag_name,
      attributes,
      stringify_tag_attributes(processed.attributes) ?? attributes,
      slice_source(content, tag_offset, source2)
    );
  }
  const { string: string2, map } = await replace_in_code(tag_regex, process_single_tag, source2);
  return { string: string2, map, dependencies };
}
async function process_markup(process2, source2) {
  const processed = await process2({
    content: source2.source,
    filename: source2.filename
  });
  if (processed) {
    return {
      string: processed.code,
      map: processed.map ? (
        // TODO: can we use decode_sourcemap?
        typeof processed.map === "string" ? JSON.parse(processed.map) : processed.map
      ) : void 0,
      dependencies: processed.dependencies
    };
  } else {
    return {};
  }
}
async function preprocess(source2, preprocessor, options) {
  const filename2 = options && options.filename || /** @type {any} */
  preprocessor.filename;
  const preprocessors = preprocessor ? Array.isArray(preprocessor) ? preprocessor : [preprocessor] : [];
  const result = new PreprocessResult(source2, filename2);
  for (const preprocessor2 of preprocessors) {
    if (preprocessor2.markup) {
      result.update_source(await process_markup(preprocessor2.markup, result));
    }
    if (preprocessor2.script) {
      result.update_source(await process_tag("script", preprocessor2.script, result));
    }
    if (preprocessor2.style) {
      result.update_source(await process_tag("style", preprocessor2.style, result));
    }
  }
  return result.to_processed();
}

// node_modules/svelte/src/compiler/migrate/index.js
var regex_style_tags2 = /(<style[^>]+>)([\S\s]*?)(<\/style>)/g;
var style_placeholder = "/*$$__STYLE_CONTENT__$$*/";
var has_migration_task = false;
var MigrationError = class extends Error {
  /**
   * @param {string} msg
   */
  constructor(msg) {
    super(msg);
  }
};
function migrate_css(state) {
  var _a2, _b2, _c, _d;
  if (!((_a2 = state.analysis.css.ast) == null ? void 0 : _a2.start)) return;
  let code = state.str.snip(
    state.analysis.css.ast.start,
    /** @type {number} */
    (_b2 = state.analysis.css.ast) == null ? void 0 : _b2.end
  ).toString();
  let starting = 0;
  const str = new MagicString(code);
  while (code) {
    if (code.startsWith(":has") || code.startsWith(":not") || code.startsWith(":is") || code.startsWith(":where")) {
      let start = code.indexOf("(") + 1;
      let is_global3 = false;
      const global_str = ":global";
      const next_global = code.indexOf(global_str);
      const str_between = code.substring(start, next_global);
      if (!str_between.trim()) {
        is_global3 = true;
        start += global_str.length;
      }
      let parenthesis = 1;
      let end = start;
      let char = code[end];
      while (parenthesis !== 0 && char) {
        if (char === "(") parenthesis++;
        if (char === ")") parenthesis--;
        end++;
        char = code[end];
      }
      if (start && end) {
        if (!is_global3) {
          str.prependLeft(starting + start, ":global(");
          str.appendRight(starting + end - 1, ")");
        }
        starting += end - 1;
        code = code.substring(end - 1);
        continue;
      }
    }
    starting++;
    code = code.substring(1);
  }
  state.str.update((_c = state.analysis.css.ast) == null ? void 0 : _c.start, (_d = state.analysis.css.ast) == null ? void 0 : _d.end, str.toString());
}
function migrate(source2, { filename: filename2, use_ts } = {}) {
  var _a2, _b2, _c;
  let og_source = source2;
  try {
    has_migration_task = false;
    const style_contents = [];
    source2 = source2.replace(regex_style_tags2, (_, start, content, end, idx) => {
      style_contents.push([idx + start.length, content]);
      return start + style_placeholder + end;
    });
    reset_warning_filter(() => false);
    reset(source2, { filename: filename2 ?? "(unknown)" });
    let parsed = parse2(source2);
    const { customElement: customElementOptions, ...parsed_options } = parsed.options || {};
    const combined_options = {
      ...validate_component_options({}, ""),
      ...parsed_options,
      customElementOptions,
      filename: filename2 ?? "(unknown)"
    };
    const str = new MagicString(source2);
    const analysis = analyze_component(parsed, source2, combined_options);
    const indent = guess_indent(source2);
    str.replaceAll(/(<svelte:options\s.*?\s?)accessors\s?/g, (_, $1) => $1);
    for (const content of style_contents) {
      str.overwrite(content[0], content[0] + style_placeholder.length, content[1]);
    }
    let state = {
      scope: analysis.instance.scope,
      analysis,
      filename: filename2,
      str,
      indent,
      props: [],
      props_insertion_point: ((_a2 = parsed.instance) == null ? void 0 : _a2.content.start) ?? 0,
      has_props_rune: false,
      has_type_or_fallback: false,
      end: source2.length,
      names: {
        props: analysis.root.unique("props").name,
        rest: analysis.root.unique("rest").name,
        // event stuff
        run: analysis.root.unique("run").name,
        handlers: analysis.root.unique("handlers").name,
        stopImmediatePropagation: analysis.root.unique("stopImmediatePropagation").name,
        preventDefault: analysis.root.unique("preventDefault").name,
        stopPropagation: analysis.root.unique("stopPropagation").name,
        once: analysis.root.unique("once").name,
        self: analysis.root.unique("self").name,
        trusted: analysis.root.unique("trusted").name,
        createBubbler: analysis.root.unique("createBubbler").name,
        bubble: analysis.root.unique("bubble").name,
        passive: analysis.root.unique("passive").name,
        nonpassive: analysis.root.unique("nonpassive").name
      },
      legacy_imports: /* @__PURE__ */ new Set(),
      script_insertions: /* @__PURE__ */ new Set(),
      derived_components: /* @__PURE__ */ new Map(),
      derived_labeled_statements: /* @__PURE__ */ new Set(),
      has_svelte_self: false,
      uses_ts: (
        // Some people could use jsdoc but have a tsconfig.json, so double-check file for jsdoc indicators
        use_ts && !source2.includes("@type {") || !!((_b2 = parsed.instance) == null ? void 0 : _b2.attributes.some(
          (attr) => attr.name === "lang" && /** @type {any} */
          attr.value[0].data === "ts"
        ))
      )
    };
    if (parsed.module) {
      const context = parsed.module.attributes.find((attr) => attr.name === "context");
      if (context) {
        state.str.update(context.start, context.end, "module");
      }
    }
    if (parsed.instance) {
      walk(parsed.instance.content, state, instance_script);
    }
    state = { ...state, scope: analysis.template.scope };
    walk(parsed.fragment, state, template2);
    let insertion_point = parsed.instance ? (
      /** @type {number} */
      parsed.instance.content.start
    ) : 0;
    const need_script = state.legacy_imports.size > 0 || state.derived_components.size > 0 || state.script_insertions.size > 0 || state.props.length > 0 || analysis.uses_rest_props || analysis.uses_props || state.has_svelte_self;
    if (!parsed.instance && need_script) {
      str.appendRight(0, "<script>");
    }
    if (state.has_svelte_self && filename2) {
      const file = filename2.split("/").pop();
      str.appendRight(
        insertion_point,
        `
${indent}import ${state.analysis.name} from './${file}';`
      );
    }
    const specifiers = [...state.legacy_imports].map((imported) => {
      const local = state.names[imported];
      return imported === local ? imported : `${imported} as ${local}`;
    });
    const legacy_import = `import { ${specifiers.join(", ")} } from 'svelte/legacy';
`;
    if (state.legacy_imports.size > 0) {
      str.appendRight(insertion_point, `
${indent}${legacy_import}`);
    }
    if (state.script_insertions.size > 0) {
      str.appendRight(
        insertion_point,
        `
${indent}${[...state.script_insertions].join(`
${indent}`)}`
      );
    }
    insertion_point = state.props_insertion_point;
    if (state.props.length > 0 || analysis.uses_rest_props || analysis.uses_props) {
      const has_many_props = state.props.length > 3;
      const newline_separator = `
${indent}${indent}`;
      const props_separator = has_many_props ? newline_separator : " ";
      let props = "";
      if (analysis.uses_props) {
        props = `...${state.names.props}`;
      } else {
        props = state.props.filter((prop2) => !prop2.type_only).map((prop2) => {
          let prop_str = prop2.local === prop2.exported ? prop2.local : `${prop2.exported}: ${prop2.local}`;
          if (prop2.bindable) {
            prop_str += ` = $bindable(${prop2.init})`;
          } else if (prop2.init) {
            prop_str += ` = ${prop2.init}`;
          }
          return prop_str;
        }).join(`,${props_separator}`);
        if (analysis.uses_rest_props) {
          props += `${state.props.length > 0 ? `,${props_separator}` : ""}...${state.names.rest}`;
        }
      }
      if (state.has_props_rune) {
        str.appendRight(insertion_point, ` ${props},`);
      } else {
        const type_name = state.scope.root.unique("Props").name;
        let type = "";
        if (state.has_type_or_fallback || state.props.every((prop2) => prop2.slot_name)) {
          if (state.uses_ts) {
            type = `interface ${type_name} {${newline_separator}${state.props.map((prop2) => {
              const comment = prop2.comment ? `${prop2.comment}${newline_separator}` : "";
              return `${comment}${prop2.exported}${prop2.optional ? "?" : ""}: ${prop2.type};`;
            }).join(newline_separator)}`;
            if (analysis.uses_props || analysis.uses_rest_props) {
              type += `${state.props.length > 0 ? newline_separator : ""}[key: string]: any`;
            }
            type += `
${indent}}`;
          } else {
            type = `/**
${indent} * @typedef {Object} ${type_name}${state.props.map((prop2) => {
              return `
${indent} * @property {${prop2.type}} ${prop2.optional ? `[${prop2.exported}]` : prop2.exported}${prop2.comment ? ` - ${prop2.comment}` : ""}`;
            }).join(``)}
${indent} */`;
          }
        }
        let props_declaration = `let {${props_separator}${props}${has_many_props ? `
${indent}` : " "}}`;
        if (state.uses_ts) {
          if (type) {
            props_declaration = `${type}

${indent}${props_declaration}`;
          }
          props_declaration = `${props_declaration}${type ? `: ${type_name}` : ""} = $props();`;
        } else {
          if (type) {
            props_declaration = `${state.props.length > 0 ? `${type}

${indent}` : ""}/** @type {${state.props.length > 0 ? type_name : ""}${analysis.uses_props || analysis.uses_rest_props ? `${state.props.length > 0 ? " & " : ""}{ [key: string]: any }` : ""}} */
${indent}${props_declaration}`;
          }
          props_declaration = `${props_declaration} = $props();`;
        }
        props_declaration = `
${indent}${props_declaration}`;
        str.appendRight(insertion_point, props_declaration);
      }
    }
    let needs_reordering = false;
    for (const [node, { dependencies }] of state.analysis.reactive_statements) {
      let ids = [];
      if (node.body.type === "ExpressionStatement" && node.body.expression.type === "AssignmentExpression") {
        ids = extract_identifiers(node.body.expression.left).map((id2) => state.scope.get(id2.name)).filter((id2) => !!id2);
      }
      if (dependencies.some(
        (dep) => !ids.includes(dep) && (dep.kind === "prop" || dep.kind === "bindable_prop" ? state.props_insertion_point : (
          /** @type {number} */
          dep.node.start
        )) > /** @type {number} */
        node.start
      )) {
        needs_reordering = true;
        break;
      }
    }
    if (needs_reordering) {
      const nodes = Array.from(state.analysis.reactive_statements.keys());
      for (const node of nodes) {
        const { start, end } = get_node_range(source2, node);
        str.appendLeft(end, "\n");
        str.move(
          start,
          end,
          /** @type {number} */
          (_c = parsed.instance) == null ? void 0 : _c.content.end
        );
        str.update(start - (source2[start - 2] === "\r" ? 2 : 1), start, "");
      }
    }
    insertion_point = parsed.instance ? (
      /** @type {number} */
      parsed.instance.content.end
    ) : insertion_point;
    if (state.derived_components.size > 0) {
      str.appendRight(
        insertion_point,
        `
${indent}${[...state.derived_components.entries()].map(([init2, name]) => `const ${name} = $derived(${init2});`).join(`
${indent}`)}
`
      );
    }
    if (state.props.length > 0 && state.analysis.accessors) {
      str.appendRight(
        insertion_point,
        `
${indent}export {${state.props.reduce((acc, prop2) => prop2.slot_name || prop2.type_only ? acc : `${acc}
${indent}	${prop2.local},`, "")}
${indent}}
`
      );
    }
    if (!parsed.instance && need_script) {
      str.appendRight(insertion_point, "\n<\/script>\n\n");
    }
    migrate_css(state);
    return {
      code: str.toString()
    };
  } catch (e2) {
    if (!(e2 instanceof MigrationError)) {
      console.error("Error while migrating Svelte code", e2);
    }
    has_migration_task = true;
    return {
      code: `<!-- @migration-task Error while migrating Svelte code: ${/** @type {any} */
      e2.message} -->
${og_source}`
    };
  } finally {
    if (has_migration_task) {
      console.log(
        `One or more \`@migration-task\` comments were added to ${filename2 ? `\`${filename2}\`` : "a file (unfortunately we don't know the name)"}, please check them and complete the migration manually.`
      );
    }
  }
}
var instance_script = {
  _(node, { state, next: next2 }) {
    const comments = node.leadingComments;
    if (comments) {
      for (const comment of comments) {
        if (comment.type === "Line") {
          const migrated = migrate_svelte_ignore(comment.value);
          if (migrated !== comment.value) {
            state.str.overwrite(comment.start + "//".length, comment.end, migrated);
          }
        }
      }
    }
    next2();
  },
  Identifier(node, { state, path }) {
    handle_identifier(node, state, path);
  },
  ImportDeclaration(node, { state }) {
    state.props_insertion_point = node.end ?? state.props_insertion_point;
    if (node.source.value === "svelte") {
      let illegal_specifiers = [];
      let removed_specifiers = 0;
      for (let specifier of node.specifiers) {
        if (specifier.type === "ImportSpecifier" && ["beforeUpdate", "afterUpdate"].includes(specifier.imported.name)) {
          const references = state.scope.references.get(specifier.local.name);
          if (!references) {
            let end = (
              /** @type {number} */
              state.str.original.indexOf(",", specifier.end) !== -1 && state.str.original.indexOf(",", specifier.end) < state.str.original.indexOf("}", specifier.end) ? state.str.original.indexOf(",", specifier.end) + 1 : specifier.end
            );
            while (state.str.original[end].trim() === "") end++;
            state.str.remove(
              /** @type {number} */
              specifier.start,
              end
            );
            removed_specifiers++;
            continue;
          }
          illegal_specifiers.push(specifier.imported.name);
        }
      }
      if (removed_specifiers === node.specifiers.length) {
        state.str.remove(
          /** @type {number} */
          node.start,
          /** @type {number} */
          node.end
        );
      }
      if (illegal_specifiers.length > 0) {
        throw new MigrationError(
          `Can't migrate code with ${illegal_specifiers.join(" and ")}. Please migrate by hand.`
        );
      }
    }
  },
  ExportNamedDeclaration(node, { state, next: next2 }) {
    if (node.declaration) {
      next2();
      return;
    }
    let count_removed = 0;
    for (const specifier of node.specifiers) {
      const binding = state.scope.get(specifier.local.name);
      if ((binding == null ? void 0 : binding.kind) === "bindable_prop") {
        state.str.remove(
          /** @type {number} */
          specifier.start,
          /** @type {number} */
          specifier.end
        );
        count_removed++;
      }
    }
    if (count_removed === node.specifiers.length) {
      state.str.remove(
        /** @type {number} */
        node.start,
        /** @type {number} */
        node.end
      );
    }
  },
  VariableDeclaration(node, { state, path, visit, next: next2 }) {
    var _a2, _b2, _c, _d, _e, _f, _g;
    if (state.scope !== state.analysis.instance.scope) {
      return;
    }
    let nr_of_props = 0;
    for (const declarator2 of node.declarations) {
      if (state.analysis.runes) {
        if (get_rune(declarator2.init, state.scope) === "$props") {
          state.props_insertion_point = /** @type {number} */
          declarator2.id.start + 1;
          state.has_props_rune = true;
        }
        continue;
      }
      let bindings;
      try {
        bindings = state.scope.get_bindings(declarator2);
      } catch (e2) {
        next2();
        continue;
      }
      const has_state = bindings.some((binding) => binding.kind === "state");
      const has_props = bindings.some((binding) => binding.kind === "bindable_prop");
      if (!has_state && !has_props) {
        next2();
        continue;
      }
      if (has_props) {
        nr_of_props++;
        if (declarator2.id.type !== "Identifier") {
          throw new MigrationError(
            "Encountered an export declaration pattern that is not supported for automigration."
          );
        }
        const name = declarator2.id.name;
        const binding = (
          /** @type {Binding} */
          state.scope.get(name)
        );
        if (state.analysis.uses_props && (declarator2.init || binding.updated)) {
          throw new MigrationError(
            "$$props is used together with named props in a way that cannot be automatically migrated."
          );
        }
        const prop2 = state.props.find((prop3) => prop3.exported === (binding.prop_alias || name));
        if (prop2) {
          next2();
          prop2.init = declarator2.init ? state.str.snip(
            /** @type {number} */
            declarator2.init.start,
            /** @type {number} */
            declarator2.init.end
          ).toString() : "";
          prop2.bindable = binding.updated;
          prop2.exported = binding.prop_alias || name;
          prop2.type_only = false;
        } else {
          next2();
          state.props.push({
            local: name,
            exported: binding.prop_alias ? binding.prop_alias : name,
            init: declarator2.init ? state.str.snip(
              /** @type {number} */
              declarator2.init.start,
              /** @type {number} */
              declarator2.init.end
            ).toString() : "",
            optional: !!declarator2.init,
            bindable: binding.updated,
            ...extract_type_and_comment(declarator2, state, path)
          });
        }
        state.props_insertion_point = /** @type {number} */
        declarator2.end;
        state.str.update(
          /** @type {number} */
          declarator2.start,
          /** @type {number} */
          declarator2.end,
          ""
        );
        continue;
      }
      if (declarator2.init) {
        let { start, end } = (
          /** @type {{ start: number, end: number }} */
          declarator2.init
        );
        if (declarator2.init.type === "SequenceExpression") {
          while (state.str.original[start] !== "(") start -= 1;
          while (state.str.original[end - 1] !== ")") end += 1;
        }
        state.str.prependLeft(start, "$state(");
        state.str.appendRight(end, ")");
      } else {
        let assignment_in_labeled;
        let labeled_statement;
        const possible_derived = bindings.every(
          (binding) => binding.references.every((reference) => {
            const declaration2 = reference.path.find((el) => el.type === "VariableDeclaration");
            const assignment2 = reference.path.find((el) => el.type === "AssignmentExpression");
            const update2 = reference.path.find((el) => el.type === "UpdateExpression");
            const labeled2 = (
              /** @type {LabeledStatement | undefined} */
              reference.path.find((el) => el.type === "LabeledStatement" && el.label.name === "$")
            );
            if (assignment2 && labeled2 && // ensure that $: foo = bar * 2 is not counted as a reassignment of bar
            (labeled2.body.type !== "ExpressionStatement" || labeled2.body.expression !== assignment2 || assignment2.left.type === "Identifier" && assignment2.left.name === binding.node.name)) {
              if (assignment_in_labeled) return false;
              assignment_in_labeled = /** @type {AssignmentExpression} */
              assignment2;
              labeled_statement = labeled2;
            }
            return !update2 && (declaration2 && binding.initial || labeled2 && assignment2 || !labeled2 && !assignment2);
          })
        );
        const labeled_has_single_assignment = (labeled_statement == null ? void 0 : labeled_statement.body.type) === "BlockStatement" && labeled_statement.body.body.length === 1 && labeled_statement.body.body[0].type === "ExpressionStatement";
        const is_expression_assignment = (labeled_statement == null ? void 0 : labeled_statement.body.type) === "ExpressionStatement" && labeled_statement.body.expression.type === "AssignmentExpression";
        let should_be_state = false;
        if (is_expression_assignment) {
          const body = (
            /**@type {ExpressionStatement}*/
            labeled_statement == null ? void 0 : labeled_statement.body
          );
          const expression = (
            /**@type {AssignmentExpression}*/
            body.expression
          );
          const [, ids] = extract_all_identifiers_from_expression(expression.right);
          if (ids.length === 0) {
            should_be_state = true;
            state.derived_labeled_statements.add(
              /** @type {LabeledStatement} */
              labeled_statement
            );
          }
        }
        if (!should_be_state && possible_derived && assignment_in_labeled && labeled_statement && (labeled_has_single_assignment || is_expression_assignment)) {
          const indent = state.str.original.substring(
            state.str.original.lastIndexOf(
              "\n",
              /** @type {number} */
              node.start
            ) + 1,
            /** @type {number} */
            node.start
          );
          if (labeled_statement.body.type === "BlockStatement" && labeled_statement.body.body[0].leadingComments) {
            for (let comment of labeled_statement.body.body[0].leadingComments) {
              state.str.prependLeft(
                /** @type {number} */
                node.start,
                comment.type === "Block" ? `/*${comment.value}*/
${indent}` : `// ${comment.value}
${indent}`
              );
            }
          }
          state.str.appendRight(
            /** @type {number} */
            ((_a2 = declarator2.id.typeAnnotation) == null ? void 0 : _a2.end) ?? declarator2.id.end,
            " = $derived("
          );
          visit(assignment_in_labeled.right);
          state.str.appendRight(
            /** @type {number} */
            ((_b2 = declarator2.id.typeAnnotation) == null ? void 0 : _b2.end) ?? declarator2.id.end,
            state.str.snip(
              /** @type {number} */
              assignment_in_labeled.right.start,
              /** @type {number} */
              assignment_in_labeled.right.end
            ).toString()
          );
          state.str.remove(
            /** @type {number} */
            labeled_statement.start,
            /** @type {number} */
            labeled_statement.end
          );
          state.str.appendRight(
            /** @type {number} */
            ((_c = declarator2.id.typeAnnotation) == null ? void 0 : _c.end) ?? declarator2.id.end,
            ")"
          );
          state.derived_labeled_statements.add(labeled_statement);
          if (labeled_statement.body.type === "BlockStatement" && labeled_statement.body.body[0].trailingComments) {
            for (let comment of labeled_statement.body.body[0].trailingComments) {
              state.str.appendRight(
                /** @type {number} */
                ((_d = declarator2.id.typeAnnotation) == null ? void 0 : _d.end) ?? declarator2.id.end,
                comment.type === "Block" ? `
${indent}/*${comment.value}*/` : `
${indent}// ${comment.value}`
              );
            }
          }
        } else {
          state.str.prependLeft(
            /** @type {number} */
            ((_e = declarator2.id.typeAnnotation) == null ? void 0 : _e.end) ?? declarator2.id.end,
            " = $state("
          );
          if (should_be_state) {
            state.str.appendRight(
              /** @type {number} */
              ((_f = declarator2.id.typeAnnotation) == null ? void 0 : _f.end) ?? declarator2.id.end,
              state.str.snip(
                /** @type {number} */
                /** @type {AssignmentExpression} */
                assignment_in_labeled.right.start,
                /** @type {number} */
                /** @type {AssignmentExpression} */
                assignment_in_labeled.right.end
              ).toString()
            );
            state.str.remove(
              /** @type {number} */
              /** @type {LabeledStatement} */
              labeled_statement.start,
              /** @type {number} */
              /** @type {LabeledStatement} */
              labeled_statement.end
            );
          }
          state.str.appendRight(
            /** @type {number} */
            ((_g = declarator2.id.typeAnnotation) == null ? void 0 : _g.end) ?? declarator2.id.end,
            ")"
          );
        }
      }
    }
    if (nr_of_props === node.declarations.length) {
      let start = (
        /** @type {number} */
        node.start
      );
      let end = (
        /** @type {number} */
        node.end
      );
      const parent = path.at(-1);
      if ((parent == null ? void 0 : parent.type) === "ExportNamedDeclaration") {
        start = /** @type {number} */
        parent.start;
        end = /** @type {number} */
        parent.end;
      }
      while (state.str.original[start] !== "\n") start--;
      while (state.str.original[end] !== "\n") end++;
      state.str.update(start, end, "");
    }
  },
  BreakStatement(node, { state, path }) {
    var _a2;
    if (path[1].type !== "LabeledStatement") return;
    if (((_a2 = node.label) == null ? void 0 : _a2.name) !== "$") return;
    state.str.update(
      /** @type {number} */
      node.start,
      /** @type {number} */
      node.end,
      "return;"
    );
  },
  LabeledStatement(node, { path, state, next: next2 }) {
    if (state.analysis.runes) return;
    if (path.length > 1) return;
    if (node.label.name !== "$") return;
    if (state.derived_labeled_statements.has(node)) return;
    next2();
    if (node.body.type === "ExpressionStatement" && node.body.expression.type === "AssignmentExpression") {
      const ids = extract_identifiers(node.body.expression.left);
      const [, expression_ids] = extract_all_identifiers_from_expression(
        node.body.expression.right
      );
      const bindings = ids.map((id2) => state.scope.get(id2.name));
      const reassigned_bindings = bindings.filter((b) => b == null ? void 0 : b.reassigned);
      if (reassigned_bindings.length === 0 && !bindings.some((b) => (b == null ? void 0 : b.kind) === "store_sub") && node.body.expression.left.type !== "MemberExpression") {
        let { start, end } = (
          /** @type {{ start: number, end: number }} */
          node.body.expression.right
        );
        state.str.update(
          /** @type {number} */
          node.start,
          /** @type {number} */
          node.body.expression.start,
          "let "
        );
        if (node.body.expression.right.type === "SequenceExpression") {
          while (state.str.original[start] !== "(") start -= 1;
          while (state.str.original[end - 1] !== ")") end += 1;
        }
        state.str.prependRight(start, `$derived(`);
        if (state.str.original[
          /** @type {number} */
          node.body.start
        ] !== "(") {
          state.str.appendLeft(end, `)`);
        }
        return;
      } else {
        for (const binding of reassigned_bindings) {
          if (binding && (ids.includes(binding.node) || expression_ids.length === 0)) {
            const init2 = binding.kind === "state" ? " = $state()" : expression_ids.length === 0 ? ` = $state(${state.str.original.substring(
              /** @type {number} */
              node.body.expression.right.start,
              node.body.expression.right.end
            )})` : "";
            state.str.prependLeft(
              /** @type {number} */
              node.start,
              `let ${binding.node.name}${init2};
${state.indent}`
            );
          }
        }
        if (expression_ids.length === 0 && !bindings.some((b) => (b == null ? void 0 : b.kind) === "store_sub")) {
          state.str.remove(
            /** @type {number} */
            node.start,
            /** @type {number} */
            node.end
          );
          return;
        }
      }
    }
    state.legacy_imports.add("run");
    const is_block_stmt = node.body.type === "BlockStatement";
    const start_end = (
      /** @type {number} */
      node.body.start
    );
    if (is_block_stmt) {
      state.str.update(
        /** @type {number} */
        node.start,
        start_end + 1,
        `${state.names.run}(() => {`
      );
      const end = (
        /** @type {number} */
        node.body.end
      );
      state.str.update(end - 1, end, "});");
    } else {
      state.str.update(
        /** @type {number} */
        node.start,
        start_end,
        `${state.names.run}(() => {
${state.indent}`
      );
      state.str.indent(state.indent, {
        exclude: [
          [
            0,
            /** @type {number} */
            node.body.start
          ],
          [
            /** @type {number} */
            node.body.end,
            state.end
          ]
        ]
      });
      state.str.appendLeft(
        /** @type {number} */
        node.end,
        `
${state.indent}});`
      );
    }
  }
};
function trim_block(state, start, end) {
  const original = state.str.snip(start, end).toString();
  const without_parens = original.substring(1, original.length - 1);
  if (without_parens.trim().length !== without_parens.length) {
    state.str.update(start + 1, end - 1, without_parens.trim());
  }
}
var template2 = {
  Identifier(node, { state, path }) {
    handle_identifier(node, state, path);
  },
  RegularElement(node, { state, path, next: next2 }) {
    migrate_slot_usage(node, path, state);
    handle_events(node, state);
    const node_name = node.name.replace(/[a-zA-Z-]*:/g, "");
    if (state.analysis.source[node.end - 2] === "/" && !is_void(node_name) && !is_svg(node_name)) {
      let trimmed_position = node.end - 2;
      while (state.str.original.charAt(trimmed_position - 1) === " ") trimmed_position--;
      state.str.remove(trimmed_position, node.end - 1);
      state.str.appendRight(node.end, `</${node.name}>`);
    }
    next2();
  },
  SvelteSelf(node, { state, next: next2 }) {
    const source2 = state.str.original.substring(node.start, node.end);
    if (!state.filename) {
      const indent = guess_indent(source2);
      has_migration_task = true;
      state.str.prependRight(
        node.start,
        `<!-- @migration-task: svelte:self is deprecated, import this Svelte file into itself instead -->
${indent}`
      );
      next2();
      return;
    }
    state.str.overwrite(
      node.start + 1,
      node.start + 1 + "svelte:self".length,
      `${state.analysis.name}`
    );
    if (node.fragment.nodes.length > 0) {
      state.str.overwrite(
        state.str.original.lastIndexOf("<", node.end) + 2,
        node.end - 1,
        `${state.analysis.name}`
      );
    } else if (!source2.endsWith("/>")) {
      state.str.overwrite(
        node.start + source2.lastIndexOf("</", node.end) + 2,
        node.end - 1,
        `${state.analysis.name}`
      );
    }
    state.has_svelte_self = true;
    next2();
  },
  SvelteElement(node, { state, path, next: next2 }) {
    migrate_slot_usage(node, path, state);
    if (node.tag.type === "Literal") {
      let is_static = true;
      let a = (
        /** @type {number} */
        node.tag.start
      );
      let b = (
        /** @type {number} */
        node.tag.end
      );
      let quote_mark = state.str.original[a - 1];
      while (state.str.original[--a] !== "=") {
        if (state.str.original[a] === "{") {
          is_static = false;
          break;
        }
      }
      if (is_static && state.str.original[b] === quote_mark) {
        state.str.prependLeft(a + 1, "{");
        state.str.appendRight(
          /** @type {number} */
          node.tag.end + 1,
          "}"
        );
      }
    }
    handle_events(node, state);
    next2();
  },
  Component(node, { state, path, next: next2 }) {
    next2();
    migrate_slot_usage(node, path, state);
  },
  SvelteComponent(node, { state, next: next2, path }) {
    next2();
    migrate_slot_usage(node, path, state);
    let expression = state.str.snip(
      /** @type {number} */
      node.expression.start,
      /** @type {number} */
      node.expression.end
    ).toString();
    if (node.expression.type !== "Identifier" && node.expression.type !== "MemberExpression" || !regex_valid_component_name.test(expression)) {
      let current_expression = expression;
      expression = state.scope.generate("SvelteComponent");
      let needs_derived = true;
      for (let i = path.length - 1; i >= 0; i--) {
        const part = path[i];
        if (part.type === "EachBlock" || part.type === "AwaitBlock" || part.type === "IfBlock" || part.type === "SnippetBlock" || part.type === "Component" || part.type === "SvelteComponent") {
          let position = node.start;
          if (i !== path.length - 1) {
            for (let modifier = 1; modifier < path.length - i; modifier++) {
              const path_part = path[i + modifier];
              if ("start" in path_part) {
                position = /** @type {number} */
                path_part.start;
                break;
              }
            }
          }
          const indent = state.str.original.substring(
            state.str.original.lastIndexOf("\n", position) + 1,
            position
          );
          state.str.appendRight(
            position,
            `{@const ${expression} = ${current_expression}}
${indent}`
          );
          needs_derived = false;
          break;
        }
      }
      if (needs_derived) {
        if (state.derived_components.has(current_expression)) {
          expression = /** @type {string} */
          state.derived_components.get(current_expression);
        } else {
          state.derived_components.set(current_expression, expression);
        }
      }
    }
    state.str.overwrite(node.start + 1, node.start + node.name.length + 1, expression);
    if (state.str.original.substring(node.end - node.name.length - 1, node.end - 1) === node.name) {
      state.str.overwrite(node.end - node.name.length - 1, node.end - 1, expression);
    }
    let this_pos = state.str.original.lastIndexOf("this", node.expression.start);
    while (!state.str.original.charAt(this_pos - 1).trim()) this_pos--;
    const end_pos = state.str.original.indexOf("}", node.expression.end) + 1;
    state.str.remove(this_pos, end_pos);
  },
  SvelteFragment(node, { state, path, next: next2 }) {
    migrate_slot_usage(node, path, state);
    next2();
  },
  SvelteWindow(node, { state, next: next2 }) {
    handle_events(node, state);
    next2();
  },
  SvelteBody(node, { state, next: next2 }) {
    handle_events(node, state);
    next2();
  },
  SvelteDocument(node, { state, next: next2 }) {
    handle_events(node, state);
    next2();
  },
  SlotElement(node, { state, path, next: next2, visit }) {
    migrate_slot_usage(node, path, state);
    if (state.analysis.custom_element) return;
    let name = "children";
    let slot_name = "default";
    let slot_props = "{ ";
    for (const attr of node.attributes) {
      if (attr.type === "SpreadAttribute") {
        slot_props += `...${state.str.original.substring(
          /** @type {number} */
          attr.expression.start,
          attr.expression.end
        )}, `;
      } else if (attr.type === "Attribute") {
        if (attr.name === "slot") {
          continue;
        }
        if (attr.name === "name") {
          slot_name = /** @type {any} */
          attr.value[0].data;
        } else {
          const attr_value = attr.value === true || Array.isArray(attr.value) ? attr.value : [attr.value];
          let value = "true";
          if (attr_value !== true) {
            const first = attr_value[0];
            const last = attr_value[attr_value.length - 1];
            for (const attr2 of attr_value) {
              visit(attr2);
            }
            value = state.str.snip(
              first.type === "Text" ? first.start - 1 : (
                /** @type {number} */
                first.expression.start
              ),
              last.type === "Text" ? last.end + 1 : (
                /** @type {number} */
                last.expression.end
              )
            ).toString();
          }
          slot_props += value === attr.name ? `${value}, ` : `${attr.name}: ${value}, `;
        }
      }
    }
    slot_props += "}";
    if (slot_props === "{ }") {
      slot_props = "";
    }
    const existing_prop = state.props.find((prop2) => prop2.slot_name === slot_name);
    if (existing_prop) {
      name = existing_prop.local;
    } else if (slot_name !== "default") {
      name = state.scope.generate(slot_name);
      if (name !== slot_name) {
        throw new MigrationError(
          "This migration would change the name of a slot making the component unusable"
        );
      }
    }
    if (!existing_prop) {
      state.props.push({
        local: name,
        exported: name,
        init: "",
        bindable: false,
        optional: true,
        slot_name,
        type: `import('svelte').${slot_props ? "Snippet<[any]>" : "Snippet"}`
      });
    } else if (existing_prop.needs_refine_type) {
      existing_prop.type = `import('svelte').${slot_props ? "Snippet<[any]>" : "Snippet"}`;
      existing_prop.needs_refine_type = false;
    }
    if (node.fragment.nodes.length > 0) {
      next2();
      state.str.update(
        node.start,
        node.fragment.nodes[0].start,
        `{#if ${name}}{@render ${state.analysis.uses_props ? `${state.names.props}.` : ""}${name}(${slot_props})}{:else}`
      );
      state.str.update(node.fragment.nodes[node.fragment.nodes.length - 1].end, node.end, "{/if}");
    } else {
      state.str.update(
        node.start,
        node.end,
        `{@render ${state.analysis.uses_props ? `${state.names.props}.` : ""}${name}?.(${slot_props})}`
      );
    }
  },
  Comment(node, { state }) {
    const migrated = migrate_svelte_ignore(node.data);
    if (migrated !== node.data) {
      state.str.overwrite(node.start + "<!--".length, node.end - "-->".length, migrated);
    }
  },
  HtmlTag(node, { state, next: next2 }) {
    trim_block(state, node.start, node.end);
    next2();
  },
  ConstTag(node, { state, next: next2 }) {
    trim_block(state, node.start, node.end);
    next2();
  },
  IfBlock(node, { state, next: next2 }) {
    const start = node.start;
    const end = state.str.original.indexOf("}", node.test.end) + 1;
    trim_block(state, start, end);
    next2();
  },
  AwaitBlock(node, { state, next: next2 }) {
    var _a2, _b2, _c, _d, _e;
    const start = node.start;
    const end = state.str.original.indexOf(
      "}",
      node.pending !== null ? node.expression.end : (_a2 = node.value) == null ? void 0 : _a2.end
    ) + 1;
    trim_block(state, start, end);
    if (node.pending !== null) {
      const start2 = state.str.original.lastIndexOf("{", (_b2 = node.value) == null ? void 0 : _b2.start);
      const end2 = state.str.original.indexOf("}", (_c = node.value) == null ? void 0 : _c.end) + 1;
      trim_block(state, start2, end2);
    }
    if (node.catch !== null) {
      const start2 = state.str.original.lastIndexOf("{", (_d = node.error) == null ? void 0 : _d.start);
      const end2 = state.str.original.indexOf("}", (_e = node.error) == null ? void 0 : _e.end) + 1;
      trim_block(state, start2, end2);
    }
    next2();
  },
  KeyBlock(node, { state, next: next2 }) {
    const start = node.start;
    const end = state.str.original.indexOf("}", node.expression.end) + 1;
    trim_block(state, start, end);
    next2();
  }
};
function migrate_slot_usage(node, path, state) {
  const parent = path.at(-2);
  if ((parent == null ? void 0 : parent.type) !== "Component" && (parent == null ? void 0 : parent.type) !== "SvelteComponent" && node.type !== "Component" && node.type !== "SvelteComponent") {
    return;
  }
  let snippet_name = "children";
  let snippet_props = [];
  let removal_queue = [];
  for (let attribute of node.attributes) {
    if (attribute.type === "Attribute" && attribute.name === "slot" && is_text_attribute(attribute)) {
      snippet_name = attribute.value[0].data;
      if (snippet_name === "default") {
        snippet_name = "children";
      }
      if (!regex_is_valid_identifier.test(snippet_name)) {
        has_migration_task = true;
        state.str.appendLeft(
          node.start,
          `<!-- @migration-task: migrate this slot by hand, \`${snippet_name}\` is an invalid identifier -->
${state.indent}`
        );
        return;
      }
      if ((parent == null ? void 0 : parent.type) === "Component" || (parent == null ? void 0 : parent.type) === "SvelteComponent") {
        for (let attribute2 of parent.attributes) {
          if (attribute2.type === "Attribute" || attribute2.type === "BindDirective") {
            if (attribute2.name === snippet_name) {
              state.str.appendLeft(
                node.start,
                `<!-- @migration-task: migrate this slot by hand, \`${snippet_name}\` would shadow a prop on the parent component -->
${state.indent}`
              );
              return;
            }
          }
        }
      }
      for (let remove_let of removal_queue) {
        remove_let();
      }
      state.str.remove(attribute.start, attribute.end);
    }
    if (attribute.type === "LetDirective") {
      snippet_props.push(
        attribute.name + (attribute.expression ? `: ${state.str.original.substring(
          /** @type {number} */
          attribute.expression.start,
          /** @type {number} */
          attribute.expression.end
        )}` : "")
      );
      removal_queue.push(() => state.str.remove(attribute.start, attribute.end));
    }
  }
  if (removal_queue.length > 0) {
    for (let remove_let of removal_queue) {
      remove_let();
    }
  }
  if (node.type === "SvelteFragment" && node.fragment.nodes.length > 0) {
    state.str.remove(node.start, node.fragment.nodes[0].start);
    state.str.remove(node.fragment.nodes[node.fragment.nodes.length - 1].end, node.end);
  }
  const props = snippet_props.length > 0 ? `{ ${snippet_props.join(", ")} }` : "";
  if (snippet_name === "children" && node.type !== "SvelteFragment") {
    if (snippet_props.length === 0) return;
    let inner_start = 0;
    let inner_end = 0;
    for (let i = 0; i < node.fragment.nodes.length; i++) {
      const inner = node.fragment.nodes[i];
      const is_empty_text = inner.type === "Text" && !inner.data.trim();
      if ((inner.type === "RegularElement" || inner.type === "SvelteElement" || inner.type === "Component" || inner.type === "SvelteComponent" || inner.type === "SlotElement" || inner.type === "SvelteFragment") && inner.attributes.some((attr) => attr.type === "Attribute" && attr.name === "slot")) {
        if (inner_start && !inner_end) {
          inner_end = inner.start;
        }
      } else if (!inner_start && !is_empty_text) {
        inner_start = inner.start;
      } else if (inner_end && !is_empty_text) {
        state.str.update(inner_end - 1, inner_end, "");
        state.str.prependLeft(inner_end - 1, state.str.original[inner_end - 1]);
        state.str.move(inner.start, inner.end, inner_end - 1);
      }
    }
    if (!inner_end) {
      inner_end = node.fragment.nodes[node.fragment.nodes.length - 1].end;
    }
    state.str.appendLeft(
      inner_start,
      `{#snippet ${snippet_name}(${props})}
${state.indent.repeat(path.length)}`
    );
    state.str.indent(state.indent, {
      exclude: [
        [0, inner_start],
        [inner_end, state.str.original.length]
      ]
    });
    if (inner_end < node.fragment.nodes[node.fragment.nodes.length - 1].end) {
      state.str.prependLeft(inner_end, `{/snippet}
${state.indent.repeat(path.length)}`);
    } else {
      state.str.prependLeft(
        inner_end,
        `${state.indent.repeat(path.length)}{/snippet}
${state.indent.repeat(path.length - 1)}`
      );
    }
  } else {
    state.str.prependLeft(
      node.start,
      `{#snippet ${snippet_name}(${props})}
${state.indent.repeat(path.length - 2)}`
    );
    state.str.indent(state.indent, {
      exclude: [
        [0, node.start],
        [node.end, state.str.original.length]
      ]
    });
    const str = `
${state.indent.repeat(path.length - 2)}{/snippet}`;
    if (node.type === "SlotElement") {
      state.str.appendRight(node.end, str);
    } else {
      state.str.appendLeft(node.end, str);
    }
  }
}
function extract_type_and_comment(declarator2, state, path) {
  var _a2, _b2;
  const str = state.str;
  const parent = path.at(-1);
  let comment_node = (
    /** @type {Node} */
    (_a2 = parent == null ? void 0 : parent.leadingComments) == null ? void 0 : _a2.at(-1)
  );
  const comment_start = (
    /** @type {any} */
    comment_node == null ? void 0 : comment_node.start
  );
  const comment_end = (
    /** @type {any} */
    comment_node == null ? void 0 : comment_node.end
  );
  let comment = comment_node && str.original.substring(comment_start, comment_end);
  if (comment_node) {
    str.update(comment_start, comment_end, "");
  }
  if (declarator2.id.typeAnnotation) {
    state.has_type_or_fallback = true;
    let start = declarator2.id.typeAnnotation.start + 1;
    while (str.original[start] === " ") {
      start++;
    }
    return { type: str.original.substring(start, declarator2.id.typeAnnotation.end), comment };
  }
  let cleaned_comment_arr = comment == null ? void 0 : comment.split("\n").map(
    (line) => line.trim().replace(/^\/\/\s*/g, "").replace(/^\/\*\*?\s*/g, "").replace(/\s*\*\/$/g, "").replace(/^\*\s*/g, "")
  ).filter(Boolean);
  const first_at_comment = cleaned_comment_arr == null ? void 0 : cleaned_comment_arr.findIndex((line) => line.startsWith("@"));
  let cleaned_comment = cleaned_comment_arr == null ? void 0 : cleaned_comment_arr.slice(0, first_at_comment !== -1 ? first_at_comment : cleaned_comment_arr.length).join("\n");
  if ((parent == null ? void 0 : parent.type) === "ExportNamedDeclaration" && comment_node) {
    state.has_type_or_fallback = true;
    const match = /@type {(.+)}/.exec(comment_node.value);
    if (match) {
      return { type: match[1], comment: cleaned_comment };
    }
  }
  if (((_b2 = declarator2.init) == null ? void 0 : _b2.type) === "Literal") {
    state.has_type_or_fallback = true;
    const type = typeof declarator2.init.value;
    if (type === "string" || type === "number" || type === "boolean") {
      return { type, comment: state.uses_ts ? comment : cleaned_comment };
    }
  }
  return { type: "any", comment: state.uses_ts ? comment : cleaned_comment };
}
var modifier_order = [
  "preventDefault",
  "stopPropagation",
  "stopImmediatePropagation",
  "self",
  "trusted",
  "once"
];
function handle_events(element2, state) {
  const handlers = /* @__PURE__ */ new Map();
  for (const attribute of element2.attributes) {
    if (attribute.type !== "OnDirective") continue;
    let name = `on${attribute.name}`;
    if (attribute.modifiers.includes("capture")) {
      name += "capture";
    }
    const nodes = handlers.get(name) || [];
    nodes.push(attribute);
    handlers.set(name, nodes);
  }
  for (const [name, nodes] of handlers) {
    const handlers2 = [];
    let first = null;
    for (const node of nodes) {
      let body;
      if (node.expression) {
        body = state.str.original.substring(
          /** @type {number} */
          node.expression.start,
          /** @type {number} */
          node.expression.end
        );
      } else {
        body = `${state.names.bubble}('${node.name}')`;
        state.legacy_imports.add("createBubbler");
        state.script_insertions.add(
          `const ${state.names.bubble} = ${state.names.createBubbler}();`
        );
      }
      const has_passive = node.modifiers.includes("passive");
      const has_nonpassive = node.modifiers.includes("nonpassive");
      const modifiers2 = modifier_order.filter((modifier) => node.modifiers.includes(modifier));
      for (const modifier of modifiers2) {
        state.legacy_imports.add(modifier);
        body = `${state.names[modifier]}(${body})`;
      }
      if (has_passive || has_nonpassive) {
        const action = has_passive ? "passive" : "nonpassive";
        state.legacy_imports.add(action);
        state.str.overwrite(
          node.start,
          node.end,
          `use:${state.names[action]}={['${node.name}', () => ${body}]}`
        );
      } else {
        if (first) {
          let start = node.start;
          let end = node.end;
          while (/[\s\n]/.test(state.str.original[start - 1])) start -= 1;
          state.str.remove(start, end);
        } else {
          first = node;
        }
        handlers2.push(body);
      }
    }
    if (first) {
      let replacement;
      if (handlers2.length > 1) {
        state.legacy_imports.add("handlers");
        replacement = `${name}={${state.names.handlers}(${handlers2.join(", ")})}`;
      } else {
        const handler = handlers2[0];
        replacement = handler === name ? `{${handler}}` : `${name}={${handler}}`;
      }
      state.str.overwrite(first.start, first.end, replacement);
    }
  }
}
function get_node_range(source2, node) {
  var _a2, _b2;
  const first_leading_comment = (_a2 = node.leadingComments) == null ? void 0 : _a2[0];
  const last_trailing_comment = (_b2 = node.trailingComments) == null ? void 0 : _b2[node.trailingComments.length - 1];
  let start = (
    /** @type {number} */
    (first_leading_comment == null ? void 0 : first_leading_comment.start) ?? node.start
  );
  let end = (
    /** @type {number} */
    (last_trailing_comment == null ? void 0 : last_trailing_comment.end) ?? node.end
  );
  let idx = start;
  while (source2[idx - 1] !== "\n" && source2[idx - 1] !== "\r") {
    idx--;
    if (source2[idx] !== " " && source2[idx] !== "	") {
      idx = start;
      break;
    }
  }
  start = idx;
  return { start, end };
}
function handle_identifier(node, state, path) {
  var _a2, _b2;
  const parent = path.at(-1);
  if ((parent == null ? void 0 : parent.type) === "MemberExpression" && parent.property === node) return;
  if (state.analysis.uses_props && node.name !== "$$slots") {
    if (node.name === "$$props" || node.name === "$$restProps") {
      state.str.update(
        /** @type {number} */
        node.start,
        /** @type {number} */
        node.end,
        state.names.props
      );
    } else {
      const binding = state.scope.get(node.name);
      if ((binding == null ? void 0 : binding.kind) === "bindable_prop" && binding.node !== node) {
        state.str.prependLeft(
          /** @type {number} */
          node.start,
          `${state.names.props}.`
        );
      }
    }
  } else if (node.name === "$$restProps" && state.analysis.uses_rest_props) {
    state.str.update(
      /** @type {number} */
      node.start,
      /** @type {number} */
      node.end,
      state.names.rest
    );
  } else if (node.name === "$$slots" && state.analysis.uses_slots) {
    if ((parent == null ? void 0 : parent.type) === "MemberExpression") {
      if (state.analysis.custom_element) return;
      let name = parent.property.type === "Literal" ? parent.property.value : parent.property.name;
      let slot_name = name;
      const existing_prop = state.props.find((prop2) => prop2.slot_name === name);
      if (existing_prop) {
        name = existing_prop.local;
      } else if (name !== "default") {
        let new_name = state.scope.generate(name);
        if (new_name !== name) {
          throw new MigrationError(
            "This migration would change the name of a slot making the component unusable"
          );
        }
      }
      name = name === "default" ? "children" : name;
      if (!existing_prop) {
        state.props.push({
          local: name,
          exported: name,
          init: "",
          bindable: false,
          optional: true,
          slot_name,
          // if it's the first time we encounter this slot
          // we start with any and delegate to when the slot
          // is actually rendered (it might not happen in that case)
          // any is still a safe bet
          type: `import('svelte').Snippet<[any]>`,
          needs_refine_type: true
        });
      }
      state.str.update(
        /** @type {number} */
        node.start,
        parent.property.start,
        state.analysis.uses_props ? `${state.names.props}.` : ""
      );
      state.str.update(parent.property.start, parent.end, name);
    }
  } else if ((parent == null ? void 0 : parent.type) === "TSInterfaceDeclaration" || (parent == null ? void 0 : parent.type) === "TSTypeAliasDeclaration") {
    const members = parent.type === "TSInterfaceDeclaration" ? parent.body.body : (_a2 = parent.typeAnnotation) == null ? void 0 : _a2.members;
    if (Array.isArray(members)) {
      if (node.name === "$$Props") {
        state.has_type_or_fallback = true;
        for (const member2 of members) {
          const prop2 = state.props.find((prop3) => prop3.exported === member2.key.name);
          const type = state.str.original.substring(
            member2.typeAnnotation.typeAnnotation.start,
            member2.typeAnnotation.typeAnnotation.end
          );
          let comment;
          const comment_node = (_b2 = member2.leadingComments) == null ? void 0 : _b2.at(-1);
          if ((comment_node == null ? void 0 : comment_node.type) === "Block") {
            comment = state.str.original.substring(comment_node.start, comment_node.end);
          }
          if (prop2) {
            prop2.type = type;
            prop2.optional = member2.optional;
            prop2.comment = comment ?? prop2.comment;
          } else {
            state.props.push({
              local: member2.key.name,
              exported: member2.key.name,
              init: "",
              bindable: false,
              optional: member2.optional,
              type,
              comment,
              type_only: true
            });
          }
        }
        state.str.remove(parent.start, parent.end);
      }
    }
  }
}
function guess_indent(content) {
  const lines = content.split("\n");
  const tabbed = lines.filter((line) => /^\t+/.test(line));
  const spaced = lines.filter((line) => /^ {2,}/.test(line));
  if (tabbed.length === 0 && spaced.length === 0) {
    return "	";
  }
  if (tabbed.length >= spaced.length) {
    return "	";
  }
  const min = spaced.reduce((previous, current) => {
    var _a2;
    const count = ((_a2 = /^ +/.exec(current)) == null ? void 0 : _a2[0].length) ?? 0;
    return Math.min(count, previous);
  }, Infinity);
  return " ".repeat(min);
}

// node_modules/svelte/src/compiler/index.js
function compile(source2, options) {
  source2 = remove_bom(source2);
  reset_warning_filter(options.warningFilter);
  const validated = validate_component_options(options, "");
  reset(source2, validated);
  let parsed = parse2(source2);
  const { customElement: customElementOptions, ...parsed_options } = parsed.options || {};
  const combined_options = {
    ...validated,
    ...parsed_options,
    customElementOptions
  };
  if (parsed.metadata.ts) {
    parsed = {
      ...parsed,
      fragment: parsed.fragment && remove_typescript_nodes(parsed.fragment),
      instance: parsed.instance && remove_typescript_nodes(parsed.instance),
      module: parsed.module && remove_typescript_nodes(parsed.module)
    };
  }
  const analysis = analyze_component(parsed, source2, combined_options);
  const result = transform_component(analysis, source2, combined_options);
  result.ast = to_public_ast(source2, parsed, options.modernAst);
  return result;
}
function compileModule(source2, options) {
  source2 = remove_bom(source2);
  reset_warning_filter(options.warningFilter);
  const validated = validate_module_options(options, "");
  reset(source2, validated);
  const analysis = analyze_module(parse(source2, false), validated);
  return transform_module(analysis, source2, validated);
}
function parse3(source2, { filename: filename2, rootDir, modern } = {}) {
  source2 = remove_bom(source2);
  reset_warning_filter(() => false);
  reset(source2, { filename: filename2 ?? "(unknown)", rootDir });
  const ast = parse2(source2);
  return to_public_ast(source2, ast, modern);
}
function to_public_ast(source2, ast, modern) {
  var _a2;
  if (modern) {
    const clean = (node) => {
      delete node.metadata;
      delete node.parent;
    };
    (_a2 = ast.options) == null ? void 0 : _a2.attributes.forEach((attribute) => {
      clean(attribute);
      clean(attribute.value);
      if (Array.isArray(attribute.value)) {
        attribute.value.forEach(clean);
      }
    });
    return walk(ast, null, {
      _(node, { next: next2 }) {
        clean(node);
        next2();
      }
    });
  }
  return convert(source2, ast);
}
function remove_bom(source2) {
  if (source2.charCodeAt(0) === 65279) {
    return source2.slice(1);
  }
  return source2;
}
function walk2() {
  throw new Error(
    `'svelte/compiler' no longer exports a \`walk\` utility — please import it directly from 'estree-walker' instead`
  );
}
export {
  VERSION,
  compile,
  compileModule,
  migrate,
  parse3 as parse,
  preprocess,
  walk2 as walk
};
//# sourceMappingURL=svelte_compiler.js.map
